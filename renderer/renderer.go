package renderer

import (
	"bytes"
	"go/format"
	"text/template"

	"github.com/hanpama/pgmg/model"
)

func RenderSchema(packageName string, schema *model.Schema) ([]byte, error) {
	return executeAndFormat("schemafile", struct {
		PackageName  string
		Schema       *model.Schema
		Dependencies map[string]bool
	}{
		packageName,
		schema,
		schema.Dependencies(),
	})
}

func RenderTable(packageName string, table *model.Table) ([]byte, error) {
	return executeAndFormat("tablefile", struct {
		PackageName  string
		Table        *model.Table
		Dependencies map[string]bool
	}{
		packageName,
		table,
		table.Dependencies(),
	})
}

func RenderCommon(packageName string) ([]byte, error) {
	return executeAndFormat("commonfile", struct {
		PackageName string
	}{
		PackageName: packageName,
	})
}

func executeAndFormat(name string, data interface{}) (b []byte, err error) {
	var buff bytes.Buffer
	if err = tmpl.ExecuteTemplate(&buff, name, data); err != nil {
		return nil, err
	}
	return format.Source(buff.Bytes())
}

var tmpl = template.Must(template.New("pg").Parse(`
{{ define "schemafile" }}
// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package {{ .PackageName }}

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	{{ range $k, $v := .Dependencies -}}
	"{{$k}}"
	{{end}}
)

{{ range $i, $m := .Schema.Tables }}
{{ template "row" $m }}
{{ template "queries" $m}}
{{ template "sql" $m }}
{{ end -}}
{{ template "common" }}

{{- end }}



{{- define "tablefile" }}{{- $m := .Table }}
// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package {{ .PackageName }}

import (
	"context"
	"encoding/json"
	{{ range $k, $v := .Dependencies -}}
	"{{$k}}"
	{{end}}
)

{{ template "row" $m }}
{{ template "queries" $m}}
{{ template "sql" $m }}

{{ end -}}


{{- define "commonfile" }}
package {{ .PackageName }}

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
)
{{ template "common" }}

{{ end }}


{{- define "row" }}
{{- $m := . }}

// {{$m.CapitalName}}Row represents a row for table "{{$m.SQLName}}"
type {{$m.CapitalName}}Row struct {
	Data {{$m.CapitalName}}Data
}

type {{$m.CapitalName}}Data struct {
	{{- range $i, $p := $m.Columns}}
	{{$p.CapitalName}} {{$p.Type.InsertType}} ` + "`json:" + `"{{$p.SQLName}}"` + "`" + `
	{{- end}}
}

func New{{$m.CapitalName}}Row(data {{$m.CapitalName}}Data) *{{$m.CapitalName}}Row {
	return &{{$m.CapitalName}}Row{data}
}

func New{{$m.CapitalName}}Rows(data ...{{$m.CapitalName}}Data) {{$m.CapitalName}}Rows {
	rows := make({{$m.CapitalName}}Rows, len(data))
	for i, d := range data {
		rows[i] = New{{$m.CapitalName}}Row(d)
	}
	return rows
}

{{- range $i, $p := $m.Columns}}

{{ if or $p.HasDefault $p.Nullable }}
// Get{{$p.CapitalName}} gets value of column "{{$p.SQLName}}" from "{{$m.SQLName}}" row
func (r *{{$m.CapitalName}}Row) Get{{$p.CapitalName}}() {{$p.Type.BaseType}} { return *r.Data.{{$p.CapitalName}} }

// Set{{$p.CapitalName}} sets value of column "{{$p.SQLName}}" in "{{$m.SQLName}}" row
func (r *{{$m.CapitalName}}Row) Set{{$p.CapitalName}} ({{$p.LowerName}} {{$p.Type.BaseType}}) { r.Data.{{$p.CapitalName}} = &{{$p.LowerName}} }

// Clear{{$p.CapitalName}} sets value of column "{{$p.SQLName}}" null in "{{$m.SQLName}}" row
func (r *{{$m.CapitalName}}Row) Clear{{$p.CapitalName}} () { r.Data.{{$p.CapitalName}} = nil }

// HasValid{{$p.CapitalName}} checks to value of column "{{$p.SQLName}}" is not null
func (r *{{$m.CapitalName}}Row) HasValid{{$p.CapitalName}}() bool { return r.Data.{{$p.CapitalName}} != nil }

{{- else}}
// Get{{$p.CapitalName}} gets value of column "{{$p.SQLName}}" from "{{$m.SQLName}}" row
func (r *{{$m.CapitalName}}Row) Get{{$p.CapitalName}}() {{$p.Type.SelectType}} { return r.Data.{{$p.CapitalName}} }

// Set{{$p.CapitalName}} sets value of column "{{$p.SQLName}}" in "{{$m.SQLName}}" row
func (r *{{$m.CapitalName}}Row) Set{{$p.CapitalName}} ({{$p.LowerName}} {{$p.Type.BaseType}}) { r.Data.{{$p.CapitalName}} = {{$p.LowerName}} }
{{- end}}

{{- end}}



{{ range $j, $k := $m.Keys -}}
// {{$k.TypeName}} represents key defined by {{if $k.IsPrimaryKey}}PRIMARY KEY{{else}}UNIQUE{{end}} constraint "{{$k.SQLName}}" for table "{{$m.SQLName}}"
type {{$k.TypeName}} struct {
	{{- range $h, $p := $k.Columns }}
	{{$p.CapitalName}} {{$p.Type.SelectType}} ` + "`json:" + `"{{$p.SQLName}}"` + "`" + `
	{{- end }}
}

func (r *{{$m.CapitalName}}Row) Key{{$k.CapitalName}}() {{$k.TypeName}} {
	return {{$k.TypeName}}{ {{range $h, $p := $k.Columns}}r.Get{{$p.CapitalName}}(),{{end}} }
}
{{ end }}

// {{$m.CapitalName}}Rows represents multiple rows for table "{{$m.SQLName}}"
type {{$m.CapitalName}}Rows []*{{$m.CapitalName}}Row

{{ range $j, $k := $m.Keys }}

func (rs {{$m.CapitalName}}Rows) Key{{$k.CapitalName}}() (keys Keys) {
	keys = make(Keys, len(rs))
	for i, r := range rs {
		keys[i] = r.Key{{$k.CapitalName}}()
	}
	return keys
}
{{ end }}


{{ range $j, $k := $m.ForeignKeys -}}
func (r *{{$m.CapitalName}}Row) Ref{{$k.CapitalName}}() {{$k.TypeName}} {
	return {{$k.TypeName}}{ {{range $h, $p := $k.Columns}}r.Get{{$p.CapitalName}}(),{{end}} }
}

func (rs {{$m.CapitalName}}Rows) Ref{{$k.CapitalName}}() (keys Keys) {
	keys = make(Keys, len(rs))
	for i, r := range rs {
		{{- range $h, $p := $k.Columns}}
		{{- if $p.Nullable}}
		if !r.HasValid{{$p.CapitalName}}() {
			continue
		}
		{{- end}}
		{{- end}}
		keys[i] = r.Ref{{$k.CapitalName}}()
	}
	return keys
}
{{ end }}


{{ end -}}


{{ define "queries" -}}
{{ $m := . -}}
{{- $pk := $m.PrimaryKey }}

// New{{$m.CapitalName}}Table(h SQLHandle) creates new {{$m.CapitalName}}Table
func New{{$m.CapitalName}}Table(h SQLHandle) *{{$m.CapitalName}}Table {
	return &{{$m.CapitalName}}Table{h}
}

// {{$m.CapitalName}}Table provides access methods for table "{{$m.SQLName}}"
type {{$m.CapitalName}}Table struct {
	h SQLHandle
}

func (t *{{$m.CapitalName}}Table) Find(ctx context.Context, filter {{$m.CapitalName}}Values) ({{$m.CapitalName}}Rows, error) {
	return Find{{$m.CapitalName}}Rows(ctx, t.h, filter)
}

func (t *{{$m.CapitalName}}Table) Count(ctx context.Context, filter {{$m.CapitalName}}Values) (int, error) {
	return Count{{$m.CapitalName}}Rows(ctx, t.h, filter)
}

func (t *{{$m.CapitalName}}Table) Update(ctx context.Context, changeset, filter {{$m.CapitalName}}Values) (int64, error) {
	return Update{{$m.CapitalName}}Rows(ctx, t.h, changeset, filter)
}

func (t *{{$m.CapitalName}}Table) Insert(ctx context.Context, rows ...*{{$m.CapitalName}}Row) (int, error) {
	return InsertReturning{{$m.CapitalName}}Rows(ctx, t.h, rows...)
}

func (t *{{$m.CapitalName}}Table) Delete(ctx context.Context, filter {{$m.CapitalName}}Values) (int64, error) {
	return Delete{{$m.CapitalName}}Rows(ctx, t.h, filter)
}

{{if $pk}}
func (t *{{$m.CapitalName}}Table) Save(ctx context.Context, rows ...*{{$m.CapitalName}}Row) error {
	return SaveReturning{{$m.CapitalName}}Rows(ctx, t.h, rows...)
}
{{end}}

{{range $i, $k := $m.Keys}}
func (t *{{$m.CapitalName}}Table) GetBy{{$k.CapitalName}}(ctx context.Context, keys ...interface{}) ({{$m.CapitalName}}Rows, error) {
	return Get{{$m.CapitalName}}RowsBy{{$k.CapitalName}}(ctx, t.h, keys...)
}

func (t *{{$m.CapitalName}}Table) UpdateBy{{$k.CapitalName}}(ctx context.Context, changeset {{$m.CapitalName}}Values, keys ...interface{}) (int64, error) {
	return Update{{$m.CapitalName}}RowsBy{{$k.CapitalName}}(ctx, t.h, changeset, keys...)
}

func (t *{{$m.CapitalName}}Table) DeleteBy{{$k.CapitalName}}(ctx context.Context, keys ...interface{}) (int64, error) {
	return Delete{{$m.CapitalName}}RowsBy{{$k.CapitalName}}(ctx, t.h, keys...)
}
{{end}}



type {{$m.CapitalName}}Values struct {
	{{- range $i, $p := $m.Columns}}
	{{$p.CapitalName}} {{$p.Type.FilterType}} ` + "`json:" + `"{{$p.SQLName}}"` + "`" + `
	{{- end}}
}

// Insert{{$m.CapitalName}}Rows inserts the rows into table "{{$m.SQLName}}"
func Insert{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, rows ...*{{$m.CapitalName}}Row) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLInsert{{$m.CapitalName}}Rows, rows)
	if err != nil {
		return numRows, formatError("Insert{{$m.CapitalName}}Rows", err)
	}
	return numRows, nil
}

// InsertReturning{{$m.CapitalName}}Rows inserts the rows into table "{{$m.SQLName}}" and returns the rows.
func InsertReturning{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, inputs ...*{{$m.CapitalName}}Row) (numRows int, err error) {
	rows := {{$m.CapitalName}}Rows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturning{{$m.CapitalName}}Rows, rows)
	if err != nil {
		return numRows, formatError("InsertReturning{{$m.CapitalName}}Rows", err)
	}
	return numRows, nil
}

// Find{{$m.CapitalName}}Rows finds the rows matching the condition from table "{{$m.SQLName}}"
func Find{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, cond {{$m.CapitalName}}Values) (rows {{$m.CapitalName}}Rows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFind{{$m.CapitalName}}Rows, cond); err != nil {
		return nil, formatError("Find{{$m.CapitalName}}Rows", err)
	}
	return rows, nil
}

// Delete{{$m.CapitalName}}Rows deletes the rows matching the condition from table "{{$m.SQLName}}"
func Delete{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, cond {{$m.CapitalName}}Values) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDelete{{$m.CapitalName}}Rows, cond); err != nil {
		return numRows, formatError("Delete{{$m.CapitalName}}Rows", err)
	}
	return numRows, nil
}

func Update{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, changeset, filter {{$m.CapitalName}}Values) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdate{{$m.CapitalName}}Rows, changeset, filter); err != nil {
		return numRows, formatError("Update{{$m.CapitalName}}Rows", err)
	}
	return numRows, nil
}

// Count{{$m.CapitalName}}Rows counts the number of rows matching the condition from table "{{$m.SQLName}}"
func Count{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, cond {{$m.CapitalName}}Values) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count } }, SQLCount{{$m.CapitalName}}Rows, cond); err != nil {
		return 0, formatError("Count{{$m.CapitalName}}Rows", err)
	}
	return count, nil
}

{{if $pk}}
// Save{{$m.CapitalName}}Rows upserts the given rows for table "{{$m.SQLName}}" checking uniqueness by contstraint "{{$pk.SQLName}}"
func Save{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, rows ...*{{$m.CapitalName}}Row) (err error) {
	_, err = execWithJSONArgs(ctx, db, SQLSave{{$m.CapitalName}}Rows, rows);
	if err != nil {
		return formatError("Save{{$m.CapitalName}}Rows", err)
	}
	return nil
}

// SaveReturning{{$m.CapitalName}}Rows upserts the given rows for table "{{$m.SQLName}}" checking uniqueness by contstraint "{{$pk.SQLName}}"
// It returns the new values and scan them into given row references.
func SaveReturning{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, inputs ...*{{$m.CapitalName}}Row) (err error) {
	rows := {{$m.CapitalName}}Rows(inputs)
	_, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLSaveReturning{{$m.CapitalName}}Rows, rows)
	if err != nil {
		return formatError("SaveReturning{{$m.CapitalName}}Rows", err)
	}
	return nil
}
{{end}}


{{ range $j, $k := $m.Keys -}}

// Get{{$m.CapitalName}}RowsBy{{$k.CapitalName}} gets matching rows for given {{$k.CapitalName}} keys from table "{{$m.SQLName}}"
func Get{{$m.CapitalName}}RowsBy{{$k.CapitalName}}(ctx context.Context, db SQLHandle, keys ...interface{}) (rows {{$m.CapitalName}}Rows, err error) {
	rows = make({{$m.CapitalName}}Rows, 0, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLGet{{$m.CapitalName}}RowsBy{{$k.CapitalName}}, Keys(keys)); err != nil {
		return nil, formatError("Get{{$m.CapitalName}}RowsBy{{$k.CapitalName}}", err)
	}
	return rows, nil
}

// Delete{{$m.CapitalName}}RowsBy{{$k.CapitalName}} deletes matching rows by {{$k.TypeName}} keys from table "{{$m.SQLName}}"
func Delete{{$m.CapitalName}}RowsBy{{$k.CapitalName}}(ctx context.Context, db SQLHandle, keys ...interface{}) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLDelete{{$m.CapitalName}}RowsBy{{$k.CapitalName}}, keys)
	if err != nil {
		return numRows, formatError("Delete{{$m.CapitalName}}RowsBy{{$k.CapitalName}}", err)
	}
	return numRows, nil
}

// Update{{$m.CapitalName}}RowsBy{{$k.CapitalName}} deletes matching rows by {{$k.TypeName}} keys from table "{{$m.SQLName}}"
func Update{{$m.CapitalName}}RowsBy{{$k.CapitalName}}(ctx context.Context, db SQLHandle, changeset {{$m.CapitalName}}Values, keys ...interface{}) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLUpdate{{$m.CapitalName}}RowsBy{{$k.CapitalName}}, changeset, keys)
	if err != nil {
		return numRows, formatError("Update{{$m.CapitalName}}RowsBy{{$k.CapitalName}}", err)
	}
	return numRows, nil
}

{{ end }}

// ReceiveRow returns all pointers of the column values for scanning
func (r *{{$m.CapitalName}}Row) ReceiveRow() []interface{} {
	return []interface{}{
		{{- range $i, $p := $m.Columns -}}
		{{- if $i}}, {{end}}&r.Data.{{$p.CapitalName -}}
		{{- end -}}
	}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *{{$m.CapitalName}}Rows) ReceiveRows(i int) []interface{} {
	if len(*rs) <= i {
		*rs = append(*rs, new({{$m.CapitalName}}Row))
	} else if (*rs)[i] == nil {
		(*rs)[i] = new({{$m.CapitalName}}Row)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *{{$m.CapitalName}}Row) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Data)
}
{{ end -}}


{{ define "sql" -}}
{{ $m := . -}}
{{ $pk := $m.PrimaryKey }}
var (
	SQLFind{{$m.CapitalName}}Rows = ` + "`" + `
		WITH __f AS (SELECT {{range $i, $p := $m.Columns }}{{if $i}}, {{end}}"{{$p.SQLName}}"{{end}} FROM json_populate_record(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		SELECT {{range $i, $p := $m.Columns }}{{if $i}}, {{end}}__t.{{$p.SQLName}}{{end}}
		FROM "{{$m.Schema}}"."{{$m.SQLName}}" AS __t
		WHERE {{ range $i, $p := $m.Columns -}}{{if $i}}
			AND {{end -}}
			((SELECT __f."{{$p.SQLName}}" IS NULL FROM __f) OR (SELECT __f."{{$p.SQLName}}" = __t."{{$p.SQLName}}" FROM __f))
			{{- end }}` + "`" + `
	SQLCount{{$m.CapitalName}}Rows = ` + "`" + `
		WITH __f AS (SELECT {{range $i, $p := $m.Columns }}{{if $i}}, {{end}}"{{$p.SQLName}}"{{end}} FROM json_populate_record(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		SELECT count(*) FROM "{{$m.Schema}}"."{{$m.SQLName}}" AS __t
		WHERE {{ range $i, $p := $m.Columns -}}{{if $i}}
			AND {{end -}}
			((SELECT __f."{{$p.SQLName}}" IS NULL FROM __f) OR (SELECT __f."{{$p.SQLName}}" = __t."{{$p.SQLName}}" FROM __f))
			{{- end }}` + "`" + `
	SQLReturning{{$m.CapitalName}}Rows = ` + "`" + `
		RETURNING {{ range $h, $p := $m.Columns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}` + "`" + `
	SQLInsert{{$m.CapitalName}}Rows = ` + "`" + `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		INSERT INTO "{{$m.Schema}}"."{{$m.SQLName}}" AS __t ({{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}})
		SELECT {{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end }}
			{{ if $p.HasDefault}}COALESCE(__v."{{$p.SQLName}}", {{$p.SQLDefault}})
			{{- else}}__v."{{$p.SQLName}}"
			{{- end}}
		{{- end}} FROM __v` + "`" + `
	SQLInsertReturning{{$m.CapitalName}}Rows = SQLInsert{{$m.CapitalName}}Rows + SQLReturning{{$m.CapitalName}}Rows
	SQLDelete{{$m.CapitalName}}Rows = ` + "`" + `
		DELETE FROM "{{$m.Schema}}"."{{$m.SQLName}}" AS __t
		WHERE TRUE
			{{- range $i, $p := $m.Columns }}
			AND (($1::json->>'{{$p.SQLName}}' IS NULL) OR CAST($1::json->>'{{$p.SQLName}}' AS {{$p.Type.SQLType}}) = __t."{{$p.SQLName}}")
			{{- end }}` + "`" + `
	SQLDeleteReturning{{$m.CapitalName}}Rows = SQLDelete{{$m.CapitalName}}Rows + SQLReturning{{$m.CapitalName}}Rows
	SQLUpdate{{$m.CapitalName}}Rows = ` + "`" + `
		WITH __v AS (SELECT * FROM json_populate_record(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"{{$m.Schema}}"."{{$m.SQLName}}", $2))
		UPDATE "{{$m.Schema}}"."{{$m.SQLName}}" AS __t
		SET ({{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}) = (SELECT {{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}
			COALESCE(__v."{{$p.SQLName}}", __t."{{$p.SQLName}}")
		{{- end}} FROM __v)
		WHERE {{ range $i, $p := $m.Columns -}}{{if $i}}
			AND {{end -}}
			((SELECT __f."{{$p.SQLName}}" IS NULL FROM __f) OR (SELECT __f."{{$p.SQLName}}" = __t."{{$p.SQLName}}" FROM __f))
			{{- end }}` + "`" + `
	SQLUpdateReturning{{$m.CapitalName}}Rows = SQLUpdate{{$m.CapitalName}}Rows + SQLReturning{{$m.CapitalName}}Rows
	{{- if $pk }}
	SQLReplace{{$m.CapitalName}}Rows = ` + "`" + `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		UPDATE "{{$m.Schema}}"."{{$m.SQLName}}" AS __t
			SET ({{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}) = (SELECT {{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}
				COALESCE(__v."{{$p.SQLName}}", __t."{{$p.SQLName}}")
			{{- end}}
			FROM __v WHERE {{ range $h, $p := $pk.Columns }}{{if $h }} AND {{end}}__v."{{$p.SQLName}}" = __t."{{$p.SQLName}}"{{end}})
		FROM __v WHERE {{ range $h, $p := $pk.Columns }}{{if $h }} AND {{end}}__v."{{$p.SQLName}}" = __t."{{$p.SQLName}}"{{end}}` + "`" + `
	SQLReplaceReturning{{$m.CapitalName}}Rows = SQLReplace{{$m.CapitalName}}Rows + SQLReturning{{$m.CapitalName}}Rows
	SQLSave{{$m.CapitalName}}Rows = ` + "`" + `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		INSERT INTO "{{$m.Schema}}"."{{$m.SQLName}}" AS __t ({{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}})
		SELECT {{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end }}
			{{ if $p.HasDefault}}COALESCE(__v."{{$p.SQLName}}", {{$p.SQLDefault}})
			{{- else}}__v."{{$p.SQLName}}"
			{{- end}}
		{{- end}} FROM __v
		ON CONFLICT ({{ range $h, $p := $pk.Columns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}) DO UPDATE
		SET ({{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}) = (
			SELECT {{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}} FROM __v
			WHERE {{ range $h, $p := $pk.Columns }}{{if $h }}
				AND {{end}}__v."{{$p.SQLName}}" = __t."{{$p.SQLName}}"{{end}}
		)` + "`" + `
	SQLSaveReturning{{$m.CapitalName}}Rows = SQLSave{{$m.CapitalName}}Rows + SQLReturning{{$m.CapitalName}}Rows
	{{- end }}
	{{- range $j, $k := $m.Keys }}
	SQLGet{{$m.CapitalName}}RowsBy{{$k.CapitalName}} = ` + "`" + `
		WITH __key AS (SELECT DISTINCT {{ range $h, $p := $k.Columns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}} FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		SELECT {{ range $h, $p := $m.Columns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}
		FROM __key JOIN "{{$m.Schema}}"."{{$m.SQLName}}" AS __t USING ({{ range $h, $p := $k.Columns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}})` + "`" + `
	SQLUpdate{{$m.CapitalName}}RowsBy{{$k.CapitalName}} = ` + "`" + `
		WITH __v AS (SELECT * FROM json_populate_record(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1)),
		  __key AS (SELECT {{ range $h, $p := $k.Columns }}{{if $h}}, {{end}}{{$p.SQLName}}{{end}} FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $2))
		UPDATE "{{$m.Schema}}"."{{$m.SQLName}}" AS __t
		SET ({{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}) = (SELECT
			{{- range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}
			COALESCE(__v."{{$p.SQLName}}", __t."{{$p.SQLName}}")
			{{- end}}
		FROM __v)
		FROM __key WHERE {{ range $h, $p := $k.Columns }}{{if $h }}AND {{end}}(__key."{{$p.SQLName}}" = __t."{{$p.SQLName}}"){{end}}` + "`" + `
	SQLDelete{{$m.CapitalName}}RowsBy{{$k.CapitalName}} = ` + "`" + `
		WITH __key AS (SELECT {{ range $h, $p := $k.Columns }}{{if $h}}, {{end}}{{$p.SQLName}}{{end}} FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		DELETE FROM "{{$m.Schema}}"."{{$m.SQLName}}" AS __t USING __key WHERE {{ range $h, $p := $k.Columns }}{{if $h }} AND {{end}}(__key."{{$p.SQLName}}" = __t."{{$p.SQLName}}"){{end}}` + "`" + `
	SQLDeleteReturning{{$m.CapitalName}}RowsBy{{$k.CapitalName}} = SQLDelete{{$m.CapitalName}}RowsBy{{$k.CapitalName}} + SQLReturning{{$m.CapitalName}}Rows
	{{- end }}
	)
{{- end -}}



{{- define "common" -}}
type Keys []interface{}

// Unique returns new Keys each key of which is unique and not null
func (ks Keys) Unique() (uks Keys) {
	seen := make(map[interface{}]struct{}, len(ks))
	uks = make(Keys, 0, len(uks))
	for _, k := range ks {
		if _, ok := seen[k]; !ok && k != nil {
			seen[k] = struct{}{}
			uks = append(uks, k)
		}
	}
	return uks
}

// MarshalJSON implements Marshaler
func (ks Keys) MarshalJSON() ([]byte, error) {
	var buff bytes.Buffer
	var err error
	buff.WriteRune('[')
	enc := json.NewEncoder(&buff)
	for i, k := range ks {
		if i > 0 {
			buff.WriteRune(',')
		}
		if err = enc.Encode(k); err != nil {
			return nil, err
		}
	}
	buff.WriteRune(']')
	return buff.Bytes(), nil
}

func execWithJSONArgs(ctx context.Context, db SQLHandle, sql string, args ...interface{}) (numRows int64, err error) {
	bArgs := make([]interface{}, len(args))
	for i, arg := range args {
		if bArgs[i], err = json.Marshal(arg); err != nil {
			return 0, err
		}
	}
	return db.ExecAndCount(ctx, sql, bArgs...)
}

func queryWithJSONArgs(ctx context.Context, db SQLHandle, receive func(int) []interface{}, sql string, args ...interface{}) (numRows int, err error) {
	bArgs := make([]interface{}, len(args))
	for i, arg := range args {
		if bArgs[i], err = json.Marshal(arg); err != nil {
			return 0, err
		}
	}
	return db.QueryAndReceive(ctx, receive, sql, bArgs...)
}

func formatError(methodName string, err error) error {
	return fmt.Errorf("%w(%s, %s)", ErrPGMG, methodName, err.Error())
}

var ErrPGMG = fmt.Errorf("errPGMG")

type SQLHandle interface {
	QueryAndReceive(ctx context.Context, receiver func(int) []interface{}, sql string, args ...interface{}) (int, error)
	ExecAndCount(ctx context.Context, sql string, args ...interface{}) (int64, error)
}
{{- end -}}
`))
