package renderer

import (
	"bytes"
	"go/format"
	"text/template"

	"github.com/hanpama/pgmg/model"
)

func RenderSchema(packageName string, schema *model.Schema) ([]byte, error) {
	return executeAndFormat("schemafile", struct {
		PackageName  string
		Schema       *model.Schema
		Dependencies map[string]bool
	}{
		packageName,
		schema,
		schema.Dependencies(),
	})
}

func RenderTable(packageName string, table *model.Table) ([]byte, error) {
	return executeAndFormat("tablefile", struct {
		PackageName  string
		Table        *model.Table
		Dependencies map[string]bool
	}{
		packageName,
		table,
		table.Dependencies(),
	})
}

func RenderCommon(packageName string) ([]byte, error) {
	return executeAndFormat("commonfile", struct {
		PackageName string
	}{
		PackageName: packageName,
	})
}

func executeAndFormat(name string, data interface{}) (b []byte, err error) {
	var buff bytes.Buffer
	if err = tmpl.ExecuteTemplate(&buff, name, data); err != nil {
		return nil, err
	}
	return format.Source(buff.Bytes())
}

var tmpl = template.Must(template.New("pg").Parse(`
{{ define "schemafile" }}
// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package {{ .PackageName }}

import (
	"context"
	"encoding/json"
	"fmt"
	{{ range $k, $v := .Dependencies -}}
	"{{$k}}"
	{{end}}
)

{{ range $i, $m := .Schema.Tables }}
{{ template "row" $m }}
{{ template "queries" $m}}
{{ template "key-methods" $m}}
{{ template "sql" $m }}
{{ end -}}
{{ template "common" }}

{{- end }}



{{- define "tablefile" }}{{- $m := .Table }}
// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package {{ .PackageName }}

import (
	"context"
	"encoding/json"
	{{ range $k, $v := .Dependencies -}}
	"{{$k}}"
	{{end}}
)

{{ template "row" $m }}
{{ template "queries" $m}}
{{ template "key-methods" $m}}
{{ template "sql" $m }}

{{ end -}}


{{- define "commonfile" }}
package {{ .PackageName }}

import (
	"context"
	"encoding/json"
	"fmt"
)
{{ template "common" }}

{{ end }}


{{- define "row" }}
{{- $m := . }}

// {{$m.CapitalName}}Row represents a row for table "{{$m.SQLName}}"
type {{$m.CapitalName}}Row struct {
	v {{$m.CapitalName}}Data
}

type {{$m.CapitalName}}Data struct {
	{{- range $i, $p := $m.Columns}}
	{{$p.CapitalName}} {{$p.Type.InsertType}} ` + "`json:" + `"{{$p.SQLName}}"` + "`" + `
	{{- end}}
}

func New{{$m.CapitalName}}Row(data {{$m.CapitalName}}Data) *{{$m.CapitalName}}Row {
	return &{{$m.CapitalName}}Row{data}
}

func New{{$m.CapitalName}}Rows(data ...{{$m.CapitalName}}Data) {{$m.CapitalName}}Rows {
	rows := make({{$m.CapitalName}}Rows, len(data))
	for i, d := range data {
		rows[i] = New{{$m.CapitalName}}Row(d)
	}
	return rows
}

{{- range $i, $p := $m.Columns}}

{{ if or $p.HasDefault $p.Nullable }}
// Get{{$p.CapitalName}} gets value of column "{{$p.SQLName}}" from "{{$m.SQLName}}" row
func (r *{{$m.CapitalName}}Row) Get{{$p.CapitalName}}() {{$p.Type.BaseType}} { return *r.v.{{$p.CapitalName}} }

// Set{{$p.CapitalName}} sets value of column "{{$p.SQLName}}" in "{{$m.SQLName}}" row
func (r *{{$m.CapitalName}}Row) Set{{$p.CapitalName}} ({{$p.LowerName}} {{$p.Type.BaseType}}) { r.v.{{$p.CapitalName}} = &{{$p.LowerName}} }

// Clear{{$p.CapitalName}} sets value of column "{{$p.SQLName}}" null in "{{$m.SQLName}}" row
func (r *{{$m.CapitalName}}Row) Clear{{$p.CapitalName}} () { r.v.{{$p.CapitalName}} = nil }

// HasValid{{$p.CapitalName}} checks to value of column "{{$p.SQLName}}" is not null
func (r *{{$m.CapitalName}}Row) HasValid{{$p.CapitalName}}() bool { return r.v.{{$p.CapitalName}} != nil }

{{- else}}
// Get{{$p.CapitalName}} gets value of column "{{$p.SQLName}}" from "{{$m.SQLName}}" row
func (r *{{$m.CapitalName}}Row) Get{{$p.CapitalName}}() {{$p.Type.SelectType}} { return r.v.{{$p.CapitalName}} }

// Set{{$p.CapitalName}} sets value of column "{{$p.SQLName}}" in "{{$m.SQLName}}" row
func (r *{{$m.CapitalName}}Row) Set{{$p.CapitalName}} ({{$p.LowerName}} {{$p.Type.BaseType}}) { r.v.{{$p.CapitalName}} = {{$p.LowerName}} }
{{- end}}

{{- end}}



{{ range $j, $k := $m.Keys -}}
// {{$k.TypeName}} represents key defined by {{if $k.IsPrimaryKey}}PRIMARY KEY{{else}}UNIQUE{{end}} constraint "{{$k.SQLName}}" for table "{{$m.SQLName}}"
type {{$k.TypeName}} struct {
	{{- range $h, $p := $k.Columns }}
	{{$p.CapitalName}} {{$p.Type.SelectType}} ` + "`json:" + `"{{$p.SQLName}}"` + "`" + `
	{{- end }}
}

func (r *{{$m.CapitalName}}Row) Key{{$k.CapitalName}}() {{$k.TypeName}} {
	return {{$k.TypeName}}{ {{range $h, $p := $k.Columns}}r.Get{{$p.CapitalName}}(),{{end}} }
}
{{ end }}

// {{$m.CapitalName}}Rows represents multiple rows for table "{{$m.SQLName}}"
type {{$m.CapitalName}}Rows []*{{$m.CapitalName}}Row

{{ range $j, $k := $m.Keys }}
// {{$k.TypeName}}Keyset is a set of key {{$k.TypeName}}
type {{$k.TypeName}}Keyset map[{{$k.TypeName}}]struct{}

func (rs {{$m.CapitalName}}Rows) Key{{$k.CapitalName}}() (keys {{$k.TypeName}}Keyset) {
	keys = make({{$k.TypeName}}Keyset)
	for _, r := range rs {
		keys[r.Key{{$k.CapitalName}}()] = struct{}{}
	}
	return keys
}
{{ end }}


{{ range $j, $k := $m.ForeignKeys -}}
func (r *{{$m.CapitalName}}Row) Ref{{$k.CapitalName}}() {{$k.TypeName}} {
	return {{$k.TypeName}}{ {{range $h, $p := $k.Columns}}r.Get{{$p.CapitalName}}(),{{end}} }
}

func (rs {{$m.CapitalName}}Rows) Ref{{$k.CapitalName}}() (keys {{$k.TypeName}}Keyset) {
	keys = make({{$k.TypeName}}Keyset)
	for _, r := range rs {
		keys[r.Ref{{$k.CapitalName}}()] = struct{}{}
	}
	return keys
}
{{ end }}

{{ end -}}


{{ define "queries" -}}
{{ $m := . -}}
{{- $pk := $m.PrimaryKey }}

// New{{$m.CapitalName}}Table(h SQLHandle) creates new {{$m.CapitalName}}Table
func New{{$m.CapitalName}}Table(h SQLHandle) *{{$m.CapitalName}}Table {
	return &{{$m.CapitalName}}Table{h}
}

// {{$m.CapitalName}}Table provides access methods for table "{{$m.SQLName}}"
type {{$m.CapitalName}}Table struct {
	h SQLHandle
}

func (t *{{$m.CapitalName}}Table) Find(ctx context.Context, filter {{$m.CapitalName}}Values) ({{$m.CapitalName}}Rows, error) {
	return Find{{$m.CapitalName}}Rows(ctx, t.h, filter)
}

func (t *{{$m.CapitalName}}Table) Count(ctx context.Context, filter {{$m.CapitalName}}Values) (int, error) {
	return Count{{$m.CapitalName}}Rows(ctx, t.h, filter)
}

func (t *{{$m.CapitalName}}Table) Update(ctx context.Context, changeset, filter {{$m.CapitalName}}Values) (int64, error) {
	return Update{{$m.CapitalName}}Rows(ctx, t.h, changeset, filter)
}

func (t *{{$m.CapitalName}}Table) Insert(ctx context.Context, rows ...*{{$m.CapitalName}}Row) (int, error) {
	return InsertReturning{{$m.CapitalName}}Rows(ctx, t.h, rows...)
}

func (t *{{$m.CapitalName}}Table) Delete(ctx context.Context, filter {{$m.CapitalName}}Values) (int64, error) {
	return Delete{{$m.CapitalName}}Rows(ctx, t.h, filter)
}

{{if $pk}}
func (t *{{$m.CapitalName}}Table) Save(ctx context.Context, rows ...*{{$m.CapitalName}}Row) error {
	return SaveReturning{{$m.CapitalName}}Rows(ctx, t.h, rows...)
}
{{end}}

{{range $i, $k := $m.Keys}}
func (t *{{$m.CapitalName}}Table) GetBy{{$k.CapitalName}}(ctx context.Context, keys ...{{$k.TypeName}}) ({{$m.CapitalName}}Rows, error) {
	return Get{{$m.CapitalName}}RowsBy{{$k.CapitalName}}(ctx, t.h, keys...)
}

func (t *{{$m.CapitalName}}Table) UpdateBy{{$k.CapitalName}}(ctx context.Context, changeset {{$m.CapitalName}}Values, keys ...{{$k.TypeName}}) (int64, error) {
	return Update{{$m.CapitalName}}RowsBy{{$k.CapitalName}}(ctx, t.h, changeset, keys...)
}

func (t *{{$m.CapitalName}}Table) DeleteBy{{$k.CapitalName}}(ctx context.Context, keys ...{{$k.TypeName}}) (int64, error) {
	return Delete{{$m.CapitalName}}RowsBy{{$k.CapitalName}}(ctx, t.h, keys...)
}
{{end}}



type {{$m.CapitalName}}Values struct {
	{{- range $i, $p := $m.Columns}}
	{{$p.CapitalName}} {{$p.Type.FilterType}} ` + "`json:" + `"{{$p.SQLName}}"` + "`" + `
	{{- end}}
}

// Insert{{$m.CapitalName}}Rows inserts the rows into table "{{$m.SQLName}}"
func Insert{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, rows ...*{{$m.CapitalName}}Row) (affected int64, err error) {
	affected, err = execWithJSONArgs(ctx, db, sqlInsert{{$m.CapitalName}}Rows, rows)
	if err != nil {
		return affected, formatError("Insert{{$m.CapitalName}}Rows", err)
	}
	return affected, nil
}

// InsertReturning{{$m.CapitalName}}Rows inserts the rows into table "{{$m.SQLName}}" and returns the rows.
func InsertReturning{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, inputs ...*{{$m.CapitalName}}Row) (affected int, err error) {
	rows := {{$m.CapitalName}}Rows(inputs)
	affected, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlInsertReturning{{$m.CapitalName}}Rows, rows)
	if err != nil {
		return affected, formatError("InsertReturning{{$m.CapitalName}}Rows", err)
	}
	return affected, nil
}

// Find{{$m.CapitalName}}Rows finds the rows matching the condition from table "{{$m.SQLName}}"
func Find{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, cond {{$m.CapitalName}}Values) (rows {{$m.CapitalName}}Rows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlFind{{$m.CapitalName}}Rows, cond); err != nil {
		return nil, err
	}
	return rows, nil
}

// Delete{{$m.CapitalName}}Rows deletes the rows matching the condition from table "{{$m.SQLName}}"
func Delete{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, cond {{$m.CapitalName}}Values) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlDelete{{$m.CapitalName}}Rows, cond)
}

func Update{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, changeset, filter {{$m.CapitalName}}Values) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlUpdate{{$m.CapitalName}}Rows, changeset, filter)
}

// Count{{$m.CapitalName}}Rows counts the number of rows matching the condition from table "{{$m.SQLName}}"
func Count{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, cond {{$m.CapitalName}}Values) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count } }, sqlCount{{$m.CapitalName}}Rows, cond); err != nil {
		return 0, err
	}
	return count, nil
}

{{if $pk}}
// Save{{$m.CapitalName}}Rows upserts the given rows for table "{{$m.SQLName}}" checking uniqueness by contstraint "{{$pk.SQLName}}"
func Save{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, rows ...*{{$m.CapitalName}}Row) (err error) {
	numRows, err := execWithJSONArgs(ctx, db, sqlSave{{$m.CapitalName}}Rows, rows);
	if err != nil {
		return formatError("Save", err)
	}
	if int64(len(rows)) != numRows {
		return formatError("Save", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// SaveReturning{{$m.CapitalName}}Rows upserts the given rows for table "{{$m.SQLName}}" checking uniqueness by contstraint "{{$pk.SQLName}}"
// It returns the new values and scan them into given row references.
func SaveReturning{{$m.CapitalName}}Rows(ctx context.Context, db SQLHandle, inputs ...*{{$m.CapitalName}}Row) (err error) {
	rows := {{$m.CapitalName}}Rows(inputs)
	numRows, err := queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlSaveReturning{{$m.CapitalName}}Rows, rows)
	if err != nil {
		return formatError("SaveReturning", err)
	}
	if len(rows) != numRows {
		return formatError("SaveReturning", ErrUnexpectedRowNumberAffected)
	}
	return nil
}
{{end}}


{{ range $j, $k := $m.Keys -}}

// Get{{$m.CapitalName}}RowsBy{{$k.CapitalName}} gets matching rows for given {{$k.CapitalName}} keys from table "{{$m.SQLName}}"
func Get{{$m.CapitalName}}RowsBy{{$k.CapitalName}}(ctx context.Context, db SQLHandle, keys ...{{$k.TypeName}}) (rows {{$m.CapitalName}}Rows, err error) {
	rows = make({{$m.CapitalName}}Rows, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlGet{{$m.CapitalName}}RowsBy{{$k.CapitalName}}, keys); err != nil {
		return nil, formatError("Get{{$m.CapitalName}}RowsBy{{$k.CapitalName}}", err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].Key{{$k.CapitalName}}() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// Delete{{$m.CapitalName}}RowsBy{{$k.CapitalName}} deletes matching rows by {{$k.TypeName}} keys from table "{{$m.SQLName}}"
func Delete{{$m.CapitalName}}RowsBy{{$k.CapitalName}}(ctx context.Context, db SQLHandle, keys ...{{$k.TypeName}}) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlDelete{{$m.CapitalName}}RowsBy{{$k.CapitalName}}, keys)
	if err != nil {
		return numRows, formatError("DeleteBy{{$k.CapitalName}}", err)
	}
	return numRows, nil
}

// Update{{$m.CapitalName}}RowsBy{{$k.CapitalName}} deletes matching rows by {{$k.TypeName}} keys from table "{{$m.SQLName}}"
func Update{{$m.CapitalName}}RowsBy{{$k.CapitalName}}(ctx context.Context, db SQLHandle, changeset {{$m.CapitalName}}Values, keys ...{{$k.TypeName}}) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlUpdate{{$m.CapitalName}}RowsBy{{$k.CapitalName}}, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateBy{{$k.CapitalName}}", err)
	}
	return numRows, nil
}



{{ end }}

func (r *{{$m.CapitalName}}Row) ReceiveRow() []interface{} {
	return []interface{}{
		{{- range $i, $p := $m.Columns -}}
		{{- if $i}}, {{end}}&r.v.{{$p.CapitalName -}}
		{{- end -}}
	}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *{{$m.CapitalName}}Rows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make({{$m.CapitalName}}Rows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new({{$m.CapitalName}}Row)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *{{$m.CapitalName}}Row) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.v)
}
{{ end -}}

{{ define "key-methods" }}
{{ $m := . -}}
{{- range $j, $k := $m.Keys }}
func (keyset {{$k.TypeName}}Keyset) Keys() (keys []{{$k.TypeName}}) {
	for k := range keyset {
		keys = append(keys, k)
	}
	return keys
}

func (keyset {{$k.TypeName}}Keyset) Add(keys ...{{$k.TypeName}}) {
	for _, k := range keys {
		keyset[k] = struct{}{}
	}
}

func (keyset {{$k.TypeName}}Keyset) Remove(keys ...{{$k.TypeName}}) {
	for _, k := range keys {
		delete(keyset, k)
	}
}
{{- end }}
{{- end }}

{{ define "sql" -}}
{{ $m := . -}}
{{ $pk := $m.PrimaryKey }}
var (
	sqlFind{{$m.CapitalName}}Rows = ` + "`" + `
		WITH __f AS (SELECT {{range $i, $p := $m.Columns }}{{if $i}}, {{end}}"{{$p.SQLName}}"{{end}} FROM json_populate_record(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		SELECT {{range $i, $p := $m.Columns }}{{if $i}}, {{end}}__t.{{$p.SQLName}}{{end}}
		FROM "{{$m.Schema}}"."{{$m.SQLName}}" AS __t
		WHERE {{ range $i, $p := $m.Columns -}}{{if $i}}
			AND {{end -}}
			((SELECT __f."{{$p.SQLName}}" IS NULL FROM __f) OR (SELECT __f."{{$p.SQLName}}" = __t."{{$p.SQLName}}" FROM __f))
			{{- end }}` + "`" + `
	sqlCount{{$m.CapitalName}}Rows = ` + "`" + `
		WITH __f AS (SELECT {{range $i, $p := $m.Columns }}{{if $i}}, {{end}}"{{$p.SQLName}}"{{end}} FROM json_populate_record(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		SELECT count(*) FROM "{{$m.Schema}}"."{{$m.SQLName}}" AS __t
		WHERE {{ range $i, $p := $m.Columns -}}{{if $i}}
			AND {{end -}}
			((SELECT __f."{{$p.SQLName}}" IS NULL FROM __f) OR (SELECT __f."{{$p.SQLName}}" = __t."{{$p.SQLName}}" FROM __f))
			{{- end }}` + "`" + `
	sqlReturning{{$m.CapitalName}}Rows = ` + "`" + `
		RETURNING {{ range $h, $p := $m.Columns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}` + "`" + `
	sqlInsert{{$m.CapitalName}}Rows = ` + "`" + `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		INSERT INTO "{{$m.Schema}}"."{{$m.SQLName}}" AS __t ({{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}})
		SELECT {{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end }}
			{{ if $p.HasDefault}}COALESCE(__v."{{$p.SQLName}}", {{$p.SQLDefault}})
			{{- else}}__v."{{$p.SQLName}}"
			{{- end}}
		{{- end}} FROM __v` + "`" + `
	sqlInsertReturning{{$m.CapitalName}}Rows = sqlInsert{{$m.CapitalName}}Rows + sqlReturning{{$m.CapitalName}}Rows
	sqlDelete{{$m.CapitalName}}Rows = ` + "`" + `
		DELETE FROM "{{$m.Schema}}"."{{$m.SQLName}}" AS __t
		WHERE TRUE
			{{- range $i, $p := $m.Columns }}
			AND (($1::json->>'{{$p.SQLName}}' IS NULL) OR CAST($1::json->>'{{$p.SQLName}}' AS {{$p.Type.SQLType}}) = __t."{{$p.SQLName}}")
			{{- end }}` + "`" + `
	sqlDeleteReturning{{$m.CapitalName}}Rows = sqlDelete{{$m.CapitalName}}Rows + sqlReturning{{$m.CapitalName}}Rows
	sqlUpdate{{$m.CapitalName}}Rows = ` + "`" + `
		WITH __v AS (SELECT * FROM json_populate_record(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"{{$m.Schema}}"."{{$m.SQLName}}", $2))
		UPDATE "{{$m.Schema}}"."{{$m.SQLName}}" AS __t
		SET ({{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}) = (SELECT {{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}
			COALESCE(__v."{{$p.SQLName}}", __t."{{$p.SQLName}}")
		{{- end}} FROM __v)
		WHERE {{ range $i, $p := $m.Columns -}}{{if $i}}
			AND {{end -}}
			((SELECT __f."{{$p.SQLName}}" IS NULL FROM __f) OR (SELECT __f."{{$p.SQLName}}" = __t."{{$p.SQLName}}" FROM __f))
			{{- end }}` + "`" + `
	sqlUpdateReturning{{$m.CapitalName}}Rows = sqlUpdate{{$m.CapitalName}}Rows + sqlReturning{{$m.CapitalName}}Rows
	{{- if $pk }}
	sqlReplace{{$m.CapitalName}}Rows = ` + "`" + `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		UPDATE "{{$m.Schema}}"."{{$m.SQLName}}" AS __t
			SET ({{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}) = (SELECT {{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}
				COALESCE(__v."{{$p.SQLName}}", __t."{{$p.SQLName}}")
			{{- end}}
			FROM __v WHERE {{ range $h, $p := $pk.Columns }}{{if $h }} AND {{end}}__v."{{$p.SQLName}}" = __t."{{$p.SQLName}}"{{end}})
		FROM __v WHERE {{ range $h, $p := $pk.Columns }}{{if $h }} AND {{end}}__v."{{$p.SQLName}}" = __t."{{$p.SQLName}}"{{end}}` + "`" + `
	sqlReplaceReturning{{$m.CapitalName}}Rows = sqlReplace{{$m.CapitalName}}Rows + sqlReturning{{$m.CapitalName}}Rows
	sqlSave{{$m.CapitalName}}Rows = ` + "`" + `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		INSERT INTO "{{$m.Schema}}"."{{$m.SQLName}}" AS __t ({{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}})
		SELECT {{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end }}
			{{ if $p.HasDefault}}COALESCE(__v."{{$p.SQLName}}", {{$p.SQLDefault}})
			{{- else}}__v."{{$p.SQLName}}"
			{{- end}}
		{{- end}} FROM __v
		ON CONFLICT ({{ range $h, $p := $pk.Columns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}) DO UPDATE
		SET ({{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}) = (
			SELECT {{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}} FROM __v
			WHERE {{ range $h, $p := $pk.Columns }}{{if $h }}
				AND {{end}}__v."{{$p.SQLName}}" = __t."{{$p.SQLName}}"{{end}}
		)` + "`" + `
	sqlSaveReturning{{$m.CapitalName}}Rows = sqlSave{{$m.CapitalName}}Rows + sqlReturning{{$m.CapitalName}}Rows
	{{- end }}
	{{- range $j, $k := $m.Keys }}
	sqlGet{{$m.CapitalName}}RowsBy{{$k.CapitalName}} = ` + "`" + `
		WITH __key AS (SELECT ROW_NUMBER() over () __idx, {{ range $h, $p := $k.Columns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}} FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		SELECT {{ range $h, $p := $m.Columns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}
		FROM __key JOIN "{{$m.Schema}}"."{{$m.SQLName}}" AS __t USING ({{ range $h, $p := $k.Columns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}})
		ORDER BY __idx` + "`" + `
	sqlUpdate{{$m.CapitalName}}RowsBy{{$k.CapitalName}} = ` + "`" + `
		WITH __v AS (SELECT * FROM json_populate_record(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1)),
		  __key AS (SELECT {{ range $h, $p := $k.Columns }}{{if $h}}, {{end}}{{$p.SQLName}}{{end}} FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $2))
		UPDATE "{{$m.Schema}}"."{{$m.SQLName}}" AS __t
		SET ({{ range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}"{{$p.SQLName}}"{{end}}) = (SELECT
			{{- range $h, $p := $m.UpdatableColumns }}{{if $h }}, {{end}}
			COALESCE(__v."{{$p.SQLName}}", __t."{{$p.SQLName}}")
			{{- end}}
		FROM __v)
		FROM __key WHERE {{ range $h, $p := $k.Columns }}{{if $h }}AND {{end}}(__key."{{$p.SQLName}}" = __t."{{$p.SQLName}}"){{end}}` + "`" + `
	sqlDelete{{$m.CapitalName}}RowsBy{{$k.CapitalName}} = ` + "`" + `
		WITH __key AS (SELECT {{ range $h, $p := $k.Columns }}{{if $h}}, {{end}}{{$p.SQLName}}{{end}} FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		DELETE FROM "{{$m.Schema}}"."{{$m.SQLName}}" AS __t USING __key WHERE {{ range $h, $p := $k.Columns }}{{if $h }} AND {{end}}(__key."{{$p.SQLName}}" = __t."{{$p.SQLName}}"){{end}}` + "`" + `
	sqlDeleteReturning{{$m.CapitalName}}RowsBy{{$k.CapitalName}} = sqlDelete{{$m.CapitalName}}RowsBy{{$k.CapitalName}} + sqlReturning{{$m.CapitalName}}Rows
	{{- end }}
	)
{{- end -}}



{{- define "common" -}}
func execWithJSONArgs(ctx context.Context, db SQLHandle, sql string, args ...interface{}) (numRows int64, err error) {
	bArgs := make([]interface{}, len(args))
	for i, arg := range args {
		if bArgs[i], err = json.Marshal(arg); err != nil {
			return 0, err
		}
	}
	return db.ExecAndCount(ctx, sql, bArgs...)
}

func queryWithJSONArgs(ctx context.Context, db SQLHandle, receive func(int) []interface{}, sql string, args ...interface{}) (numRows int, err error) {
	bArgs := make([]interface{}, len(args))
	for i, arg := range args {
		if bArgs[i], err = json.Marshal(arg); err != nil {
			return 0, err
		}
	}
	return db.QueryAndReceive(ctx, receive, sql, bArgs...)
}

func formatError(methodName string, err error) error {
	return fmt.Errorf("%w(%s, %s)", ErrPGMG, methodName, err.Error())
}

var ErrPGMG = fmt.Errorf("errPGMG")
var ErrUnexpectedRowNumberAffected = fmt.Errorf("unexpected row number affected")

type SQLHandle interface {
	QueryAndReceive(ctx context.Context, receiver func(int) []interface{}, sql string, args ...interface{}) (int, error)
	ExecAndCount(ctx context.Context, sql string, args ...interface{}) (int64, error)
}
{{- end -}}
`))
