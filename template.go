package main

import (
	"text/template"
)

var Tmpl = template.Must(template.New("pgmg").Parse(
	`{{- define "table_model" -}}
// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package {{ .PackageName }}

{{ if .Dependencies -}}
import (
	"context"
	"encoding/json"
	{{ range $k, $v := .Dependencies -}}
	"{{$k}}"
	{{end}}
)
{{- end }}

// PGMGDatabase represents PostgresQL database
type PGMGDatabase interface {
	QueryScan(ctx context.Context, receiver func(int) []interface{}, sql string, args ...interface{}) (int, error)
	Exec(ctx context.Context, sql string, args ...interface{}) (int64, error)
}

{{ range $i, $m := .Models }}
// {{$m.CapitalName}}Row represents a row for table "{{$m.SQLName}}"
type {{$m.CapitalName}}Row struct {
	{{- range $i, $p := $m.Properties}}
	{{$p.CapitalName}} {{$p.GoInsertType}} ` + "`json:" + `"{{$p.SQLName}}"` + "`" + `
	{{- end}}
}

{{ range $i, $p := $m.Properties }}
// {{$m.CapitalName}}Row{{$p.CapitalName}} represents column "{{$p.SQLName}}" of table "{{$m.SQLName}}"
type {{$m.CapitalName}}Row{{$p.CapitalName}} {{$p.GoInsertType}}
{{- end }}

// New{{$m.CapitalName}}Row creates a new row for table "{{$m.SQLName}}" with all column values
func New{{$m.CapitalName}}Row(
	{{- range $i, $p := $m.Properties }}
	{{$p.LowerName}} {{$m.CapitalName}}Row{{$p.CapitalName}},
	{{- end }}
) *{{$m.CapitalName}}Row {
	return &{{$m.CapitalName}}Row{
		{{- range $i, $p := $m.Properties }}
		({{$p.GoInsertType}})({{$p.LowerName}}),
		{{- end }}
	}
}

func (r *{{$m.CapitalName}}Row) receive() []interface{} {
	return []interface{}{
		{{- range $i, $p := $m.Properties -}}
		{{if $i}}, {{end}}&r.{{$p.CapitalName}}
		{{- end -}}
	}
}
{{ end -}}

{{ range $i, $m := .Models }}{{ range $j, $k := $m.Keys }}
// {{$k.CapitalName}} represents key defined by UNIQUE constraint "{{$k.SQLName}}" for table "{{$m.SQLName}}"
type {{$k.CapitalName}} struct {
	{{- range $h, $p := $k.Properties }}
	{{$p.CapitalName}} {{$p.GoSelectType}} ` + "`json:" + `"{{$p.SQLName}}"` + "`" + `
	{{- end }}
}

func (r *{{$m.CapitalName}}Row) {{$k.CapitalName}}() {{$k.CapitalName}} {
	k := {{$k.CapitalName}}{}
	{{- range $h, $p := $k.Properties }}
	{{- if $p.Default}}
	if r.{{$p.CapitalName}} != nil {
		k.{{$p.CapitalName}} = *r.{{$p.CapitalName}}
	}
	{{- else}}
	k.{{$p.CapitalName}} = r.{{$p.CapitalName}}
	{{end}}
	{{- end }}
	return k
}

// GetBy{{$k.CapitalName}} gets matching rows for given {{$k.CapitalName}} keys from table "{{$m.SQLName}}"
func GetBy{{$k.CapitalName}}(ctx context.Context, db PGMGDatabase, keys ...{{$k.CapitalName}}) (rows []*{{$m.CapitalName}}Row, err error) {
	var b []byte
	if b, err = json.Marshal(keys); err != nil {
		return nil, err
	}
	rows = make([]*{{$m.CapitalName}}Row, len(keys))
	if _, err = db.QueryScan(ctx, func(i int) []interface{} {
		rows[i] = &{{$m.CapitalName}}Row{}
		return rows[i].receive()
	}, ` + "`" + `
		WITH __key AS (
			SELECT ROW_NUMBER() over () __keyindex,
				{{ range $h, $p := $k.Properties }}{{if $h }}, {{end}}{{$p.SQLName}}{{end}}
			FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1)
		)
		SELECT {{ range $h, $p := $m.Properties }}{{if $h }}, {{end}}{{$p.SQLName}}{{end}}
		FROM __key JOIN "{{$m.Schema}}"."{{$m.SQLName}}" AS __table USING ({{ range $h, $p := $k.Properties }}{{if $h }}, {{end}}{{$p.SQLName}}{{end}})
		ORDER BY __keyindex
  ` + "`" + `, string(b)); err != nil {
		return nil, err
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].{{$k.CapitalName}}() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// SaveBy{{$k.CapitalName}} upserts the given rows for table "{{$m.SQLName}}" checking uniqueness by contstraint "{{$k.SQLName}}"
func SaveBy{{$k.CapitalName}}(ctx context.Context, db PGMGDatabase, rows ...*{{$m.CapitalName}}Row) ([]*{{$m.CapitalName}}Row, error) {
	b, err := json.Marshal(rows);
	if err != nil {
		return rows, err
	}
	_, err = db.QueryScan(ctx, func(i int) []interface{} { return rows[i].receive() }, ` + "`" + `
		WITH __values AS (
			SELECT
				{{ range $h, $p := $m.Properties }}{{if $h }},
			  {{end -}}
				{{- if $p.Default}}COALESCE(__input.{{$p.SQLName}}, {{$p.Default}}) {{$p.SQLName}}
				{{- else}}__input.{{$p.SQLName}}
				{{- end}}
			{{- end}}
			FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1) __input
		)
		INSERT INTO "{{$m.Schema}}"."{{$m.SQLName}}" SELECT * FROM __values
		ON CONFLICT ({{ range $h, $p := $k.Properties }}{{if $h }}, {{end}}{{$p.SQLName}}{{end}}) DO UPDATE
			SET ({{ range $h, $p := $m.Properties }}{{if $h }}, {{end}}{{$p.SQLName}}{{end}}) = (
				SELECT {{ range $h, $p := $m.Properties }}{{if $h }}, {{end}}{{$p.SQLName}}{{end}} FROM __values
			)
		RETURNING {{ range $h, $p := $m.Properties }}{{if $h }}, {{end}}{{$p.SQLName}}{{end}}
	` + "`" + `, string(b))
	return rows, err
}

// DeleteBy{{$k.CapitalName}} deletes matching rows by {{$k.CapitalName}} keys from table "{{$m.SQLName}}"
func DeleteBy{{$k.CapitalName}}(ctx context.Context, db PGMGDatabase, keys ...{{$k.CapitalName}}) (int64, error) {
	b, err := json.Marshal(keys);
	if err != nil {
		return 0, err
	}
	return db.Exec(ctx, ` + "`" + `
		WITH __key AS (SELECT * FROM json_populate_recordset(null::"{{$m.Schema}}"."{{$m.SQLName}}", $1))
		DELETE FROM "{{$m.Schema}}"."{{$m.SQLName}}" AS __table
			USING __key
			WHERE {{ range $h, $p := $k.Properties }}{{if $h }}  AND {{end}}(__key.{{$p.SQLName}} = __table.{{$p.SQLName}})
			{{ end -}}
	` + "`" + `, string(b))
}
{{end}}{{ end}}

{{ end -}}
	`,
))
