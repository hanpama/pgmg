// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package example

import (
	"context"
	"encoding/json"
	"fmt"
	"time"
)

// Semester represents a row for table "semester"
type Semester struct {
	ID     *int32 `json:"id"`
	Year   int32  `json:"year"`
	Season string `json:"season"`
}

// SemesterRows represents multiple rows for table "semester"
type SemesterRows []*Semester

// Product represents a row for table "product"
type Product struct {
	ID      *int32     `json:"id"`
	Price   float64    `json:"price"`
	Stocked time.Time  `json:"stocked"`
	Sold    *time.Time `json:"sold"`
}

// ProductRows represents multiple rows for table "product"
type ProductRows []*Product

// NewPGMGRepository creates a new PGMGRepository
func NewPGMGRepository(db PGMGDatabase) *PGMGRepository {
	return &PGMGRepository{db}
}

// PGMGRepository provides methods which get, insert, save and delete rows in db
type PGMGRepository struct {
	db PGMGDatabase
}

func (rep *PGMGRepository) InsertSemesterRows(ctx context.Context, rows ...*Semester) error {
	return InsertSemesterRows(ctx, rep.db, rows...)
}

func (rep *PGMGRepository) InsertAndReturnSemesterRows(ctx context.Context, rows ...*Semester) (SemesterRows, error) {
	return InsertAndReturnSemesterRows(ctx, rep.db, rows...)
}

// GetBySemesterPkey gets matching rows for given SemesterPkey keys from table "semester"
func (rep *PGMGRepository) GetBySemesterPkey(ctx context.Context, keys ...SemesterPkey) (rows SemesterRows, err error) {
	return GetBySemesterPkey(ctx, rep.db, keys...)
}

// SaveBySemesterPkey upserts the given rows for table "semester" checking uniqueness by contstraint "semester_pkey"
func (rep *PGMGRepository) SaveBySemesterPkey(ctx context.Context, rows ...*Semester) error {
	return SaveBySemesterPkey(ctx, rep.db, rows...)
}

// SaveAndReturnBySemesterPkey upserts the given rows for table "semester" checking uniqueness by contstraint "semester_pkey"
// It returns the new values and scan them into given row references.
func (rep *PGMGRepository) SaveAndReturnBySemesterPkey(ctx context.Context, rows ...*Semester) (SemesterRows, error) {
	return SaveAndReturnBySemesterPkey(ctx, rep.db, rows...)
}

// DeleteBySemesterPkey deletes matching rows by SemesterPkey keys from table "semester"
func (rep *PGMGRepository) DeleteBySemesterPkey(ctx context.Context, keys ...SemesterPkey) (int64, error) {
	return DeleteBySemesterPkey(ctx, rep.db, keys...)
}

// GetBySemesterYearSeasonKey gets matching rows for given SemesterYearSeasonKey keys from table "semester"
func (rep *PGMGRepository) GetBySemesterYearSeasonKey(ctx context.Context, keys ...SemesterYearSeasonKey) (rows SemesterRows, err error) {
	return GetBySemesterYearSeasonKey(ctx, rep.db, keys...)
}

// SaveBySemesterYearSeasonKey upserts the given rows for table "semester" checking uniqueness by contstraint "semester_year_season_key"
func (rep *PGMGRepository) SaveBySemesterYearSeasonKey(ctx context.Context, rows ...*Semester) error {
	return SaveBySemesterYearSeasonKey(ctx, rep.db, rows...)
}

// SaveAndReturnBySemesterYearSeasonKey upserts the given rows for table "semester" checking uniqueness by contstraint "semester_year_season_key"
// It returns the new values and scan them into given row references.
func (rep *PGMGRepository) SaveAndReturnBySemesterYearSeasonKey(ctx context.Context, rows ...*Semester) (SemesterRows, error) {
	return SaveAndReturnBySemesterYearSeasonKey(ctx, rep.db, rows...)
}

// DeleteBySemesterYearSeasonKey deletes matching rows by SemesterYearSeasonKey keys from table "semester"
func (rep *PGMGRepository) DeleteBySemesterYearSeasonKey(ctx context.Context, keys ...SemesterYearSeasonKey) (int64, error) {
	return DeleteBySemesterYearSeasonKey(ctx, rep.db, keys...)
}

// SemesterCondition is used for quering table "semester"
type SemesterCondition struct {
	ID     *int32  `json:"id"`
	Year   *int32  `json:"year"`
	Season *string `json:"season"`
}

// FindSemesterRows find the rows matching the condition from table "semester"
func (rep *PGMGRepository) FindSemesterRows(ctx context.Context, cond SemesterCondition) (SemesterRows, error) {
	return FindSemesterRows(ctx, rep.db, cond)
}

// DeleteSemesterRows delete the rows matching the condition from table "semester"
func (rep *PGMGRepository) DeleteSemesterRows(ctx context.Context, cond SemesterCondition) (afftected int64, err error) {
	return DeleteSemesterRows(ctx, rep.db, cond)
}

// CountSemesterRows counts the number of rows matching the condition from table "semester"
func (rep *PGMGRepository) CountSemesterRows(ctx context.Context, cond SemesterCondition) (int, error) {
	return CountSemesterRows(ctx, rep.db, cond)
}

func (rep *PGMGRepository) InsertProductRows(ctx context.Context, rows ...*Product) error {
	return InsertProductRows(ctx, rep.db, rows...)
}

func (rep *PGMGRepository) InsertAndReturnProductRows(ctx context.Context, rows ...*Product) (ProductRows, error) {
	return InsertAndReturnProductRows(ctx, rep.db, rows...)
}

// GetByProductPkey gets matching rows for given ProductPkey keys from table "product"
func (rep *PGMGRepository) GetByProductPkey(ctx context.Context, keys ...ProductPkey) (rows ProductRows, err error) {
	return GetByProductPkey(ctx, rep.db, keys...)
}

// SaveByProductPkey upserts the given rows for table "product" checking uniqueness by contstraint "product_pkey"
func (rep *PGMGRepository) SaveByProductPkey(ctx context.Context, rows ...*Product) error {
	return SaveByProductPkey(ctx, rep.db, rows...)
}

// SaveAndReturnByProductPkey upserts the given rows for table "product" checking uniqueness by contstraint "product_pkey"
// It returns the new values and scan them into given row references.
func (rep *PGMGRepository) SaveAndReturnByProductPkey(ctx context.Context, rows ...*Product) (ProductRows, error) {
	return SaveAndReturnByProductPkey(ctx, rep.db, rows...)
}

// DeleteByProductPkey deletes matching rows by ProductPkey keys from table "product"
func (rep *PGMGRepository) DeleteByProductPkey(ctx context.Context, keys ...ProductPkey) (int64, error) {
	return DeleteByProductPkey(ctx, rep.db, keys...)
}

// ProductCondition is used for quering table "product"
type ProductCondition struct {
	ID      *int32     `json:"id"`
	Price   *float64   `json:"price"`
	Stocked *time.Time `json:"stocked"`
	Sold    *time.Time `json:"sold"`
}

// FindProductRows find the rows matching the condition from table "product"
func (rep *PGMGRepository) FindProductRows(ctx context.Context, cond ProductCondition) (ProductRows, error) {
	return FindProductRows(ctx, rep.db, cond)
}

// DeleteProductRows delete the rows matching the condition from table "product"
func (rep *PGMGRepository) DeleteProductRows(ctx context.Context, cond ProductCondition) (afftected int64, err error) {
	return DeleteProductRows(ctx, rep.db, cond)
}

// CountProductRows counts the number of rows matching the condition from table "product"
func (rep *PGMGRepository) CountProductRows(ctx context.Context, cond ProductCondition) (int, error) {
	return CountProductRows(ctx, rep.db, cond)
}

// SemesterID represents value type of column "id" of table "semester"
type SemesterID *int32

// SemesterYear represents value type of column "year" of table "semester"
type SemesterYear int32

// SemesterSeason represents value type of column "season" of table "semester"
type SemesterSeason string

// NewSemester creates a new row for table "semester" with all column values
func NewSemester(
	id SemesterID,
	year SemesterYear,
	season SemesterSeason,
) *Semester {
	return &Semester{
		(*int32)(id),
		(int32)(year),
		(string)(season),
	}
}

func (r *Semester) ReceiveRow() []interface{} {
	return []interface{}{&r.ID, &r.Year, &r.Season}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *SemesterRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(SemesterRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(Semester)
	}
	return (*rs)[i].ReceiveRow()
}

// ProductID represents value type of column "id" of table "product"
type ProductID *int32

// ProductPrice represents value type of column "price" of table "product"
type ProductPrice float64

// ProductStocked represents value type of column "stocked" of table "product"
type ProductStocked time.Time

// ProductSold represents value type of column "sold" of table "product"
type ProductSold *time.Time

// NewProduct creates a new row for table "product" with all column values
func NewProduct(
	id ProductID,
	price ProductPrice,
	stocked ProductStocked,
	sold ProductSold,
) *Product {
	return &Product{
		(*int32)(id),
		(float64)(price),
		(time.Time)(stocked),
		(*time.Time)(sold),
	}
}

func (r *Product) ReceiveRow() []interface{} {
	return []interface{}{&r.ID, &r.Price, &r.Stocked, &r.Sold}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *ProductRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(ProductRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(Product)
	}
	return (*rs)[i].ReceiveRow()
}

var sqlInsertSemesterRows = `
	WITH __values AS (
		SELECT
			COALESCE(__input."id", nextval('wise.semester_id_seq'::regclass)) "id",
			__input."year",
			__input."season"
		FROM json_populate_recordset(null::"wise"."semester", $1) __input
	)
	INSERT INTO "wise"."semester" AS _t ("id", "year", "season")
	SELECT "id", "year", "season" FROM __values`

func InsertSemesterRows(ctx context.Context, db PGMGDatabase, inputs ...*Semester) (err error) {
	if err = execJSON(ctx, db, sqlInsertSemesterRows, inputs, len(inputs)); err != nil {
		return fmt.Errorf("%w( InsertSemesterRows, %w)", ErrPGMG, err)
	}
	return nil
}

var sqlReturningSemesterRows = `
	RETURNING id, year, season
`

var sqlInsertAndReturnSemesterRows = sqlInsertSemesterRows + sqlReturningSemesterRows

func InsertAndReturnSemesterRows(ctx context.Context, db PGMGDatabase, inputs ...*Semester) (rows SemesterRows, err error) {
	rows = inputs
	err = execJSONAndReturn(ctx, db, rows.ReceiveRows, sqlInsertAndReturnSemesterRows, rows, len(rows))
	if err != nil {
		return rows, fmt.Errorf("%w(SQLInsertAndReturnSemesterRows, %w)", ErrPGMG, err)
	}
	return rows, nil
}

var sqlFindSemesterRows = `
	SELECT __t.id, __t.year, __t.season
	FROM "wise"."semester" AS __t
	WHERE TRUE
		AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS integer) = __t."id")
		AND (($1::json->>'year' IS NULL) OR CAST($1::json->>'year' AS integer) = __t."year")
		AND (($1::json->>'season' IS NULL) OR CAST($1::json->>'season' AS text) = __t."season")
`

// FindSemesterRows find the rows matching the condition from table "semester"
func FindSemesterRows(ctx context.Context, db PGMGDatabase, cond SemesterCondition) (rows SemesterRows, err error) {
	var arg1 []byte
	if arg1, err = json.Marshal(cond); err != nil {
		return nil, err
	}
	if _, err = db.QueryScan(ctx, rows.ReceiveRows, sqlFindSemesterRows, arg1); err != nil {
		return nil, err
	}
	return rows, nil
}

var sqlDeleteSemesterRows = `
	DELETE FROM "wise"."semester" AS __t
	WHERE TRUE
		AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS integer) = __t."id")
		AND (($1::json->>'year' IS NULL) OR CAST($1::json->>'year' AS integer) = __t."year")
		AND (($1::json->>'season' IS NULL) OR CAST($1::json->>'season' AS text) = __t."season")
`

// DeleteSemesterRows delete the rows matching the condition from table "semester"
func DeleteSemesterRows(ctx context.Context, db PGMGDatabase, cond SemesterCondition) (afftected int64, err error) {
	var arg1 []byte
	if arg1, err = json.Marshal(cond); err != nil {
		return 0, err
	}
	return db.ExecCountingAffected(ctx, sqlDeleteSemesterRows, arg1)
}

var sqlCountSemesterRows = `
	SELECT count(*) FROM "wise"."semester" AS __t
	WHERE TRUE
		AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS integer) = __t."id")
		AND (($1::json->>'year' IS NULL) OR CAST($1::json->>'year' AS integer) = __t."year")
		AND (($1::json->>'season' IS NULL) OR CAST($1::json->>'season' AS text) = __t."season")
`

// CountSemesterRows counts the number of rows matching the condition from table "semester"
func CountSemesterRows(ctx context.Context, db PGMGDatabase, cond SemesterCondition) (count int, err error) {
	var arg1 []byte
	if arg1, err = json.Marshal(cond); err != nil {
		return 0, err
	}
	_, err = db.QueryScan(ctx, func(int) []interface{} { return []interface{}{&count} }, sqlCountSemesterRows, arg1)
	return count, err
}

// SemesterPkey represents the key defined by UNIQUE constraint "semester_pkey" for table "semester"
type SemesterPkey struct {
	ID int32 `json:"id"`
}

func (r *Semester) SemesterPkey() SemesterPkey {
	k := SemesterPkey{}
	if r.ID != nil {
		k.ID = *r.ID
	}
	return k
}

func (rs SemesterRows) SemesterPkeySlice() (keys []SemesterPkey) {
	keys = make([]SemesterPkey, len(rs))
	for i, r := range rs {
		keys[i] = r.SemesterPkey()
	}
	return keys
}

var sqlGetBySemesterPkey = `
	WITH __key AS (
		SELECT ROW_NUMBER() over () __keyindex,
			id
		FROM json_populate_recordset(null::"wise"."semester", $1)
	)
	SELECT "id", "year", "season"
	FROM __key JOIN "wise"."semester" AS __table USING ("id")
	ORDER BY __keyindex
`

// GetBySemesterPkey gets matching rows for given SemesterPkey keys from table "semester"
func GetBySemesterPkey(ctx context.Context, db PGMGDatabase, keys ...SemesterPkey) (rows SemesterRows, err error) {
	var b []byte
	if b, err = json.Marshal(keys); err != nil {
		return nil, fmt.Errorf("%w(GetBySemesterPkey, %w)", ErrPGMG, err)
	}
	rows = make(SemesterRows, len(keys))
	if _, err = db.QueryScan(ctx, rows.ReceiveRows, sqlGetBySemesterPkey, b); err != nil {
		return nil, fmt.Errorf("%w(GetBySemesterPkey, %w)", ErrPGMG, err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].SemesterPkey() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

var sqlSaveBySemesterPkey = sqlInsertSemesterRows + `
	ON CONFLICT ("id") DO UPDATE
		SET ("id", "year", "season") = (
			SELECT "id", "year", "season" FROM __values
			WHERE __values."id" = _t."id"
		)
`

// SaveBySemesterPkey upserts the given rows for table "semester" checking uniqueness by contstraint "semester_pkey"
func SaveBySemesterPkey(ctx context.Context, db PGMGDatabase, rows ...*Semester) (err error) {
	if err = execJSON(ctx, db, sqlSaveBySemesterPkey, rows, len(rows)); err != nil {
		return fmt.Errorf("%w(SaveBySemesterPkey, %w)", ErrPGMG, err)
	}
	return nil
}

var sqlSaveAndReturnBySemesterPkey = sqlSaveBySemesterPkey + sqlReturningSemesterRows

// SaveAndReturnBySemesterPkey upserts the given rows for table "semester" checking uniqueness by contstraint "semester_pkey"
// It returns the new values and scan them into given row references.
func SaveAndReturnBySemesterPkey(ctx context.Context, db PGMGDatabase, inputs ...*Semester) (rows SemesterRows, err error) {
	rows = inputs
	err = execJSONAndReturn(ctx, db, rows.ReceiveRows, sqlSaveAndReturnBySemesterPkey, rows, len(rows))
	if err != nil {
		return rows, fmt.Errorf("%w(SaveAndReturnBySemesterPkey, %w)", ErrPGMG, err)
	}
	return rows, nil
}

var sqlDeleteBySemesterPkey = `
WITH __key AS (SELECT id FROM json_populate_recordset(null::"wise"."semester", $1))
DELETE FROM "wise"."semester" AS __table
	USING __key
	WHERE (__key."id" = __table."id")
	`

// DeleteBySemesterPkey deletes matching rows by SemesterPkey keys from table "semester"
func DeleteBySemesterPkey(ctx context.Context, db PGMGDatabase, keys ...SemesterPkey) (affected int64, err error) {
	b, err := json.Marshal(keys)
	if err != nil {
		return affected, fmt.Errorf("%w(DeleteBySemesterPkey, %w)", ErrPGMG, err)
	}
	if affected, err = db.ExecCountingAffected(ctx, sqlDeleteBySemesterPkey, b); err != nil {
		return affected, fmt.Errorf("%w(DeleteBySemesterPkey, %w)", ErrPGMG, err)
	}
	return affected, nil
}

// SemesterYearSeasonKey represents the key defined by UNIQUE constraint "semester_year_season_key" for table "semester"
type SemesterYearSeasonKey struct {
	Year   int32  `json:"year"`
	Season string `json:"season"`
}

func (r *Semester) SemesterYearSeasonKey() SemesterYearSeasonKey {
	k := SemesterYearSeasonKey{}
	k.Year = r.Year
	k.Season = r.Season
	return k
}

func (rs SemesterRows) SemesterYearSeasonKeySlice() (keys []SemesterYearSeasonKey) {
	keys = make([]SemesterYearSeasonKey, len(rs))
	for i, r := range rs {
		keys[i] = r.SemesterYearSeasonKey()
	}
	return keys
}

var sqlGetBySemesterYearSeasonKey = `
	WITH __key AS (
		SELECT ROW_NUMBER() over () __keyindex,
			year, season
		FROM json_populate_recordset(null::"wise"."semester", $1)
	)
	SELECT "id", "year", "season"
	FROM __key JOIN "wise"."semester" AS __table USING ("year", "season")
	ORDER BY __keyindex
`

// GetBySemesterYearSeasonKey gets matching rows for given SemesterYearSeasonKey keys from table "semester"
func GetBySemesterYearSeasonKey(ctx context.Context, db PGMGDatabase, keys ...SemesterYearSeasonKey) (rows SemesterRows, err error) {
	var b []byte
	if b, err = json.Marshal(keys); err != nil {
		return nil, fmt.Errorf("%w(GetBySemesterYearSeasonKey, %w)", ErrPGMG, err)
	}
	rows = make(SemesterRows, len(keys))
	if _, err = db.QueryScan(ctx, rows.ReceiveRows, sqlGetBySemesterYearSeasonKey, b); err != nil {
		return nil, fmt.Errorf("%w(GetBySemesterYearSeasonKey, %w)", ErrPGMG, err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].SemesterYearSeasonKey() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

var sqlSaveBySemesterYearSeasonKey = sqlInsertSemesterRows + `
	ON CONFLICT ("year", "season") DO UPDATE
		SET ("id", "year", "season") = (
			SELECT "id", "year", "season" FROM __values
			WHERE __values."year" = _t."year"
				AND __values."season" = _t."season"
		)
`

// SaveBySemesterYearSeasonKey upserts the given rows for table "semester" checking uniqueness by contstraint "semester_year_season_key"
func SaveBySemesterYearSeasonKey(ctx context.Context, db PGMGDatabase, rows ...*Semester) (err error) {
	if err = execJSON(ctx, db, sqlSaveBySemesterYearSeasonKey, rows, len(rows)); err != nil {
		return fmt.Errorf("%w(SaveBySemesterYearSeasonKey, %w)", ErrPGMG, err)
	}
	return nil
}

var sqlSaveAndReturnBySemesterYearSeasonKey = sqlSaveBySemesterYearSeasonKey + sqlReturningSemesterRows

// SaveAndReturnBySemesterYearSeasonKey upserts the given rows for table "semester" checking uniqueness by contstraint "semester_year_season_key"
// It returns the new values and scan them into given row references.
func SaveAndReturnBySemesterYearSeasonKey(ctx context.Context, db PGMGDatabase, inputs ...*Semester) (rows SemesterRows, err error) {
	rows = inputs
	err = execJSONAndReturn(ctx, db, rows.ReceiveRows, sqlSaveAndReturnBySemesterYearSeasonKey, rows, len(rows))
	if err != nil {
		return rows, fmt.Errorf("%w(SaveAndReturnBySemesterYearSeasonKey, %w)", ErrPGMG, err)
	}
	return rows, nil
}

var sqlDeleteBySemesterYearSeasonKey = `
WITH __key AS (SELECT year, season FROM json_populate_recordset(null::"wise"."semester", $1))
DELETE FROM "wise"."semester" AS __table
	USING __key
	WHERE (__key."year" = __table."year")
	  AND (__key."season" = __table."season")
	`

// DeleteBySemesterYearSeasonKey deletes matching rows by SemesterYearSeasonKey keys from table "semester"
func DeleteBySemesterYearSeasonKey(ctx context.Context, db PGMGDatabase, keys ...SemesterYearSeasonKey) (affected int64, err error) {
	b, err := json.Marshal(keys)
	if err != nil {
		return affected, fmt.Errorf("%w(DeleteBySemesterYearSeasonKey, %w)", ErrPGMG, err)
	}
	if affected, err = db.ExecCountingAffected(ctx, sqlDeleteBySemesterYearSeasonKey, b); err != nil {
		return affected, fmt.Errorf("%w(DeleteBySemesterYearSeasonKey, %w)", ErrPGMG, err)
	}
	return affected, nil
}

var sqlInsertProductRows = `
	WITH __values AS (
		SELECT
			COALESCE(__input."id", nextval('wise.product_id_seq'::regclass)) "id",
			__input."price",
			__input."stocked",
			__input."sold"
		FROM json_populate_recordset(null::"wise"."product", $1) __input
	)
	INSERT INTO "wise"."product" AS _t ("id", "price", "stocked", "sold")
	SELECT "id", "price", "stocked", "sold" FROM __values`

func InsertProductRows(ctx context.Context, db PGMGDatabase, inputs ...*Product) (err error) {
	if err = execJSON(ctx, db, sqlInsertProductRows, inputs, len(inputs)); err != nil {
		return fmt.Errorf("%w( InsertProductRows, %w)", ErrPGMG, err)
	}
	return nil
}

var sqlReturningProductRows = `
	RETURNING id, price, stocked, sold
`

var sqlInsertAndReturnProductRows = sqlInsertProductRows + sqlReturningProductRows

func InsertAndReturnProductRows(ctx context.Context, db PGMGDatabase, inputs ...*Product) (rows ProductRows, err error) {
	rows = inputs
	err = execJSONAndReturn(ctx, db, rows.ReceiveRows, sqlInsertAndReturnProductRows, rows, len(rows))
	if err != nil {
		return rows, fmt.Errorf("%w(SQLInsertAndReturnProductRows, %w)", ErrPGMG, err)
	}
	return rows, nil
}

var sqlFindProductRows = `
	SELECT __t.id, __t.price, __t.stocked, __t.sold
	FROM "wise"."product" AS __t
	WHERE TRUE
		AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS integer) = __t."id")
		AND (($1::json->>'price' IS NULL) OR CAST($1::json->>'price' AS numeric) = __t."price")
		AND (($1::json->>'stocked' IS NULL) OR CAST($1::json->>'stocked' AS timestamp with time zone) = __t."stocked")
		AND (($1::json->>'sold' IS NULL) OR CAST($1::json->>'sold' AS timestamp with time zone) = __t."sold")
`

// FindProductRows find the rows matching the condition from table "product"
func FindProductRows(ctx context.Context, db PGMGDatabase, cond ProductCondition) (rows ProductRows, err error) {
	var arg1 []byte
	if arg1, err = json.Marshal(cond); err != nil {
		return nil, err
	}
	if _, err = db.QueryScan(ctx, rows.ReceiveRows, sqlFindProductRows, arg1); err != nil {
		return nil, err
	}
	return rows, nil
}

var sqlDeleteProductRows = `
	DELETE FROM "wise"."product" AS __t
	WHERE TRUE
		AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS integer) = __t."id")
		AND (($1::json->>'price' IS NULL) OR CAST($1::json->>'price' AS numeric) = __t."price")
		AND (($1::json->>'stocked' IS NULL) OR CAST($1::json->>'stocked' AS timestamp with time zone) = __t."stocked")
		AND (($1::json->>'sold' IS NULL) OR CAST($1::json->>'sold' AS timestamp with time zone) = __t."sold")
`

// DeleteProductRows delete the rows matching the condition from table "product"
func DeleteProductRows(ctx context.Context, db PGMGDatabase, cond ProductCondition) (afftected int64, err error) {
	var arg1 []byte
	if arg1, err = json.Marshal(cond); err != nil {
		return 0, err
	}
	return db.ExecCountingAffected(ctx, sqlDeleteProductRows, arg1)
}

var sqlCountProductRows = `
	SELECT count(*) FROM "wise"."product" AS __t
	WHERE TRUE
		AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS integer) = __t."id")
		AND (($1::json->>'price' IS NULL) OR CAST($1::json->>'price' AS numeric) = __t."price")
		AND (($1::json->>'stocked' IS NULL) OR CAST($1::json->>'stocked' AS timestamp with time zone) = __t."stocked")
		AND (($1::json->>'sold' IS NULL) OR CAST($1::json->>'sold' AS timestamp with time zone) = __t."sold")
`

// CountProductRows counts the number of rows matching the condition from table "product"
func CountProductRows(ctx context.Context, db PGMGDatabase, cond ProductCondition) (count int, err error) {
	var arg1 []byte
	if arg1, err = json.Marshal(cond); err != nil {
		return 0, err
	}
	_, err = db.QueryScan(ctx, func(int) []interface{} { return []interface{}{&count} }, sqlCountProductRows, arg1)
	return count, err
}

// ProductPkey represents the key defined by UNIQUE constraint "product_pkey" for table "product"
type ProductPkey struct {
	ID int32 `json:"id"`
}

func (r *Product) ProductPkey() ProductPkey {
	k := ProductPkey{}
	if r.ID != nil {
		k.ID = *r.ID
	}
	return k
}

func (rs ProductRows) ProductPkeySlice() (keys []ProductPkey) {
	keys = make([]ProductPkey, len(rs))
	for i, r := range rs {
		keys[i] = r.ProductPkey()
	}
	return keys
}

var sqlGetByProductPkey = `
	WITH __key AS (
		SELECT ROW_NUMBER() over () __keyindex,
			id
		FROM json_populate_recordset(null::"wise"."product", $1)
	)
	SELECT "id", "price", "stocked", "sold"
	FROM __key JOIN "wise"."product" AS __table USING ("id")
	ORDER BY __keyindex
`

// GetByProductPkey gets matching rows for given ProductPkey keys from table "product"
func GetByProductPkey(ctx context.Context, db PGMGDatabase, keys ...ProductPkey) (rows ProductRows, err error) {
	var b []byte
	if b, err = json.Marshal(keys); err != nil {
		return nil, fmt.Errorf("%w(GetByProductPkey, %w)", ErrPGMG, err)
	}
	rows = make(ProductRows, len(keys))
	if _, err = db.QueryScan(ctx, rows.ReceiveRows, sqlGetByProductPkey, b); err != nil {
		return nil, fmt.Errorf("%w(GetByProductPkey, %w)", ErrPGMG, err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].ProductPkey() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

var sqlSaveByProductPkey = sqlInsertProductRows + `
	ON CONFLICT ("id") DO UPDATE
		SET ("id", "price", "stocked", "sold") = (
			SELECT "id", "price", "stocked", "sold" FROM __values
			WHERE __values."id" = _t."id"
		)
`

// SaveByProductPkey upserts the given rows for table "product" checking uniqueness by contstraint "product_pkey"
func SaveByProductPkey(ctx context.Context, db PGMGDatabase, rows ...*Product) (err error) {
	if err = execJSON(ctx, db, sqlSaveByProductPkey, rows, len(rows)); err != nil {
		return fmt.Errorf("%w(SaveByProductPkey, %w)", ErrPGMG, err)
	}
	return nil
}

var sqlSaveAndReturnByProductPkey = sqlSaveByProductPkey + sqlReturningProductRows

// SaveAndReturnByProductPkey upserts the given rows for table "product" checking uniqueness by contstraint "product_pkey"
// It returns the new values and scan them into given row references.
func SaveAndReturnByProductPkey(ctx context.Context, db PGMGDatabase, inputs ...*Product) (rows ProductRows, err error) {
	rows = inputs
	err = execJSONAndReturn(ctx, db, rows.ReceiveRows, sqlSaveAndReturnByProductPkey, rows, len(rows))
	if err != nil {
		return rows, fmt.Errorf("%w(SaveAndReturnByProductPkey, %w)", ErrPGMG, err)
	}
	return rows, nil
}

var sqlDeleteByProductPkey = `
WITH __key AS (SELECT id FROM json_populate_recordset(null::"wise"."product", $1))
DELETE FROM "wise"."product" AS __table
	USING __key
	WHERE (__key."id" = __table."id")
	`

// DeleteByProductPkey deletes matching rows by ProductPkey keys from table "product"
func DeleteByProductPkey(ctx context.Context, db PGMGDatabase, keys ...ProductPkey) (affected int64, err error) {
	b, err := json.Marshal(keys)
	if err != nil {
		return affected, fmt.Errorf("%w(DeleteByProductPkey, %w)", ErrPGMG, err)
	}
	if affected, err = db.ExecCountingAffected(ctx, sqlDeleteByProductPkey, b); err != nil {
		return affected, fmt.Errorf("%w(DeleteByProductPkey, %w)", ErrPGMG, err)
	}
	return affected, nil
}

func execJSON(ctx context.Context, db PGMGDatabase, sql string, rows interface{}, ern int) (err error) {
	var arg1 []byte
	if arg1, err = json.Marshal(rows); err != nil {
		return err
	}
	if affected, err := db.ExecCountingAffected(ctx, sql, arg1); err != nil {
		return err
	} else if affected != int64(ern) {
		return ErrUnexpectedRowNumberAffected
	}
	return nil
}

func execJSONAndReturn(ctx context.Context, db PGMGDatabase, receive func(int) []interface{}, sql string, rows interface{}, ern int) (err error) {
	var arg1 []byte
	if arg1, err = json.Marshal(rows); err != nil {
		return err
	}
	if affected, err := db.QueryScan(ctx, receive, sql, arg1); err != nil {
		return err
	} else if affected != ern {
		return ErrUnexpectedRowNumberAffected
	}
	return nil
}

// PGMGDatabase represents PostgresQL database
type PGMGDatabase interface {
	QueryScan(ctx context.Context, receiver func(int) []interface{}, sql string, args ...interface{}) (int, error)
	ExecCountingAffected(ctx context.Context, sql string, args ...interface{}) (int64, error)
}

var ErrUnexpectedRowNumberAffected = fmt.Errorf("pgmg: unexpected row number affected")
var ErrPGMG = fmt.Errorf("pgmg: error")
