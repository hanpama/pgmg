// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package example

import (
	"context"
	"encoding/json"
	"fmt"
	"time"
)

// PGMGDatabase represents PostgresQL database
type PGMGDatabase interface {
	QueryScan(ctx context.Context, receiver func(int) []interface{}, sql string, args ...interface{}) (int, error)
	Exec(ctx context.Context, sql string, args ...interface{}) (int64, error)
}

// Semester represents a row for table "semester"
type Semester struct {
	ID     *int32 `json:"id"`
	Year   int32  `json:"year"`
	Season string `json:"season"`
}

// SemesterID represents column "id" of table "semester"
type SemesterID *int32

// SemesterYear represents column "year" of table "semester"
type SemesterYear int32

// SemesterSeason represents column "season" of table "semester"
type SemesterSeason string

// NewSemester creates a new row for table "semester" with all column values
func NewSemester(
	id SemesterID,
	year SemesterYear,
	season SemesterSeason,
) *Semester {
	return &Semester{
		(*int32)(id),
		(int32)(year),
		(string)(season),
	}
}

func (r *Semester) receive() []interface{} {
	return []interface{}{&r.ID, &r.Year, &r.Season}
}

// Product represents a row for table "product"
type Product struct {
	ID      *int32     `json:"id"`
	Price   float64    `json:"price"`
	Stocked time.Time  `json:"stocked"`
	Sold    *time.Time `json:"sold"`
}

// ProductID represents column "id" of table "product"
type ProductID *int32

// ProductPrice represents column "price" of table "product"
type ProductPrice float64

// ProductStocked represents column "stocked" of table "product"
type ProductStocked time.Time

// ProductSold represents column "sold" of table "product"
type ProductSold *time.Time

// NewProduct creates a new row for table "product" with all column values
func NewProduct(
	id ProductID,
	price ProductPrice,
	stocked ProductStocked,
	sold ProductSold,
) *Product {
	return &Product{
		(*int32)(id),
		(float64)(price),
		(time.Time)(stocked),
		(*time.Time)(sold),
	}
}

func (r *Product) receive() []interface{} {
	return []interface{}{&r.ID, &r.Price, &r.Stocked, &r.Sold}
}

// SemesterPkey represents key defined by UNIQUE constraint "semester_pkey" for table "semester"
type SemesterPkey struct {
	ID int32 `json:"id"`
}

func (r *Semester) SemesterPkey() SemesterPkey {
	k := SemesterPkey{}
	if r.ID != nil {
		k.ID = *r.ID
	}
	return k
}

var SQLGetBySemesterPkey = `
	WITH __key AS (
		SELECT ROW_NUMBER() over () __keyindex,
			id
		FROM json_populate_recordset(null::"wise"."semester", $1)
	)
	SELECT id, year, season
	FROM __key JOIN "wise"."semester" AS __table USING (id)
	ORDER BY __keyindex
`

// GetBySemesterPkey gets matching rows for given SemesterPkey keys from table "semester"
func GetBySemesterPkey(ctx context.Context, db PGMGDatabase, keys ...SemesterPkey) (rows []*Semester, err error) {
	var b []byte
	if b, err = json.Marshal(keys); err != nil {
		return nil, err
	}
	rows = make([]*Semester, len(keys))
	if _, err = db.QueryScan(ctx, func(i int) []interface{} {
		rows[i] = &Semester{}
		return rows[i].receive()
	}, SQLGetBySemesterPkey, string(b)); err != nil {
		return nil, err
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].SemesterPkey() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

var SQLSaveBySemesterPkey = `
	WITH __values AS (
		SELECT
			COALESCE(__input.id, nextval('wise.semester_id_seq'::regclass)) id,
			__input.year,
			__input.season
		FROM json_populate_recordset(null::"wise"."semester", $1) __input
	)
	INSERT INTO "wise"."semester" SELECT * FROM __values
	ON CONFLICT (id) DO UPDATE
		SET (id, year, season) = (
			SELECT id, year, season FROM __values
		)
`

// SaveBySemesterPkey upserts the given rows for table "semester" checking uniqueness by contstraint "semester_pkey"
func SaveBySemesterPkey(ctx context.Context, db PGMGDatabase, rows ...*Semester) error {
	b, err := json.Marshal(rows)
	if err != nil {
		return err
	}
	affected, err := db.Exec(ctx, SQLSaveBySemesterPkey, string(b))
	if err != nil {
		return err
	}
	if affected != int64(len(rows)) {
		return ErrUnexpectedRowNumberAffected
	}
	return nil
}

// SaveAndReturnBySemesterPkey upserts the given rows for table "semester" checking uniqueness by contstraint "semester_pkey"
// It returns the new values and scan them into given row references.
func SaveAndReturnBySemesterPkey(ctx context.Context, db PGMGDatabase, rows ...*Semester) ([]*Semester, error) {
	b, err := json.Marshal(rows)
	if err != nil {
		return rows, err
	}
	affected, err := db.QueryScan(ctx, func(i int) []interface{} { return rows[i].receive() },
		SQLSaveBySemesterPkey+" RETURNING id, year, season",
		string(b),
	)
	if err != nil {
		return rows, err
	}
	if affected != len(rows) {
		return rows, ErrUnexpectedRowNumberAffected
	}
	return rows, nil
}

var SQLDeleteBySemesterPkey = `
WITH __key AS (SELECT * FROM json_populate_recordset(null::"wise"."semester", $1))
DELETE FROM "wise"."semester" AS __table
	USING __key
	WHERE (__key.id = __table.id)
	`

// DeleteBySemesterPkey deletes matching rows by SemesterPkey keys from table "semester"
func DeleteBySemesterPkey(ctx context.Context, db PGMGDatabase, keys ...SemesterPkey) (int64, error) {
	b, err := json.Marshal(keys)
	if err != nil {
		return 0, err
	}
	return db.Exec(ctx, SQLDeleteBySemesterPkey, string(b))
}

// SemesterYearSeasonKey represents key defined by UNIQUE constraint "semester_year_season_key" for table "semester"
type SemesterYearSeasonKey struct {
	Year   int32  `json:"year"`
	Season string `json:"season"`
}

func (r *Semester) SemesterYearSeasonKey() SemesterYearSeasonKey {
	k := SemesterYearSeasonKey{}
	k.Year = r.Year

	k.Season = r.Season

	return k
}

var SQLGetBySemesterYearSeasonKey = `
	WITH __key AS (
		SELECT ROW_NUMBER() over () __keyindex,
			year, season
		FROM json_populate_recordset(null::"wise"."semester", $1)
	)
	SELECT id, year, season
	FROM __key JOIN "wise"."semester" AS __table USING (year, season)
	ORDER BY __keyindex
`

// GetBySemesterYearSeasonKey gets matching rows for given SemesterYearSeasonKey keys from table "semester"
func GetBySemesterYearSeasonKey(ctx context.Context, db PGMGDatabase, keys ...SemesterYearSeasonKey) (rows []*Semester, err error) {
	var b []byte
	if b, err = json.Marshal(keys); err != nil {
		return nil, err
	}
	rows = make([]*Semester, len(keys))
	if _, err = db.QueryScan(ctx, func(i int) []interface{} {
		rows[i] = &Semester{}
		return rows[i].receive()
	}, SQLGetBySemesterYearSeasonKey, string(b)); err != nil {
		return nil, err
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].SemesterYearSeasonKey() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

var SQLSaveBySemesterYearSeasonKey = `
	WITH __values AS (
		SELECT
			COALESCE(__input.id, nextval('wise.semester_id_seq'::regclass)) id,
			__input.year,
			__input.season
		FROM json_populate_recordset(null::"wise"."semester", $1) __input
	)
	INSERT INTO "wise"."semester" SELECT * FROM __values
	ON CONFLICT (year, season) DO UPDATE
		SET (id, year, season) = (
			SELECT id, year, season FROM __values
		)
`

// SaveBySemesterYearSeasonKey upserts the given rows for table "semester" checking uniqueness by contstraint "semester_year_season_key"
func SaveBySemesterYearSeasonKey(ctx context.Context, db PGMGDatabase, rows ...*Semester) error {
	b, err := json.Marshal(rows)
	if err != nil {
		return err
	}
	affected, err := db.Exec(ctx, SQLSaveBySemesterYearSeasonKey, string(b))
	if err != nil {
		return err
	}
	if affected != int64(len(rows)) {
		return ErrUnexpectedRowNumberAffected
	}
	return nil
}

// SaveAndReturnBySemesterYearSeasonKey upserts the given rows for table "semester" checking uniqueness by contstraint "semester_year_season_key"
// It returns the new values and scan them into given row references.
func SaveAndReturnBySemesterYearSeasonKey(ctx context.Context, db PGMGDatabase, rows ...*Semester) ([]*Semester, error) {
	b, err := json.Marshal(rows)
	if err != nil {
		return rows, err
	}
	affected, err := db.QueryScan(ctx, func(i int) []interface{} { return rows[i].receive() },
		SQLSaveBySemesterYearSeasonKey+" RETURNING id, year, season",
		string(b),
	)
	if err != nil {
		return rows, err
	}
	if affected != len(rows) {
		return rows, ErrUnexpectedRowNumberAffected
	}
	return rows, nil
}

var SQLDeleteBySemesterYearSeasonKey = `
WITH __key AS (SELECT * FROM json_populate_recordset(null::"wise"."semester", $1))
DELETE FROM "wise"."semester" AS __table
	USING __key
	WHERE (__key.year = __table.year)
	  AND (__key.season = __table.season)
	`

// DeleteBySemesterYearSeasonKey deletes matching rows by SemesterYearSeasonKey keys from table "semester"
func DeleteBySemesterYearSeasonKey(ctx context.Context, db PGMGDatabase, keys ...SemesterYearSeasonKey) (int64, error) {
	b, err := json.Marshal(keys)
	if err != nil {
		return 0, err
	}
	return db.Exec(ctx, SQLDeleteBySemesterYearSeasonKey, string(b))
}

// ProductPkey represents key defined by UNIQUE constraint "product_pkey" for table "product"
type ProductPkey struct {
	ID int32 `json:"id"`
}

func (r *Product) ProductPkey() ProductPkey {
	k := ProductPkey{}
	if r.ID != nil {
		k.ID = *r.ID
	}
	return k
}

var SQLGetByProductPkey = `
	WITH __key AS (
		SELECT ROW_NUMBER() over () __keyindex,
			id
		FROM json_populate_recordset(null::"wise"."product", $1)
	)
	SELECT id, price, stocked, sold
	FROM __key JOIN "wise"."product" AS __table USING (id)
	ORDER BY __keyindex
`

// GetByProductPkey gets matching rows for given ProductPkey keys from table "product"
func GetByProductPkey(ctx context.Context, db PGMGDatabase, keys ...ProductPkey) (rows []*Product, err error) {
	var b []byte
	if b, err = json.Marshal(keys); err != nil {
		return nil, err
	}
	rows = make([]*Product, len(keys))
	if _, err = db.QueryScan(ctx, func(i int) []interface{} {
		rows[i] = &Product{}
		return rows[i].receive()
	}, SQLGetByProductPkey, string(b)); err != nil {
		return nil, err
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].ProductPkey() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

var SQLSaveByProductPkey = `
	WITH __values AS (
		SELECT
			COALESCE(__input.id, nextval('wise.product_id_seq'::regclass)) id,
			__input.price,
			__input.stocked,
			__input.sold
		FROM json_populate_recordset(null::"wise"."product", $1) __input
	)
	INSERT INTO "wise"."product" SELECT * FROM __values
	ON CONFLICT (id) DO UPDATE
		SET (id, price, stocked, sold) = (
			SELECT id, price, stocked, sold FROM __values
		)
`

// SaveByProductPkey upserts the given rows for table "product" checking uniqueness by contstraint "product_pkey"
func SaveByProductPkey(ctx context.Context, db PGMGDatabase, rows ...*Product) error {
	b, err := json.Marshal(rows)
	if err != nil {
		return err
	}
	affected, err := db.Exec(ctx, SQLSaveByProductPkey, string(b))
	if err != nil {
		return err
	}
	if affected != int64(len(rows)) {
		return ErrUnexpectedRowNumberAffected
	}
	return nil
}

// SaveAndReturnByProductPkey upserts the given rows for table "product" checking uniqueness by contstraint "product_pkey"
// It returns the new values and scan them into given row references.
func SaveAndReturnByProductPkey(ctx context.Context, db PGMGDatabase, rows ...*Product) ([]*Product, error) {
	b, err := json.Marshal(rows)
	if err != nil {
		return rows, err
	}
	affected, err := db.QueryScan(ctx, func(i int) []interface{} { return rows[i].receive() },
		SQLSaveByProductPkey+" RETURNING id, price, stocked, sold",
		string(b),
	)
	if err != nil {
		return rows, err
	}
	if affected != len(rows) {
		return rows, ErrUnexpectedRowNumberAffected
	}
	return rows, nil
}

var SQLDeleteByProductPkey = `
WITH __key AS (SELECT * FROM json_populate_recordset(null::"wise"."product", $1))
DELETE FROM "wise"."product" AS __table
	USING __key
	WHERE (__key.id = __table.id)
	`

// DeleteByProductPkey deletes matching rows by ProductPkey keys from table "product"
func DeleteByProductPkey(ctx context.Context, db PGMGDatabase, keys ...ProductPkey) (int64, error) {
	b, err := json.Marshal(keys)
	if err != nil {
		return 0, err
	}
	return db.Exec(ctx, SQLDeleteByProductPkey, string(b))
}

var ErrUnexpectedRowNumberAffected = fmt.Errorf("unexpected row number affected")
