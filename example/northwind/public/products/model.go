// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package products

import (
	"encoding/json"
)

type Record struct {
	ProductID       int16    `json:"product_id"`
	ProductName     string   `json:"product_name"`
	SupplierID      *int16   `json:"supplier_id"`
	CategoryID      *int16   `json:"category_id"`
	QuantityPerUnit *string  `json:"quantity_per_unit"`
	UnitPrice       *float32 `json:"unit_price"`
	UnitsInStock    *int16   `json:"units_in_stock"`
	UnitsOnOrder    *int16   `json:"units_on_order"`
	ReorderLevel    *int16   `json:"reorder_level"`
	Discontinued    int32    `json:"discontinued"`
}

type PkProducts struct {
	ProductID int16 `json:"product_id"`
}

type ProductID int16
type ProductName string
type SupplierID int16
type CategoryID int16
type QuantityPerUnit string
type UnitPrice float32
type UnitsInStock int16
type UnitsOnOrder int16
type ReorderLevel int16
type Discontinued int32

func (r *Record) Receive() []interface{} {
	return []interface{}{
		&r.ProductID,
		&r.ProductName,
		&r.SupplierID,
		&r.CategoryID,
		&r.QuantityPerUnit,
		&r.UnitPrice,
		&r.UnitsInStock,
		&r.UnitsOnOrder,
		&r.ReorderLevel,
		&r.Discontinued,
	}
}

type Recordset []Record

func (rs *Recordset) Receive() []interface{} {
	*rs = append(*rs, Record{})
	return (*rs)[len(*rs)-1].Receive()
}

type Values []attribute

func InputValues(
	productID ProductID,
	productName ProductName,
	discontinued Discontinued,
	attrs ...attribute,
) Values {
	return append(Values{
		productID,
		productName,
		discontinued,
	}, attrs...)
}
func (vs Values) ApplyTo(r *Record) {
	for _, v := range vs {
		v.ApplyTo(r)
	}
}

func (vs Values) MarshalJSON() (b []byte, err error) {
	r := make(map[string]interface{})
	for _, v := range vs {
		r[v.Column()] = v.Value()
	}
	return json.Marshal(r)
}

type attribute interface {
	ApplyTo(*Record)
	Column() string
	Value() interface{}
}

func (v ProductID) ApplyTo(r *Record)        { r.ProductID = (int16)(v) }
func (v ProductID) Column() string           { return "product_id" }
func (v ProductID) Value() interface{}       { return (int16)(v) }
func (v ProductName) ApplyTo(r *Record)      { r.ProductName = (string)(v) }
func (v ProductName) Column() string         { return "product_name" }
func (v ProductName) Value() interface{}     { return (string)(v) }
func (v SupplierID) ApplyTo(r *Record)       { r.SupplierID = (*int16)(&v) }
func (v SupplierID) Column() string          { return "supplier_id" }
func (v SupplierID) Value() interface{}      { return (int16)(v) }
func (v CategoryID) ApplyTo(r *Record)       { r.CategoryID = (*int16)(&v) }
func (v CategoryID) Column() string          { return "category_id" }
func (v CategoryID) Value() interface{}      { return (int16)(v) }
func (v QuantityPerUnit) ApplyTo(r *Record)  { r.QuantityPerUnit = (*string)(&v) }
func (v QuantityPerUnit) Column() string     { return "quantity_per_unit" }
func (v QuantityPerUnit) Value() interface{} { return (string)(v) }
func (v UnitPrice) ApplyTo(r *Record)        { r.UnitPrice = (*float32)(&v) }
func (v UnitPrice) Column() string           { return "unit_price" }
func (v UnitPrice) Value() interface{}       { return (float32)(v) }
func (v UnitsInStock) ApplyTo(r *Record)     { r.UnitsInStock = (*int16)(&v) }
func (v UnitsInStock) Column() string        { return "units_in_stock" }
func (v UnitsInStock) Value() interface{}    { return (int16)(v) }
func (v UnitsOnOrder) ApplyTo(r *Record)     { r.UnitsOnOrder = (*int16)(&v) }
func (v UnitsOnOrder) Column() string        { return "units_on_order" }
func (v UnitsOnOrder) Value() interface{}    { return (int16)(v) }
func (v ReorderLevel) ApplyTo(r *Record)     { r.ReorderLevel = (*int16)(&v) }
func (v ReorderLevel) Column() string        { return "reorder_level" }
func (v ReorderLevel) Value() interface{}    { return (int16)(v) }
func (v Discontinued) ApplyTo(r *Record)     { r.Discontinued = (int32)(v) }
func (v Discontinued) Column() string        { return "discontinued" }
func (v Discontinued) Value() interface{}    { return (int32)(v) }

func mustMarshalJSON(v interface{}) []byte {
	b, err := json.Marshal(v)
	if err != nil {
		panic(err)
	}
	return b
}
