// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package orders

import (
	"encoding/json"
	"time"
)

type Record struct {
	OrderID        int16      `json:"order_id"`
	CustomerID     *string    `json:"customer_id"`
	EmployeeID     *int16     `json:"employee_id"`
	OrderDate      *time.Time `json:"order_date"`
	RequiredDate   *time.Time `json:"required_date"`
	ShippedDate    *time.Time `json:"shipped_date"`
	ShipVia        *int16     `json:"ship_via"`
	Freight        *float32   `json:"freight"`
	ShipName       *string    `json:"ship_name"`
	ShipAddress    *string    `json:"ship_address"`
	ShipCity       *string    `json:"ship_city"`
	ShipRegion     *string    `json:"ship_region"`
	ShipPostalCode *string    `json:"ship_postal_code"`
	ShipCountry    *string    `json:"ship_country"`
}

type PkOrders struct {
	OrderID int16 `json:"order_id"`
}

type OrderID int16
type CustomerID string
type EmployeeID int16
type OrderDate time.Time
type RequiredDate time.Time
type ShippedDate time.Time
type ShipVia int16
type Freight float32
type ShipName string
type ShipAddress string
type ShipCity string
type ShipRegion string
type ShipPostalCode string
type ShipCountry string

func (r *Record) Receive() []interface{} {
	return []interface{}{
		&r.OrderID, &r.CustomerID, &r.EmployeeID, &r.OrderDate, &r.RequiredDate, &r.ShippedDate,
		&r.ShipVia, &r.Freight, &r.ShipName, &r.ShipAddress, &r.ShipCity, &r.ShipRegion, &r.ShipPostalCode, &r.ShipCountry,
	}
}

type Recordset []Record

func (rs *Recordset) ReceiveNext() []interface{} {
	*rs = append(*rs, Record{})
	return (*rs)[len(*rs)-1].Receive()
}

type Values []attribute

func InputValues(
	orderID OrderID,
	customerID CustomerID,
	employeeID EmployeeID,
	orderDate OrderDate,
	requiredDate RequiredDate,
	shippedDate ShippedDate,
	shipVia ShipVia,
	freight Freight,
	shipName ShipName,
	shipAddress ShipAddress,
	shipCity ShipCity,
	shipRegion ShipRegion,
	shipPostalCode ShipPostalCode,
	shipCountry ShipCountry,
	attrs ...attribute,
) Values {
	return append(Values{orderID, customerID, employeeID, orderDate, requiredDate, shippedDate, shipVia, freight, shipName, shipAddress, shipCity, shipRegion, shipPostalCode, shipCountry}, attrs...)
}
func (vs Values) ApplyTo(r *Record) {
	for _, v := range vs {
		v.ApplyTo(r)
	}
}

func (vs Values) MarshalJSON() (b []byte, err error) {
	r := make(map[string]interface{})
	for _, v := range vs {
		r[v.Column()] = v.Value()
	}
	return json.Marshal(r)
}

type attribute interface {
	ApplyTo(*Record)
	Column() string
	Value() interface{}
}

func (v OrderID) ApplyTo(r *Record)         { r.OrderID = (int16)(v) }
func (v OrderID) Column() string            { return "order_id" }
func (v OrderID) Value() interface{}        { return (int16)(v) }
func (v CustomerID) ApplyTo(r *Record)      { r.CustomerID = (*string)(&v) }
func (v CustomerID) Column() string         { return "customer_id" }
func (v CustomerID) Value() interface{}     { return (string)(v) }
func (v EmployeeID) ApplyTo(r *Record)      { r.EmployeeID = (*int16)(&v) }
func (v EmployeeID) Column() string         { return "employee_id" }
func (v EmployeeID) Value() interface{}     { return (int16)(v) }
func (v OrderDate) ApplyTo(r *Record)       { r.OrderDate = (*time.Time)(&v) }
func (v OrderDate) Column() string          { return "order_date" }
func (v OrderDate) Value() interface{}      { return (time.Time)(v) }
func (v RequiredDate) ApplyTo(r *Record)    { r.RequiredDate = (*time.Time)(&v) }
func (v RequiredDate) Column() string       { return "required_date" }
func (v RequiredDate) Value() interface{}   { return (time.Time)(v) }
func (v ShippedDate) ApplyTo(r *Record)     { r.ShippedDate = (*time.Time)(&v) }
func (v ShippedDate) Column() string        { return "shipped_date" }
func (v ShippedDate) Value() interface{}    { return (time.Time)(v) }
func (v ShipVia) ApplyTo(r *Record)         { r.ShipVia = (*int16)(&v) }
func (v ShipVia) Column() string            { return "ship_via" }
func (v ShipVia) Value() interface{}        { return (int16)(v) }
func (v Freight) ApplyTo(r *Record)         { r.Freight = (*float32)(&v) }
func (v Freight) Column() string            { return "freight" }
func (v Freight) Value() interface{}        { return (float32)(v) }
func (v ShipName) ApplyTo(r *Record)        { r.ShipName = (*string)(&v) }
func (v ShipName) Column() string           { return "ship_name" }
func (v ShipName) Value() interface{}       { return (string)(v) }
func (v ShipAddress) ApplyTo(r *Record)     { r.ShipAddress = (*string)(&v) }
func (v ShipAddress) Column() string        { return "ship_address" }
func (v ShipAddress) Value() interface{}    { return (string)(v) }
func (v ShipCity) ApplyTo(r *Record)        { r.ShipCity = (*string)(&v) }
func (v ShipCity) Column() string           { return "ship_city" }
func (v ShipCity) Value() interface{}       { return (string)(v) }
func (v ShipRegion) ApplyTo(r *Record)      { r.ShipRegion = (*string)(&v) }
func (v ShipRegion) Column() string         { return "ship_region" }
func (v ShipRegion) Value() interface{}     { return (string)(v) }
func (v ShipPostalCode) ApplyTo(r *Record)  { r.ShipPostalCode = (*string)(&v) }
func (v ShipPostalCode) Column() string     { return "ship_postal_code" }
func (v ShipPostalCode) Value() interface{} { return (string)(v) }
func (v ShipCountry) ApplyTo(r *Record)     { r.ShipCountry = (*string)(&v) }
func (v ShipCountry) Column() string        { return "ship_country" }
func (v ShipCountry) Value() interface{}    { return (string)(v) }

func mustMarshalJSON(v interface{}) []byte {
	b, err := json.Marshal(v)
	if err != nil {
		panic(err)
	}
	return b
}
