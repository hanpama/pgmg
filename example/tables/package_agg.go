// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package tables

import (
	"context"
	"encoding/json"
)

// PackageAggRow represents a row for table "package_agg"
type PackageAggRow struct {
	v PackageAggData
}

type PackageAggData struct {
	ID        *string `json:"id"`
	Name      *string `json:"name"`
	Available *bool   `json:"available"`
	Count     *int64  `json:"count"`
}

func NewPackageAggRow(data PackageAggData) *PackageAggRow {
	return &PackageAggRow{data}
}

func NewPackageAggRows(data ...PackageAggData) PackageAggRows {
	rows := make(PackageAggRows, len(data))
	for i, d := range data {
		rows[i] = NewPackageAggRow(d)
	}
	return rows
}

// GetID gets value of column "id" from "package_agg" row
func (r *PackageAggRow) GetID() string { return *r.v.ID }

// SetID sets value of column "id" in "package_agg" row
func (r *PackageAggRow) SetID(id string) { r.v.ID = &id }

// ClearID sets value of column "id" null in "package_agg" row
func (r *PackageAggRow) ClearID() { r.v.ID = nil }

// HasValidID checks to value of column "id" is not null
func (r *PackageAggRow) HasValidID() bool { return r.v.ID != nil }

// GetName gets value of column "name" from "package_agg" row
func (r *PackageAggRow) GetName() string { return *r.v.Name }

// SetName sets value of column "name" in "package_agg" row
func (r *PackageAggRow) SetName(name string) { r.v.Name = &name }

// ClearName sets value of column "name" null in "package_agg" row
func (r *PackageAggRow) ClearName() { r.v.Name = nil }

// HasValidName checks to value of column "name" is not null
func (r *PackageAggRow) HasValidName() bool { return r.v.Name != nil }

// GetAvailable gets value of column "available" from "package_agg" row
func (r *PackageAggRow) GetAvailable() bool { return *r.v.Available }

// SetAvailable sets value of column "available" in "package_agg" row
func (r *PackageAggRow) SetAvailable(available bool) { r.v.Available = &available }

// ClearAvailable sets value of column "available" null in "package_agg" row
func (r *PackageAggRow) ClearAvailable() { r.v.Available = nil }

// HasValidAvailable checks to value of column "available" is not null
func (r *PackageAggRow) HasValidAvailable() bool { return r.v.Available != nil }

// GetCount gets value of column "count" from "package_agg" row
func (r *PackageAggRow) GetCount() int64 { return *r.v.Count }

// SetCount sets value of column "count" in "package_agg" row
func (r *PackageAggRow) SetCount(count int64) { r.v.Count = &count }

// ClearCount sets value of column "count" null in "package_agg" row
func (r *PackageAggRow) ClearCount() { r.v.Count = nil }

// HasValidCount checks to value of column "count" is not null
func (r *PackageAggRow) HasValidCount() bool { return r.v.Count != nil }

// PackageAggRows represents multiple rows for table "package_agg"
type PackageAggRows []*PackageAggRow

// NewPackageAggTable(h SQLHandle) creates new PackageAggTable
func NewPackageAggTable(h SQLHandle) *PackageAggTable {
	return &PackageAggTable{h}
}

// PackageAggTable provides access methods for table "package_agg"
type PackageAggTable struct {
	h SQLHandle
}

func (t *PackageAggTable) Find(ctx context.Context, filter PackageAggValues) (PackageAggRows, error) {
	return FindPackageAggRows(ctx, t.h, filter)
}

func (t *PackageAggTable) Count(ctx context.Context, filter PackageAggValues) (int, error) {
	return CountPackageAggRows(ctx, t.h, filter)
}

func (t *PackageAggTable) Update(ctx context.Context, changeset, filter PackageAggValues) (int64, error) {
	return UpdatePackageAggRows(ctx, t.h, changeset, filter)
}

func (t *PackageAggTable) Insert(ctx context.Context, rows ...*PackageAggRow) (int, error) {
	return InsertReturningPackageAggRows(ctx, t.h, rows...)
}

func (t *PackageAggTable) Delete(ctx context.Context, filter PackageAggValues) (int64, error) {
	return DeletePackageAggRows(ctx, t.h, filter)
}

type PackageAggValues struct {
	ID        *string `json:"id"`
	Name      *string `json:"name"`
	Available *bool   `json:"available"`
	Count     *int64  `json:"count"`
}

// InsertPackageAggRows inserts the rows into table "package_agg"
func InsertPackageAggRows(ctx context.Context, db SQLHandle, rows ...*PackageAggRow) (affected int64, err error) {
	affected, err = execWithJSONArgs(ctx, db, sqlInsertPackageAggRows, rows)
	if err != nil {
		return affected, formatError("InsertPackageAggRows", err)
	}
	return affected, nil
}

// InsertReturningPackageAggRows inserts the rows into table "package_agg" and returns the rows.
func InsertReturningPackageAggRows(ctx context.Context, db SQLHandle, inputs ...*PackageAggRow) (affected int, err error) {
	rows := PackageAggRows(inputs)
	affected, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlInsertReturningPackageAggRows, rows)
	if err != nil {
		return affected, formatError("InsertReturningPackageAggRows", err)
	}
	return affected, nil
}

// FindPackageAggRows finds the rows matching the condition from table "package_agg"
func FindPackageAggRows(ctx context.Context, db SQLHandle, cond PackageAggValues) (rows PackageAggRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlFindPackageAggRows, cond); err != nil {
		return nil, err
	}
	return rows, nil
}

// DeletePackageAggRows deletes the rows matching the condition from table "package_agg"
func DeletePackageAggRows(ctx context.Context, db SQLHandle, cond PackageAggValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlDeletePackageAggRows, cond)
}

func UpdatePackageAggRows(ctx context.Context, db SQLHandle, changeset, filter PackageAggValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlUpdatePackageAggRows, changeset, filter)
}

// CountPackageAggRows counts the number of rows matching the condition from table "package_agg"
func CountPackageAggRows(ctx context.Context, db SQLHandle, cond PackageAggValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, sqlCountPackageAggRows, cond); err != nil {
		return 0, err
	}
	return count, nil
}

func (r *PackageAggRow) ReceiveRow() []interface{} {
	return []interface{}{&r.v.ID, &r.v.Name, &r.v.Available, &r.v.Count}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PackageAggRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PackageAggRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PackageAggRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PackageAggRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.v)
}

var (
	sqlFindPackageAggRows = `
		WITH __f AS (SELECT "id", "name", "available", "count" FROM json_populate_record(null::"wise"."package_agg", $1))
		SELECT __t.id, __t.name, __t.available, __t.count
		FROM "wise"."package_agg" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))
			AND ((SELECT __f."count" IS NULL FROM __f) OR (SELECT __f."count" = __t."count" FROM __f))`
	sqlCountPackageAggRows = `
		WITH __f AS (SELECT "id", "name", "available", "count" FROM json_populate_record(null::"wise"."package_agg", $1))
		SELECT count(*) FROM "wise"."package_agg" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))
			AND ((SELECT __f."count" IS NULL FROM __f) OR (SELECT __f."count" = __t."count" FROM __f))`
	sqlReturningPackageAggRows = `
		RETURNING "id", "name", "available", "count"`
	sqlInsertPackageAggRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package_agg", $1))
		INSERT INTO "wise"."package_agg" AS __t ("id", "name", "available")
		SELECT 
			__v."id", 
			__v."name", 
			__v."available" FROM __v`
	sqlInsertReturningPackageAggRows = sqlInsertPackageAggRows + sqlReturningPackageAggRows
	sqlDeletePackageAggRows          = `
		DELETE FROM "wise"."package_agg" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS uuid) = __t."id")
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS text) = __t."name")
			AND (($1::json->>'available' IS NULL) OR CAST($1::json->>'available' AS boolean) = __t."available")
			AND (($1::json->>'count' IS NULL) OR CAST($1::json->>'count' AS bigint) = __t."count")`
	sqlDeleteReturningPackageAggRows = sqlDeletePackageAggRows + sqlReturningPackageAggRows
	sqlUpdatePackageAggRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package_agg", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."package_agg", $2))
		UPDATE "wise"."package_agg" AS __t
		SET ("id", "name", "available") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."available", __t."available") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))
			AND ((SELECT __f."count" IS NULL FROM __f) OR (SELECT __f."count" = __t."count" FROM __f))`
	sqlUpdateReturningPackageAggRows = sqlUpdatePackageAggRows + sqlReturningPackageAggRows
)
