// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package tables

import (
	"context"
	"encoding/json"
)

// PackageProductRow represents a row for table "package_product"
type PackageProductRow struct {
	v PackageProductData
}

type PackageProductData struct {
	PackageID string `json:"package_id"`
	ProductID int32  `json:"product_id"`
}

func NewPackageProductRow(data PackageProductData) *PackageProductRow {
	return &PackageProductRow{data}
}

func NewPackageProductRows(data ...PackageProductData) PackageProductRows {
	rows := make(PackageProductRows, len(data))
	for i, d := range data {
		rows[i] = NewPackageProductRow(d)
	}
	return rows
}

// GetPackageID gets value of column "package_id" from "package_product" row
func (r *PackageProductRow) GetPackageID() string { return r.v.PackageID }

// SetPackageID sets value of column "package_id" in "package_product" row
func (r *PackageProductRow) SetPackageID(packageID string) { r.v.PackageID = packageID }

// GetProductID gets value of column "product_id" from "package_product" row
func (r *PackageProductRow) GetProductID() int32 { return r.v.ProductID }

// SetProductID sets value of column "product_id" in "package_product" row
func (r *PackageProductRow) SetProductID(productID int32) { r.v.ProductID = productID }

// PackageProductPackageIDProductID represents key defined by UNIQUE constraint "package_product_package_id_product_id_key" for table "package_product"
type PackageProductPackageIDProductID struct {
	PackageID string `json:"package_id"`
	ProductID int32  `json:"product_id"`
}

func (r *PackageProductRow) KeyPackageIDProductID() PackageProductPackageIDProductID {
	return PackageProductPackageIDProductID{r.GetPackageID(), r.GetProductID()}
}

// PackageProductRows represents multiple rows for table "package_product"
type PackageProductRows []*PackageProductRow

// PackageProductPackageIDProductIDKeyset is a set of key PackageProductPackageIDProductID
type PackageProductPackageIDProductIDKeyset map[PackageProductPackageIDProductID]struct{}

func (rs PackageProductRows) KeyPackageIDProductID() (keys PackageProductPackageIDProductIDKeyset) {
	keys = make(PackageProductPackageIDProductIDKeyset)
	for _, r := range rs {
		keys[r.KeyPackageIDProductID()] = struct{}{}
	}
	return keys
}

func (r *PackageProductRow) RefPackageID() PackageID {
	return PackageID{r.GetPackageID()}
}

func (rs PackageProductRows) RefPackageID() (keys PackageIDKeyset) {
	keys = make(PackageIDKeyset)
	for _, r := range rs {
		keys[r.RefPackageID()] = struct{}{}
	}
	return keys
}
func (r *PackageProductRow) RefProductID() ProductID {
	return ProductID{r.GetProductID()}
}

func (rs PackageProductRows) RefProductID() (keys ProductIDKeyset) {
	keys = make(ProductIDKeyset)
	for _, r := range rs {
		keys[r.RefProductID()] = struct{}{}
	}
	return keys
}

// NewPackageProductTable(h SQLHandle) creates new PackageProductTable
func NewPackageProductTable(h SQLHandle) *PackageProductTable {
	return &PackageProductTable{h}
}

// PackageProductTable provides access methods for table "package_product"
type PackageProductTable struct {
	h SQLHandle
}

func (t *PackageProductTable) Find(ctx context.Context, filter PackageProductValues) (PackageProductRows, error) {
	return FindPackageProductRows(ctx, t.h, filter)
}

func (t *PackageProductTable) Count(ctx context.Context, filter PackageProductValues) (int, error) {
	return CountPackageProductRows(ctx, t.h, filter)
}

func (t *PackageProductTable) Update(ctx context.Context, changeset, filter PackageProductValues) (int64, error) {
	return UpdatePackageProductRows(ctx, t.h, changeset, filter)
}

func (t *PackageProductTable) Insert(ctx context.Context, rows ...*PackageProductRow) (int, error) {
	return InsertReturningPackageProductRows(ctx, t.h, rows...)
}

func (t *PackageProductTable) Delete(ctx context.Context, filter PackageProductValues) (int64, error) {
	return DeletePackageProductRows(ctx, t.h, filter)
}

func (t *PackageProductTable) Save(ctx context.Context, rows ...*PackageProductRow) error {
	return SaveReturningPackageProductRows(ctx, t.h, rows...)
}

func (t *PackageProductTable) GetByPackageIDProductID(ctx context.Context, keys ...PackageProductPackageIDProductID) (PackageProductRows, error) {
	return GetPackageProductRowsByPackageIDProductID(ctx, t.h, keys...)
}

func (t *PackageProductTable) UpdateByPackageIDProductID(ctx context.Context, changeset PackageProductValues, keys ...PackageProductPackageIDProductID) (int64, error) {
	return UpdatePackageProductRowsByPackageIDProductID(ctx, t.h, changeset, keys...)
}

func (t *PackageProductTable) DeleteByPackageIDProductID(ctx context.Context, keys ...PackageProductPackageIDProductID) (int64, error) {
	return DeletePackageProductRowsByPackageIDProductID(ctx, t.h, keys...)
}

type PackageProductValues struct {
	PackageID *string `json:"package_id"`
	ProductID *int32  `json:"product_id"`
}

// InsertPackageProductRows inserts the rows into table "package_product"
func InsertPackageProductRows(ctx context.Context, db SQLHandle, rows ...*PackageProductRow) (affected int64, err error) {
	affected, err = execWithJSONArgs(ctx, db, sqlInsertPackageProductRows, rows)
	if err != nil {
		return affected, formatError("InsertPackageProductRows", err)
	}
	return affected, nil
}

// InsertReturningPackageProductRows inserts the rows into table "package_product" and returns the rows.
func InsertReturningPackageProductRows(ctx context.Context, db SQLHandle, inputs ...*PackageProductRow) (affected int, err error) {
	rows := PackageProductRows(inputs)
	affected, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlInsertReturningPackageProductRows, rows)
	if err != nil {
		return affected, formatError("InsertReturningPackageProductRows", err)
	}
	return affected, nil
}

// FindPackageProductRows finds the rows matching the condition from table "package_product"
func FindPackageProductRows(ctx context.Context, db SQLHandle, cond PackageProductValues) (rows PackageProductRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlFindPackageProductRows, cond); err != nil {
		return nil, err
	}
	return rows, nil
}

// DeletePackageProductRows deletes the rows matching the condition from table "package_product"
func DeletePackageProductRows(ctx context.Context, db SQLHandle, cond PackageProductValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlDeletePackageProductRows, cond)
}

func UpdatePackageProductRows(ctx context.Context, db SQLHandle, changeset, filter PackageProductValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlUpdatePackageProductRows, changeset, filter)
}

// CountPackageProductRows counts the number of rows matching the condition from table "package_product"
func CountPackageProductRows(ctx context.Context, db SQLHandle, cond PackageProductValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, sqlCountPackageProductRows, cond); err != nil {
		return 0, err
	}
	return count, nil
}

// SavePackageProductRows upserts the given rows for table "package_product" checking uniqueness by contstraint "package_product_package_id_product_id_key"
func SavePackageProductRows(ctx context.Context, db SQLHandle, rows ...*PackageProductRow) (err error) {
	numRows, err := execWithJSONArgs(ctx, db, sqlSavePackageProductRows, rows)
	if err != nil {
		return formatError("Save", err)
	}
	if int64(len(rows)) != numRows {
		return formatError("Save", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// SaveReturningPackageProductRows upserts the given rows for table "package_product" checking uniqueness by contstraint "package_product_package_id_product_id_key"
// It returns the new values and scan them into given row references.
func SaveReturningPackageProductRows(ctx context.Context, db SQLHandle, inputs ...*PackageProductRow) (err error) {
	rows := PackageProductRows(inputs)
	numRows, err := queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlSaveReturningPackageProductRows, rows)
	if err != nil {
		return formatError("SaveReturning", err)
	}
	if len(rows) != numRows {
		return formatError("SaveReturning", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// GetPackageProductRowsByPackageIDProductID gets matching rows for given PackageIDProductID keys from table "package_product"
func GetPackageProductRowsByPackageIDProductID(ctx context.Context, db SQLHandle, keys ...PackageProductPackageIDProductID) (rows PackageProductRows, err error) {
	rows = make(PackageProductRows, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlGetPackageProductRowsByPackageIDProductID, keys); err != nil {
		return nil, formatError("GetPackageProductRowsByPackageIDProductID", err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].KeyPackageIDProductID() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// DeletePackageProductRowsByPackageIDProductID deletes matching rows by PackageProductPackageIDProductID keys from table "package_product"
func DeletePackageProductRowsByPackageIDProductID(ctx context.Context, db SQLHandle, keys ...PackageProductPackageIDProductID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlDeletePackageProductRowsByPackageIDProductID, keys)
	if err != nil {
		return numRows, formatError("DeleteByPackageIDProductID", err)
	}
	return numRows, nil
}

// UpdatePackageProductRowsByPackageIDProductID deletes matching rows by PackageProductPackageIDProductID keys from table "package_product"
func UpdatePackageProductRowsByPackageIDProductID(ctx context.Context, db SQLHandle, changeset PackageProductValues, keys ...PackageProductPackageIDProductID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlUpdatePackageProductRowsByPackageIDProductID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateByPackageIDProductID", err)
	}
	return numRows, nil
}

func (r *PackageProductRow) ReceiveRow() []interface{} {
	return []interface{}{&r.v.PackageID, &r.v.ProductID}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PackageProductRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PackageProductRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PackageProductRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PackageProductRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.v)
}

func (keyset PackageProductPackageIDProductIDKeyset) Keys() (keys []PackageProductPackageIDProductID) {
	for k := range keyset {
		keys = append(keys, k)
	}
	return keys
}

func (keyset PackageProductPackageIDProductIDKeyset) Add(keys ...PackageProductPackageIDProductID) {
	for _, k := range keys {
		keyset[k] = struct{}{}
	}
}

func (keyset PackageProductPackageIDProductIDKeyset) Remove(keys ...PackageProductPackageIDProductID) {
	for _, k := range keys {
		delete(keyset, k)
	}
}

var (
	sqlFindPackageProductRows = `
		WITH __f AS (SELECT "package_id", "product_id" FROM json_populate_record(null::"wise"."package_product", $1))
		SELECT __t.package_id, __t.product_id
		FROM "wise"."package_product" AS __t
		WHERE ((SELECT __f."package_id" IS NULL FROM __f) OR (SELECT __f."package_id" = __t."package_id" FROM __f))
			AND ((SELECT __f."product_id" IS NULL FROM __f) OR (SELECT __f."product_id" = __t."product_id" FROM __f))`
	sqlCountPackageProductRows = `
		WITH __f AS (SELECT "package_id", "product_id" FROM json_populate_record(null::"wise"."package_product", $1))
		SELECT count(*) FROM "wise"."package_product" AS __t
		WHERE ((SELECT __f."package_id" IS NULL FROM __f) OR (SELECT __f."package_id" = __t."package_id" FROM __f))
			AND ((SELECT __f."product_id" IS NULL FROM __f) OR (SELECT __f."product_id" = __t."product_id" FROM __f))`
	sqlReturningPackageProductRows = `
		RETURNING "package_id", "product_id"`
	sqlInsertPackageProductRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package_product", $1))
		INSERT INTO "wise"."package_product" AS __t ("package_id", "product_id")
		SELECT 
			__v."package_id", 
			__v."product_id" FROM __v`
	sqlInsertReturningPackageProductRows = sqlInsertPackageProductRows + sqlReturningPackageProductRows
	sqlDeletePackageProductRows          = `
		DELETE FROM "wise"."package_product" AS __t
		WHERE TRUE
			AND (($1::json->>'package_id' IS NULL) OR CAST($1::json->>'package_id' AS uuid) = __t."package_id")
			AND (($1::json->>'product_id' IS NULL) OR CAST($1::json->>'product_id' AS integer) = __t."product_id")`
	sqlDeleteReturningPackageProductRows = sqlDeletePackageProductRows + sqlReturningPackageProductRows
	sqlUpdatePackageProductRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package_product", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."package_product", $2))
		UPDATE "wise"."package_product" AS __t
		SET ("package_id", "product_id") = (SELECT 
			COALESCE(__v."package_id", __t."package_id"), 
			COALESCE(__v."product_id", __t."product_id") FROM __v)
		WHERE ((SELECT __f."package_id" IS NULL FROM __f) OR (SELECT __f."package_id" = __t."package_id" FROM __f))
			AND ((SELECT __f."product_id" IS NULL FROM __f) OR (SELECT __f."product_id" = __t."product_id" FROM __f))`
	sqlUpdateReturningPackageProductRows = sqlUpdatePackageProductRows + sqlReturningPackageProductRows
	sqlReplacePackageProductRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package_product", $1))
		UPDATE "wise"."package_product" AS __t
			SET ("package_id", "product_id") = (SELECT 
				COALESCE(__v."package_id", __t."package_id"), 
				COALESCE(__v."product_id", __t."product_id")
			FROM __v WHERE __v."package_id" = __t."package_id" AND __v."product_id" = __t."product_id")
		FROM __v WHERE __v."package_id" = __t."package_id" AND __v."product_id" = __t."product_id"`
	sqlReplaceReturningPackageProductRows = sqlReplacePackageProductRows + sqlReturningPackageProductRows
	sqlSavePackageProductRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package_product", $1))
		INSERT INTO "wise"."package_product" AS __t ("package_id", "product_id")
		SELECT 
			__v."package_id", 
			__v."product_id" FROM __v
		ON CONFLICT ("package_id", "product_id") DO UPDATE
		SET ("package_id", "product_id") = (
			SELECT "package_id", "product_id" FROM __v
			WHERE __v."package_id" = __t."package_id"
				AND __v."product_id" = __t."product_id"
		)`
	sqlSaveReturningPackageProductRows           = sqlSavePackageProductRows + sqlReturningPackageProductRows
	sqlGetPackageProductRowsByPackageIDProductID = `
		WITH __key AS (SELECT ROW_NUMBER() over () __idx, "package_id", "product_id" FROM json_populate_recordset(null::"wise"."package_product", $1))
		SELECT "package_id", "product_id"
		FROM __key JOIN "wise"."package_product" AS __t USING ("package_id", "product_id")
		ORDER BY __idx`
	sqlUpdatePackageProductRowsByPackageIDProductID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package_product", $1)),
		  __key AS (SELECT package_id, product_id FROM json_populate_recordset(null::"wise"."package_product", $2))
		UPDATE "wise"."package_product" AS __t
		SET ("package_id", "product_id") = (SELECT
			COALESCE(__v."package_id", __t."package_id"), 
			COALESCE(__v."product_id", __t."product_id")
		FROM __v)
		FROM __key WHERE (__key."package_id" = __t."package_id")AND (__key."product_id" = __t."product_id")`
	sqlDeletePackageProductRowsByPackageIDProductID = `
		WITH __key AS (SELECT package_id, product_id FROM json_populate_recordset(null::"wise"."package_product", $1))
		DELETE FROM "wise"."package_product" AS __t USING __key WHERE (__key."package_id" = __t."package_id") AND (__key."product_id" = __t."product_id")`
	sqlDeleteReturningPackageProductRowsByPackageIDProductID = sqlDeletePackageProductRowsByPackageIDProductID + sqlReturningPackageProductRows
)
