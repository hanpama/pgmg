// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package tables

import (
	"context"
	"encoding/json"
	"time"
)

// ProductRow represents a row for table "product"
type ProductRow struct {
	v ProductData
}

type ProductData struct {
	ID      *int32     `json:"id"`
	Price   string     `json:"price"`
	Name    string     `json:"name"`
	Alias   string     `json:"alias"`
	Stocked time.Time  `json:"stocked"`
	Sold    *time.Time `json:"sold"`
}

func NewProductRow(data ProductData) *ProductRow {
	return &ProductRow{data}
}

func NewProductRows(data ...ProductData) ProductRows {
	rows := make(ProductRows, len(data))
	for i, d := range data {
		rows[i] = NewProductRow(d)
	}
	return rows
}

// GetID gets value of column "id" from "product" row
func (r *ProductRow) GetID() int32 { return *r.v.ID }

// SetID sets value of column "id" in "product" row
func (r *ProductRow) SetID(id int32) { r.v.ID = &id }

// ClearID sets value of column "id" null in "product" row
func (r *ProductRow) ClearID() { r.v.ID = nil }

// HasValidID checks to value of column "id" is not null
func (r *ProductRow) HasValidID() bool { return r.v.ID != nil }

// GetPrice gets value of column "price" from "product" row
func (r *ProductRow) GetPrice() string { return r.v.Price }

// SetPrice sets value of column "price" in "product" row
func (r *ProductRow) SetPrice(price string) { r.v.Price = price }

// GetName gets value of column "name" from "product" row
func (r *ProductRow) GetName() string { return r.v.Name }

// SetName sets value of column "name" in "product" row
func (r *ProductRow) SetName(name string) { r.v.Name = name }

// GetAlias gets value of column "alias" from "product" row
func (r *ProductRow) GetAlias() string { return r.v.Alias }

// SetAlias sets value of column "alias" in "product" row
func (r *ProductRow) SetAlias(alias string) { r.v.Alias = alias }

// GetStocked gets value of column "stocked" from "product" row
func (r *ProductRow) GetStocked() time.Time { return r.v.Stocked }

// SetStocked sets value of column "stocked" in "product" row
func (r *ProductRow) SetStocked(stocked time.Time) { r.v.Stocked = stocked }

// GetSold gets value of column "sold" from "product" row
func (r *ProductRow) GetSold() time.Time { return *r.v.Sold }

// SetSold sets value of column "sold" in "product" row
func (r *ProductRow) SetSold(sold time.Time) { r.v.Sold = &sold }

// ClearSold sets value of column "sold" null in "product" row
func (r *ProductRow) ClearSold() { r.v.Sold = nil }

// HasValidSold checks to value of column "sold" is not null
func (r *ProductRow) HasValidSold() bool { return r.v.Sold != nil }

// ProductID represents key defined by PRIMARY KEY constraint "product_pkey" for table "product"
type ProductID struct {
	ID int32 `json:"id"`
}

func (r *ProductRow) KeyID() ProductID {
	return ProductID{r.GetID()}
}

// ProductAlias represents key defined by UNIQUE constraint "product_alias_key" for table "product"
type ProductAlias struct {
	Alias string `json:"alias"`
}

func (r *ProductRow) KeyAlias() ProductAlias {
	return ProductAlias{r.GetAlias()}
}

// ProductRows represents multiple rows for table "product"
type ProductRows []*ProductRow

// ProductIDKeyset is a set of key ProductID
type ProductIDKeyset map[ProductID]struct{}

func (rs ProductRows) KeyID() (keys ProductIDKeyset) {
	keys = make(ProductIDKeyset)
	for _, r := range rs {
		keys[r.KeyID()] = struct{}{}
	}
	return keys
}

// ProductAliasKeyset is a set of key ProductAlias
type ProductAliasKeyset map[ProductAlias]struct{}

func (rs ProductRows) KeyAlias() (keys ProductAliasKeyset) {
	keys = make(ProductAliasKeyset)
	for _, r := range rs {
		keys[r.KeyAlias()] = struct{}{}
	}
	return keys
}

// NewProductTable(h SQLHandle) creates new ProductTable
func NewProductTable(h SQLHandle) *ProductTable {
	return &ProductTable{h}
}

// ProductTable provides access methods for table "product"
type ProductTable struct {
	h SQLHandle
}

func (t *ProductTable) Find(ctx context.Context, filter ProductValues) (ProductRows, error) {
	return FindProductRows(ctx, t.h, filter)
}

func (t *ProductTable) Count(ctx context.Context, filter ProductValues) (int, error) {
	return CountProductRows(ctx, t.h, filter)
}

func (t *ProductTable) Update(ctx context.Context, changeset, filter ProductValues) (int64, error) {
	return UpdateProductRows(ctx, t.h, changeset, filter)
}

func (t *ProductTable) Insert(ctx context.Context, rows ...*ProductRow) (int, error) {
	return InsertReturningProductRows(ctx, t.h, rows...)
}

func (t *ProductTable) Delete(ctx context.Context, filter ProductValues) (int64, error) {
	return DeleteProductRows(ctx, t.h, filter)
}

func (t *ProductTable) Save(ctx context.Context, rows ...*ProductRow) error {
	return SaveReturningProductRows(ctx, t.h, rows...)
}

func (t *ProductTable) GetByID(ctx context.Context, keys ...ProductID) (ProductRows, error) {
	return GetProductRowsByID(ctx, t.h, keys...)
}

func (t *ProductTable) UpdateByID(ctx context.Context, changeset ProductValues, keys ...ProductID) (int64, error) {
	return UpdateProductRowsByID(ctx, t.h, changeset, keys...)
}

func (t *ProductTable) DeleteByID(ctx context.Context, keys ...ProductID) (int64, error) {
	return DeleteProductRowsByID(ctx, t.h, keys...)
}

func (t *ProductTable) GetByAlias(ctx context.Context, keys ...ProductAlias) (ProductRows, error) {
	return GetProductRowsByAlias(ctx, t.h, keys...)
}

func (t *ProductTable) UpdateByAlias(ctx context.Context, changeset ProductValues, keys ...ProductAlias) (int64, error) {
	return UpdateProductRowsByAlias(ctx, t.h, changeset, keys...)
}

func (t *ProductTable) DeleteByAlias(ctx context.Context, keys ...ProductAlias) (int64, error) {
	return DeleteProductRowsByAlias(ctx, t.h, keys...)
}

type ProductValues struct {
	ID      *int32     `json:"id"`
	Price   *string    `json:"price"`
	Name    *string    `json:"name"`
	Alias   *string    `json:"alias"`
	Stocked *time.Time `json:"stocked"`
	Sold    *time.Time `json:"sold"`
}

// InsertProductRows inserts the rows into table "product"
func InsertProductRows(ctx context.Context, db SQLHandle, rows ...*ProductRow) (affected int64, err error) {
	affected, err = execWithJSONArgs(ctx, db, sqlInsertProductRows, rows)
	if err != nil {
		return affected, formatError("InsertProductRows", err)
	}
	return affected, nil
}

// InsertReturningProductRows inserts the rows into table "product" and returns the rows.
func InsertReturningProductRows(ctx context.Context, db SQLHandle, inputs ...*ProductRow) (affected int, err error) {
	rows := ProductRows(inputs)
	affected, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlInsertReturningProductRows, rows)
	if err != nil {
		return affected, formatError("InsertReturningProductRows", err)
	}
	return affected, nil
}

// FindProductRows finds the rows matching the condition from table "product"
func FindProductRows(ctx context.Context, db SQLHandle, cond ProductValues) (rows ProductRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlFindProductRows, cond); err != nil {
		return nil, err
	}
	return rows, nil
}

// DeleteProductRows deletes the rows matching the condition from table "product"
func DeleteProductRows(ctx context.Context, db SQLHandle, cond ProductValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlDeleteProductRows, cond)
}

func UpdateProductRows(ctx context.Context, db SQLHandle, changeset, filter ProductValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlUpdateProductRows, changeset, filter)
}

// CountProductRows counts the number of rows matching the condition from table "product"
func CountProductRows(ctx context.Context, db SQLHandle, cond ProductValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, sqlCountProductRows, cond); err != nil {
		return 0, err
	}
	return count, nil
}

// SaveProductRows upserts the given rows for table "product" checking uniqueness by contstraint "product_pkey"
func SaveProductRows(ctx context.Context, db SQLHandle, rows ...*ProductRow) (err error) {
	numRows, err := execWithJSONArgs(ctx, db, sqlSaveProductRows, rows)
	if err != nil {
		return formatError("Save", err)
	}
	if int64(len(rows)) != numRows {
		return formatError("Save", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// SaveReturningProductRows upserts the given rows for table "product" checking uniqueness by contstraint "product_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningProductRows(ctx context.Context, db SQLHandle, inputs ...*ProductRow) (err error) {
	rows := ProductRows(inputs)
	numRows, err := queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlSaveReturningProductRows, rows)
	if err != nil {
		return formatError("SaveReturning", err)
	}
	if len(rows) != numRows {
		return formatError("SaveReturning", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// GetProductRowsByID gets matching rows for given ID keys from table "product"
func GetProductRowsByID(ctx context.Context, db SQLHandle, keys ...ProductID) (rows ProductRows, err error) {
	rows = make(ProductRows, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlGetProductRowsByID, keys); err != nil {
		return nil, formatError("GetProductRowsByID", err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].KeyID() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// DeleteProductRowsByID deletes matching rows by ProductID keys from table "product"
func DeleteProductRowsByID(ctx context.Context, db SQLHandle, keys ...ProductID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlDeleteProductRowsByID, keys)
	if err != nil {
		return numRows, formatError("DeleteByID", err)
	}
	return numRows, nil
}

// UpdateProductRowsByID deletes matching rows by ProductID keys from table "product"
func UpdateProductRowsByID(ctx context.Context, db SQLHandle, changeset ProductValues, keys ...ProductID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlUpdateProductRowsByID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateByID", err)
	}
	return numRows, nil
}

// GetProductRowsByAlias gets matching rows for given Alias keys from table "product"
func GetProductRowsByAlias(ctx context.Context, db SQLHandle, keys ...ProductAlias) (rows ProductRows, err error) {
	rows = make(ProductRows, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlGetProductRowsByAlias, keys); err != nil {
		return nil, formatError("GetProductRowsByAlias", err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].KeyAlias() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// DeleteProductRowsByAlias deletes matching rows by ProductAlias keys from table "product"
func DeleteProductRowsByAlias(ctx context.Context, db SQLHandle, keys ...ProductAlias) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlDeleteProductRowsByAlias, keys)
	if err != nil {
		return numRows, formatError("DeleteByAlias", err)
	}
	return numRows, nil
}

// UpdateProductRowsByAlias deletes matching rows by ProductAlias keys from table "product"
func UpdateProductRowsByAlias(ctx context.Context, db SQLHandle, changeset ProductValues, keys ...ProductAlias) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlUpdateProductRowsByAlias, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateByAlias", err)
	}
	return numRows, nil
}

func (r *ProductRow) ReceiveRow() []interface{} {
	return []interface{}{&r.v.ID, &r.v.Price, &r.v.Name, &r.v.Alias, &r.v.Stocked, &r.v.Sold}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *ProductRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(ProductRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(ProductRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *ProductRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.v)
}

func (keyset ProductIDKeyset) Keys() (keys []ProductID) {
	for k := range keyset {
		keys = append(keys, k)
	}
	return keys
}

func (keyset ProductIDKeyset) Add(keys ...ProductID) {
	for _, k := range keys {
		keyset[k] = struct{}{}
	}
}

func (keyset ProductIDKeyset) Remove(keys ...ProductID) {
	for _, k := range keys {
		delete(keyset, k)
	}
}
func (keyset ProductAliasKeyset) Keys() (keys []ProductAlias) {
	for k := range keyset {
		keys = append(keys, k)
	}
	return keys
}

func (keyset ProductAliasKeyset) Add(keys ...ProductAlias) {
	for _, k := range keys {
		keyset[k] = struct{}{}
	}
}

func (keyset ProductAliasKeyset) Remove(keys ...ProductAlias) {
	for _, k := range keys {
		delete(keyset, k)
	}
}

var (
	sqlFindProductRows = `
		WITH __f AS (SELECT "id", "price", "name", "alias", "stocked", "sold" FROM json_populate_record(null::"wise"."product", $1))
		SELECT __t.id, __t.price, __t.name, __t.alias, __t.stocked, __t.sold
		FROM "wise"."product" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."price" IS NULL FROM __f) OR (SELECT __f."price" = __t."price" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."alias" IS NULL FROM __f) OR (SELECT __f."alias" = __t."alias" FROM __f))
			AND ((SELECT __f."stocked" IS NULL FROM __f) OR (SELECT __f."stocked" = __t."stocked" FROM __f))
			AND ((SELECT __f."sold" IS NULL FROM __f) OR (SELECT __f."sold" = __t."sold" FROM __f))`
	sqlCountProductRows = `
		WITH __f AS (SELECT "id", "price", "name", "alias", "stocked", "sold" FROM json_populate_record(null::"wise"."product", $1))
		SELECT count(*) FROM "wise"."product" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."price" IS NULL FROM __f) OR (SELECT __f."price" = __t."price" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."alias" IS NULL FROM __f) OR (SELECT __f."alias" = __t."alias" FROM __f))
			AND ((SELECT __f."stocked" IS NULL FROM __f) OR (SELECT __f."stocked" = __t."stocked" FROM __f))
			AND ((SELECT __f."sold" IS NULL FROM __f) OR (SELECT __f."sold" = __t."sold" FROM __f))`
	sqlReturningProductRows = `
		RETURNING "id", "price", "name", "alias", "stocked", "sold"`
	sqlInsertProductRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."product", $1))
		INSERT INTO "wise"."product" AS __t ("id", "price", "name", "alias", "stocked", "sold")
		SELECT 
			COALESCE(__v."id", nextval('wise.product_id_seq'::regclass)), 
			__v."price", 
			__v."name", 
			__v."alias", 
			__v."stocked", 
			__v."sold" FROM __v`
	sqlInsertReturningProductRows = sqlInsertProductRows + sqlReturningProductRows
	sqlDeleteProductRows          = `
		DELETE FROM "wise"."product" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS integer) = __t."id")
			AND (($1::json->>'price' IS NULL) OR CAST($1::json->>'price' AS money) = __t."price")
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS character varying) = __t."name")
			AND (($1::json->>'alias' IS NULL) OR CAST($1::json->>'alias' AS character varying) = __t."alias")
			AND (($1::json->>'stocked' IS NULL) OR CAST($1::json->>'stocked' AS timestamp with time zone) = __t."stocked")
			AND (($1::json->>'sold' IS NULL) OR CAST($1::json->>'sold' AS timestamp with time zone) = __t."sold")`
	sqlDeleteReturningProductRows = sqlDeleteProductRows + sqlReturningProductRows
	sqlUpdateProductRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."product", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."product", $2))
		UPDATE "wise"."product" AS __t
		SET ("id", "price", "name", "alias", "stocked", "sold") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."price", __t."price"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."alias", __t."alias"), 
			COALESCE(__v."stocked", __t."stocked"), 
			COALESCE(__v."sold", __t."sold") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."price" IS NULL FROM __f) OR (SELECT __f."price" = __t."price" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."alias" IS NULL FROM __f) OR (SELECT __f."alias" = __t."alias" FROM __f))
			AND ((SELECT __f."stocked" IS NULL FROM __f) OR (SELECT __f."stocked" = __t."stocked" FROM __f))
			AND ((SELECT __f."sold" IS NULL FROM __f) OR (SELECT __f."sold" = __t."sold" FROM __f))`
	sqlUpdateReturningProductRows = sqlUpdateProductRows + sqlReturningProductRows
	sqlReplaceProductRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."product", $1))
		UPDATE "wise"."product" AS __t
			SET ("id", "price", "name", "alias", "stocked", "sold") = (SELECT 
				COALESCE(__v."id", __t."id"), 
				COALESCE(__v."price", __t."price"), 
				COALESCE(__v."name", __t."name"), 
				COALESCE(__v."alias", __t."alias"), 
				COALESCE(__v."stocked", __t."stocked"), 
				COALESCE(__v."sold", __t."sold")
			FROM __v WHERE __v."id" = __t."id")
		FROM __v WHERE __v."id" = __t."id"`
	sqlReplaceReturningProductRows = sqlReplaceProductRows + sqlReturningProductRows
	sqlSaveProductRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."product", $1))
		INSERT INTO "wise"."product" AS __t ("id", "price", "name", "alias", "stocked", "sold")
		SELECT 
			COALESCE(__v."id", nextval('wise.product_id_seq'::regclass)), 
			__v."price", 
			__v."name", 
			__v."alias", 
			__v."stocked", 
			__v."sold" FROM __v
		ON CONFLICT ("id") DO UPDATE
		SET ("id", "price", "name", "alias", "stocked", "sold") = (
			SELECT "id", "price", "name", "alias", "stocked", "sold" FROM __v
			WHERE __v."id" = __t."id"
		)`
	sqlSaveReturningProductRows = sqlSaveProductRows + sqlReturningProductRows
	sqlGetProductRowsByID       = `
		WITH __key AS (SELECT ROW_NUMBER() over () __idx, "id" FROM json_populate_recordset(null::"wise"."product", $1))
		SELECT "id", "price", "name", "alias", "stocked", "sold"
		FROM __key JOIN "wise"."product" AS __t USING ("id")
		ORDER BY __idx`
	sqlUpdateProductRowsByID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."product", $1)),
		  __key AS (SELECT id FROM json_populate_recordset(null::"wise"."product", $2))
		UPDATE "wise"."product" AS __t
		SET ("id", "price", "name", "alias", "stocked", "sold") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."price", __t."price"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."alias", __t."alias"), 
			COALESCE(__v."stocked", __t."stocked"), 
			COALESCE(__v."sold", __t."sold")
		FROM __v)
		FROM __key WHERE (__key."id" = __t."id")`
	sqlDeleteProductRowsByID = `
		WITH __key AS (SELECT id FROM json_populate_recordset(null::"wise"."product", $1))
		DELETE FROM "wise"."product" AS __t USING __key WHERE (__key."id" = __t."id")`
	sqlDeleteReturningProductRowsByID = sqlDeleteProductRowsByID + sqlReturningProductRows
	sqlGetProductRowsByAlias          = `
		WITH __key AS (SELECT ROW_NUMBER() over () __idx, "alias" FROM json_populate_recordset(null::"wise"."product", $1))
		SELECT "id", "price", "name", "alias", "stocked", "sold"
		FROM __key JOIN "wise"."product" AS __t USING ("alias")
		ORDER BY __idx`
	sqlUpdateProductRowsByAlias = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."product", $1)),
		  __key AS (SELECT alias FROM json_populate_recordset(null::"wise"."product", $2))
		UPDATE "wise"."product" AS __t
		SET ("id", "price", "name", "alias", "stocked", "sold") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."price", __t."price"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."alias", __t."alias"), 
			COALESCE(__v."stocked", __t."stocked"), 
			COALESCE(__v."sold", __t."sold")
		FROM __v)
		FROM __key WHERE (__key."alias" = __t."alias")`
	sqlDeleteProductRowsByAlias = `
		WITH __key AS (SELECT alias FROM json_populate_recordset(null::"wise"."product", $1))
		DELETE FROM "wise"."product" AS __t USING __key WHERE (__key."alias" = __t."alias")`
	sqlDeleteReturningProductRowsByAlias = sqlDeleteProductRowsByAlias + sqlReturningProductRows
)
