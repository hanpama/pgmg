// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package tables

import (
	"context"
	"encoding/json"
)

// PopRow represents a row for table "pop"
type PopRow struct {
	v PopData
}

type PopData struct {
	Name        string `json:"name"`
	Year        int32  `json:"year"`
	Description string `json:"description"`
}

func NewPopRow(data PopData) *PopRow {
	return &PopRow{data}
}

func NewPopRows(data ...PopData) PopRows {
	rows := make(PopRows, len(data))
	for i, d := range data {
		rows[i] = NewPopRow(d)
	}
	return rows
}

// GetName gets value of column "name" from "pop" row
func (r *PopRow) GetName() string { return r.v.Name }

// SetName sets value of column "name" in "pop" row
func (r *PopRow) SetName(name string) { r.v.Name = name }

// GetYear gets value of column "year" from "pop" row
func (r *PopRow) GetYear() int32 { return r.v.Year }

// SetYear sets value of column "year" in "pop" row
func (r *PopRow) SetYear(year int32) { r.v.Year = year }

// GetDescription gets value of column "description" from "pop" row
func (r *PopRow) GetDescription() string { return r.v.Description }

// SetDescription sets value of column "description" in "pop" row
func (r *PopRow) SetDescription(description string) { r.v.Description = description }

// PopNameYear represents key defined by PRIMARY KEY constraint "pop_pkey" for table "pop"
type PopNameYear struct {
	Name string `json:"name"`
	Year int32  `json:"year"`
}

func (r *PopRow) KeyNameYear() PopNameYear {
	return PopNameYear{r.GetName(), r.GetYear()}
}

// PopRows represents multiple rows for table "pop"
type PopRows []*PopRow

// PopNameYearKeyset is a set of key PopNameYear
type PopNameYearKeyset map[PopNameYear]struct{}

func (rs PopRows) KeyNameYear() (keys PopNameYearKeyset) {
	keys = make(PopNameYearKeyset)
	for _, r := range rs {
		keys[r.KeyNameYear()] = struct{}{}
	}
	return keys
}

// NewPopTable(h SQLHandle) creates new PopTable
func NewPopTable(h SQLHandle) *PopTable {
	return &PopTable{h}
}

// PopTable provides access methods for table "pop"
type PopTable struct {
	h SQLHandle
}

func (t *PopTable) Find(ctx context.Context, filter PopValues) (PopRows, error) {
	return FindPopRows(ctx, t.h, filter)
}

func (t *PopTable) Count(ctx context.Context, filter PopValues) (int, error) {
	return CountPopRows(ctx, t.h, filter)
}

func (t *PopTable) Update(ctx context.Context, changeset, filter PopValues) (int64, error) {
	return UpdatePopRows(ctx, t.h, changeset, filter)
}

func (t *PopTable) Insert(ctx context.Context, rows ...*PopRow) (int, error) {
	return InsertReturningPopRows(ctx, t.h, rows...)
}

func (t *PopTable) Delete(ctx context.Context, filter PopValues) (int64, error) {
	return DeletePopRows(ctx, t.h, filter)
}

func (t *PopTable) Save(ctx context.Context, rows ...*PopRow) error {
	return SaveReturningPopRows(ctx, t.h, rows...)
}

func (t *PopTable) GetByNameYear(ctx context.Context, keys ...PopNameYear) (PopRows, error) {
	return GetPopRowsByNameYear(ctx, t.h, keys...)
}

func (t *PopTable) UpdateByNameYear(ctx context.Context, changeset PopValues, keys ...PopNameYear) (int64, error) {
	return UpdatePopRowsByNameYear(ctx, t.h, changeset, keys...)
}

func (t *PopTable) DeleteByNameYear(ctx context.Context, keys ...PopNameYear) (int64, error) {
	return DeletePopRowsByNameYear(ctx, t.h, keys...)
}

type PopValues struct {
	Name        *string `json:"name"`
	Year        *int32  `json:"year"`
	Description *string `json:"description"`
}

// InsertPopRows inserts the rows into table "pop"
func InsertPopRows(ctx context.Context, db SQLHandle, rows ...*PopRow) (affected int64, err error) {
	affected, err = execWithJSONArgs(ctx, db, sqlInsertPopRows, rows)
	if err != nil {
		return affected, formatError("InsertPopRows", err)
	}
	return affected, nil
}

// InsertReturningPopRows inserts the rows into table "pop" and returns the rows.
func InsertReturningPopRows(ctx context.Context, db SQLHandle, inputs ...*PopRow) (affected int, err error) {
	rows := PopRows(inputs)
	affected, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlInsertReturningPopRows, rows)
	if err != nil {
		return affected, formatError("InsertReturningPopRows", err)
	}
	return affected, nil
}

// FindPopRows finds the rows matching the condition from table "pop"
func FindPopRows(ctx context.Context, db SQLHandle, cond PopValues) (rows PopRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlFindPopRows, cond); err != nil {
		return nil, err
	}
	return rows, nil
}

// DeletePopRows deletes the rows matching the condition from table "pop"
func DeletePopRows(ctx context.Context, db SQLHandle, cond PopValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlDeletePopRows, cond)
}

func UpdatePopRows(ctx context.Context, db SQLHandle, changeset, filter PopValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlUpdatePopRows, changeset, filter)
}

// CountPopRows counts the number of rows matching the condition from table "pop"
func CountPopRows(ctx context.Context, db SQLHandle, cond PopValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, sqlCountPopRows, cond); err != nil {
		return 0, err
	}
	return count, nil
}

// SavePopRows upserts the given rows for table "pop" checking uniqueness by contstraint "pop_pkey"
func SavePopRows(ctx context.Context, db SQLHandle, rows ...*PopRow) (err error) {
	numRows, err := execWithJSONArgs(ctx, db, sqlSavePopRows, rows)
	if err != nil {
		return formatError("Save", err)
	}
	if int64(len(rows)) != numRows {
		return formatError("Save", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// SaveReturningPopRows upserts the given rows for table "pop" checking uniqueness by contstraint "pop_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningPopRows(ctx context.Context, db SQLHandle, inputs ...*PopRow) (err error) {
	rows := PopRows(inputs)
	numRows, err := queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlSaveReturningPopRows, rows)
	if err != nil {
		return formatError("SaveReturning", err)
	}
	if len(rows) != numRows {
		return formatError("SaveReturning", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// GetPopRowsByNameYear gets matching rows for given NameYear keys from table "pop"
func GetPopRowsByNameYear(ctx context.Context, db SQLHandle, keys ...PopNameYear) (rows PopRows, err error) {
	rows = make(PopRows, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlGetPopRowsByNameYear, keys); err != nil {
		return nil, formatError("GetPopRowsByNameYear", err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].KeyNameYear() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// DeletePopRowsByNameYear deletes matching rows by PopNameYear keys from table "pop"
func DeletePopRowsByNameYear(ctx context.Context, db SQLHandle, keys ...PopNameYear) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlDeletePopRowsByNameYear, keys)
	if err != nil {
		return numRows, formatError("DeleteByNameYear", err)
	}
	return numRows, nil
}

// UpdatePopRowsByNameYear deletes matching rows by PopNameYear keys from table "pop"
func UpdatePopRowsByNameYear(ctx context.Context, db SQLHandle, changeset PopValues, keys ...PopNameYear) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlUpdatePopRowsByNameYear, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateByNameYear", err)
	}
	return numRows, nil
}

func (r *PopRow) ReceiveRow() []interface{} {
	return []interface{}{&r.v.Name, &r.v.Year, &r.v.Description}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PopRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PopRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PopRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PopRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.v)
}

func (keyset PopNameYearKeyset) Keys() (keys []PopNameYear) {
	for k := range keyset {
		keys = append(keys, k)
	}
	return keys
}

func (keyset PopNameYearKeyset) Add(keys ...PopNameYear) {
	for _, k := range keys {
		keyset[k] = struct{}{}
	}
}

func (keyset PopNameYearKeyset) Remove(keys ...PopNameYear) {
	for _, k := range keys {
		delete(keyset, k)
	}
}

var (
	sqlFindPopRows = `
		WITH __f AS (SELECT "name", "year", "description" FROM json_populate_record(null::"wise"."pop", $1))
		SELECT __t.name, __t.year, __t.description
		FROM "wise"."pop" AS __t
		WHERE ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."year" IS NULL FROM __f) OR (SELECT __f."year" = __t."year" FROM __f))
			AND ((SELECT __f."description" IS NULL FROM __f) OR (SELECT __f."description" = __t."description" FROM __f))`
	sqlCountPopRows = `
		WITH __f AS (SELECT "name", "year", "description" FROM json_populate_record(null::"wise"."pop", $1))
		SELECT count(*) FROM "wise"."pop" AS __t
		WHERE ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."year" IS NULL FROM __f) OR (SELECT __f."year" = __t."year" FROM __f))
			AND ((SELECT __f."description" IS NULL FROM __f) OR (SELECT __f."description" = __t."description" FROM __f))`
	sqlReturningPopRows = `
		RETURNING "name", "year", "description"`
	sqlInsertPopRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."pop", $1))
		INSERT INTO "wise"."pop" AS __t ("name", "year", "description")
		SELECT 
			__v."name", 
			__v."year", 
			__v."description" FROM __v`
	sqlInsertReturningPopRows = sqlInsertPopRows + sqlReturningPopRows
	sqlDeletePopRows          = `
		DELETE FROM "wise"."pop" AS __t
		WHERE TRUE
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS text) = __t."name")
			AND (($1::json->>'year' IS NULL) OR CAST($1::json->>'year' AS integer) = __t."year")
			AND (($1::json->>'description' IS NULL) OR CAST($1::json->>'description' AS text) = __t."description")`
	sqlDeleteReturningPopRows = sqlDeletePopRows + sqlReturningPopRows
	sqlUpdatePopRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."pop", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."pop", $2))
		UPDATE "wise"."pop" AS __t
		SET ("name", "year", "description") = (SELECT 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."year", __t."year"), 
			COALESCE(__v."description", __t."description") FROM __v)
		WHERE ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."year" IS NULL FROM __f) OR (SELECT __f."year" = __t."year" FROM __f))
			AND ((SELECT __f."description" IS NULL FROM __f) OR (SELECT __f."description" = __t."description" FROM __f))`
	sqlUpdateReturningPopRows = sqlUpdatePopRows + sqlReturningPopRows
	sqlReplacePopRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."pop", $1))
		UPDATE "wise"."pop" AS __t
			SET ("name", "year", "description") = (SELECT 
				COALESCE(__v."name", __t."name"), 
				COALESCE(__v."year", __t."year"), 
				COALESCE(__v."description", __t."description")
			FROM __v WHERE __v."name" = __t."name" AND __v."year" = __t."year")
		FROM __v WHERE __v."name" = __t."name" AND __v."year" = __t."year"`
	sqlReplaceReturningPopRows = sqlReplacePopRows + sqlReturningPopRows
	sqlSavePopRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."pop", $1))
		INSERT INTO "wise"."pop" AS __t ("name", "year", "description")
		SELECT 
			__v."name", 
			__v."year", 
			__v."description" FROM __v
		ON CONFLICT ("name", "year") DO UPDATE
		SET ("name", "year", "description") = (
			SELECT "name", "year", "description" FROM __v
			WHERE __v."name" = __t."name"
				AND __v."year" = __t."year"
		)`
	sqlSaveReturningPopRows = sqlSavePopRows + sqlReturningPopRows
	sqlGetPopRowsByNameYear = `
		WITH __key AS (SELECT ROW_NUMBER() over () __idx, "name", "year" FROM json_populate_recordset(null::"wise"."pop", $1))
		SELECT "name", "year", "description"
		FROM __key JOIN "wise"."pop" AS __t USING ("name", "year")
		ORDER BY __idx`
	sqlUpdatePopRowsByNameYear = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."pop", $1)),
		  __key AS (SELECT name, year FROM json_populate_recordset(null::"wise"."pop", $2))
		UPDATE "wise"."pop" AS __t
		SET ("name", "year", "description") = (SELECT
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."year", __t."year"), 
			COALESCE(__v."description", __t."description")
		FROM __v)
		FROM __key WHERE (__key."name" = __t."name")AND (__key."year" = __t."year")`
	sqlDeletePopRowsByNameYear = `
		WITH __key AS (SELECT name, year FROM json_populate_recordset(null::"wise"."pop", $1))
		DELETE FROM "wise"."pop" AS __t USING __key WHERE (__key."name" = __t."name") AND (__key."year" = __t."year")`
	sqlDeleteReturningPopRowsByNameYear = sqlDeletePopRowsByNameYear + sqlReturningPopRows
)
