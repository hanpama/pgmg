// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package tables

import (
	"context"
	"encoding/json"
)

// PopRow represents a row for table "pop"
type PopRow struct {
	Data PopData
}

type PopData struct {
	Name        string `json:"name"`
	Year        int32  `json:"year"`
	Description string `json:"description"`
}

func NewPopRow(data PopData) *PopRow {
	return &PopRow{data}
}

func NewPopRows(data ...PopData) PopRows {
	rows := make(PopRows, len(data))
	for i, d := range data {
		rows[i] = NewPopRow(d)
	}
	return rows
}

// GetName gets value of column "name" from "pop" row
func (r *PopRow) GetName() string { return r.Data.Name }

// SetName sets value of column "name" in "pop" row
func (r *PopRow) SetName(name string) { r.Data.Name = name }

// GetYear gets value of column "year" from "pop" row
func (r *PopRow) GetYear() int32 { return r.Data.Year }

// SetYear sets value of column "year" in "pop" row
func (r *PopRow) SetYear(year int32) { r.Data.Year = year }

// GetDescription gets value of column "description" from "pop" row
func (r *PopRow) GetDescription() string { return r.Data.Description }

// SetDescription sets value of column "description" in "pop" row
func (r *PopRow) SetDescription(description string) { r.Data.Description = description }

// PopNameYear represents key defined by PRIMARY KEY constraint "pop_pkey" for table "pop"
type PopNameYear struct {
	Name string `json:"name"`
	Year int32  `json:"year"`
}

func (r *PopRow) KeyNameYear() *PopNameYear {
	return &PopNameYear{r.GetName(), r.GetYear()}
}

// PopRows represents multiple rows for table "pop"
type PopRows []*PopRow

func (rs PopRows) KeyNameYear() (keys []*PopNameYear) {
	keys = make([]*PopNameYear, len(rs))
	for i, r := range rs {
		keys[i] = r.KeyNameYear()
	}
	return keys
}

// NewPopTable(h SQLHandle) creates new PopTable
func NewPopTable(h SQLHandle) *PopTable {
	return &PopTable{h}
}

// PopTable provides access methods for table "pop"
type PopTable struct {
	h SQLHandle
}

func (t *PopTable) Find(ctx context.Context, filter PopValues) (PopRows, error) {
	return FindPopRows(ctx, t.h, filter)
}

func (t *PopTable) Count(ctx context.Context, filter PopValues) (int, error) {
	return CountPopRows(ctx, t.h, filter)
}

func (t *PopTable) Update(ctx context.Context, changeset, filter PopValues) (int64, error) {
	return UpdatePopRows(ctx, t.h, changeset, filter)
}

func (t *PopTable) Insert(ctx context.Context, rows ...*PopRow) (int, error) {
	return InsertReturningPopRows(ctx, t.h, rows...)
}

func (t *PopTable) Delete(ctx context.Context, filter PopValues) (int64, error) {
	return DeletePopRows(ctx, t.h, filter)
}

func (t *PopTable) Save(ctx context.Context, rows ...*PopRow) error {
	return SaveReturningPopRows(ctx, t.h, rows...)
}

func (t *PopTable) GetByNameYear(ctx context.Context, keys ...*PopNameYear) (map[PopNameYear]*PopRow, error) {
	return GetPopRowsByNameYear(ctx, t.h, keys...)
}

func (t *PopTable) UpdateByNameYear(ctx context.Context, changeset PopValues, keys ...*PopNameYear) (int64, error) {
	return UpdatePopRowsByNameYear(ctx, t.h, changeset, keys...)
}

func (t *PopTable) DeleteByNameYear(ctx context.Context, keys ...*PopNameYear) (int64, error) {
	return DeletePopRowsByNameYear(ctx, t.h, keys...)
}

type PopValues struct {
	Name        *string `json:"name"`
	Year        *int32  `json:"year"`
	Description *string `json:"description"`
}

// InsertPopRows inserts the rows into table "pop"
func InsertPopRows(ctx context.Context, db SQLHandle, rows ...*PopRow) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLInsertPopRows, rows)
	if err != nil {
		return numRows, formatError("InsertPopRows", err)
	}
	return numRows, nil
}

// InsertReturningPopRows inserts the rows into table "pop" and returns the rows.
func InsertReturningPopRows(ctx context.Context, db SQLHandle, inputs ...*PopRow) (numRows int, err error) {
	rows := PopRows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturningPopRows, rows)
	if err != nil {
		return numRows, formatError("InsertReturningPopRows", err)
	}
	return numRows, nil
}

// FindPopRows finds the rows matching the condition from table "pop"
func FindPopRows(ctx context.Context, db SQLHandle, cond PopValues) (rows PopRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFindPopRows, cond); err != nil {
		return nil, formatError("FindPopRows", err)
	}
	return rows, nil
}

// DeletePopRows deletes the rows matching the condition from table "pop"
func DeletePopRows(ctx context.Context, db SQLHandle, cond PopValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDeletePopRows, cond); err != nil {
		return numRows, formatError("DeletePopRows", err)
	}
	return numRows, nil
}

func UpdatePopRows(ctx context.Context, db SQLHandle, changeset, filter PopValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdatePopRows, changeset, filter); err != nil {
		return numRows, formatError("UpdatePopRows", err)
	}
	return numRows, nil
}

// CountPopRows counts the number of rows matching the condition from table "pop"
func CountPopRows(ctx context.Context, db SQLHandle, cond PopValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, SQLCountPopRows, cond); err != nil {
		return 0, formatError("CountPopRows", err)
	}
	return count, nil
}

// SavePopRows upserts the given rows for table "pop" checking uniqueness by contstraint "pop_pkey"
func SavePopRows(ctx context.Context, db SQLHandle, rows ...*PopRow) (err error) {
	_, err = execWithJSONArgs(ctx, db, SQLSavePopRows, rows)
	if err != nil {
		return formatError("SavePopRows", err)
	}
	return nil
}

// SaveReturningPopRows upserts the given rows for table "pop" checking uniqueness by contstraint "pop_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningPopRows(ctx context.Context, db SQLHandle, inputs ...*PopRow) (err error) {
	rows := PopRows(inputs)
	_, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLSaveReturningPopRows, rows)
	if err != nil {
		return formatError("SaveReturningPopRows", err)
	}
	return nil
}

// GetPopRowsByNameYear gets matching rows for given NameYear keys from table "pop"
func GetPopRowsByNameYear(ctx context.Context, db SQLHandle, keys ...*PopNameYear) (rs map[PopNameYear]*PopRow, err error) {
	ukm := make(map[PopNameYear]struct{}, len(keys))
	for _, k := range keys {
		if k != nil {
			ukm[*k] = struct{}{}
		}
	}
	uks := make([]PopNameYear, len(ukm))
	i := 0
	for k := range ukm {
		uks[i] = k
		i++
	}

	var r PopRow
	rs = make(map[PopNameYear]*PopRow, len(uks))
	if _, err = queryWithJSONArgs(ctx, db, func(i int) []interface{} {
		if i > 0 {
			r := r
			rs[*r.KeyNameYear()] = &r
		}
		return r.ReceiveRow()
	}, SQLGetPopRowsByNameYear, uks); err != nil {
		return nil, formatError("GetPopRowsByNameYear", err)
	}
	rs[*r.KeyNameYear()] = &r
	return rs, nil
}

// DeletePopRowsByNameYear deletes matching rows by PopNameYear keys from table "pop"
func DeletePopRowsByNameYear(ctx context.Context, db SQLHandle, keys ...*PopNameYear) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLDeletePopRowsByNameYear, keys)
	if err != nil {
		return numRows, formatError("DeletePopRowsByNameYear", err)
	}
	return numRows, nil
}

// UpdatePopRowsByNameYear deletes matching rows by PopNameYear keys from table "pop"
func UpdatePopRowsByNameYear(ctx context.Context, db SQLHandle, changeset PopValues, keys ...*PopNameYear) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLUpdatePopRowsByNameYear, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdatePopRowsByNameYear", err)
	}
	return numRows, nil
}

func (r *PopRow) ReceiveRow() []interface{} {
	return []interface{}{&r.Data.Name, &r.Data.Year, &r.Data.Description}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PopRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PopRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PopRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PopRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Data)
}

var (
	SQLFindPopRows = `
		WITH __f AS (SELECT "name", "year", "description" FROM json_populate_record(null::"wise"."pop", $1))
		SELECT __t.name, __t.year, __t.description
		FROM "wise"."pop" AS __t
		WHERE ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."year" IS NULL FROM __f) OR (SELECT __f."year" = __t."year" FROM __f))
			AND ((SELECT __f."description" IS NULL FROM __f) OR (SELECT __f."description" = __t."description" FROM __f))`
	SQLCountPopRows = `
		WITH __f AS (SELECT "name", "year", "description" FROM json_populate_record(null::"wise"."pop", $1))
		SELECT count(*) FROM "wise"."pop" AS __t
		WHERE ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."year" IS NULL FROM __f) OR (SELECT __f."year" = __t."year" FROM __f))
			AND ((SELECT __f."description" IS NULL FROM __f) OR (SELECT __f."description" = __t."description" FROM __f))`
	SQLReturningPopRows = `
		RETURNING "name", "year", "description"`
	SQLInsertPopRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."pop", $1))
		INSERT INTO "wise"."pop" AS __t ("name", "year", "description")
		SELECT 
			__v."name", 
			__v."year", 
			__v."description" FROM __v`
	SQLInsertReturningPopRows = SQLInsertPopRows + SQLReturningPopRows
	SQLDeletePopRows          = `
		DELETE FROM "wise"."pop" AS __t
		WHERE TRUE
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS text) = __t."name")
			AND (($1::json->>'year' IS NULL) OR CAST($1::json->>'year' AS integer) = __t."year")
			AND (($1::json->>'description' IS NULL) OR CAST($1::json->>'description' AS text) = __t."description")`
	SQLDeleteReturningPopRows = SQLDeletePopRows + SQLReturningPopRows
	SQLUpdatePopRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."pop", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."pop", $2))
		UPDATE "wise"."pop" AS __t
		SET ("name", "year", "description") = (SELECT 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."year", __t."year"), 
			COALESCE(__v."description", __t."description") FROM __v)
		WHERE ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."year" IS NULL FROM __f) OR (SELECT __f."year" = __t."year" FROM __f))
			AND ((SELECT __f."description" IS NULL FROM __f) OR (SELECT __f."description" = __t."description" FROM __f))`
	SQLUpdateReturningPopRows = SQLUpdatePopRows + SQLReturningPopRows
	SQLReplacePopRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."pop", $1))
		UPDATE "wise"."pop" AS __t
			SET ("name", "year", "description") = (SELECT 
				COALESCE(__v."name", __t."name"), 
				COALESCE(__v."year", __t."year"), 
				COALESCE(__v."description", __t."description")
			FROM __v WHERE __v."name" = __t."name" AND __v."year" = __t."year")
		FROM __v WHERE __v."name" = __t."name" AND __v."year" = __t."year"`
	SQLReplaceReturningPopRows = SQLReplacePopRows + SQLReturningPopRows
	SQLSavePopRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."pop", $1))
		INSERT INTO "wise"."pop" AS __t ("name", "year", "description")
		SELECT 
			__v."name", 
			__v."year", 
			__v."description" FROM __v
		ON CONFLICT ("name", "year") DO UPDATE
		SET ("name", "year", "description") = (
			SELECT "name", "year", "description" FROM __v
			WHERE __v."name" = __t."name"
				AND __v."year" = __t."year"
		)`
	SQLSaveReturningPopRows = SQLSavePopRows + SQLReturningPopRows
	SQLGetPopRowsByNameYear = `
		WITH __key AS (SELECT DISTINCT "name", "year" FROM json_populate_recordset(null::"wise"."pop", $1))
		SELECT "name", "year", "description"
		FROM __key JOIN "wise"."pop" AS __t USING ("name", "year")
		`
	SQLUpdatePopRowsByNameYear = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."pop", $1)),
		  __key AS (SELECT name, year FROM json_populate_recordset(null::"wise"."pop", $2))
		UPDATE "wise"."pop" AS __t
		SET ("name", "year", "description") = (SELECT
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."year", __t."year"), 
			COALESCE(__v."description", __t."description")
		FROM __v)
		FROM __key WHERE (__key."name" = __t."name")AND (__key."year" = __t."year")`
	SQLDeletePopRowsByNameYear = `
		WITH __key AS (SELECT name, year FROM json_populate_recordset(null::"wise"."pop", $1))
		DELETE FROM "wise"."pop" AS __t USING __key WHERE (__key."name" = __t."name") AND (__key."year" = __t."year")`
	SQLDeleteReturningPopRowsByNameYear = SQLDeletePopRowsByNameYear + SQLReturningPopRows
)
