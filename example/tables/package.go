// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package tables

import (
	"context"
	"encoding/json"
)

// PackageRow represents a row for table "package"
type PackageRow struct {
	Data PackageData
}

type PackageData struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Available *bool  `json:"available"`
}

func NewPackageRow(data PackageData) *PackageRow {
	return &PackageRow{data}
}

func NewPackageRows(data ...PackageData) PackageRows {
	rows := make(PackageRows, len(data))
	for i, d := range data {
		rows[i] = NewPackageRow(d)
	}
	return rows
}

// GetID gets value of column "id" from "package" row
func (r *PackageRow) GetID() string { return r.Data.ID }

// SetID sets value of column "id" in "package" row
func (r *PackageRow) SetID(id string) { r.Data.ID = id }

// GetName gets value of column "name" from "package" row
func (r *PackageRow) GetName() string { return r.Data.Name }

// SetName sets value of column "name" in "package" row
func (r *PackageRow) SetName(name string) { r.Data.Name = name }

// GetAvailable gets value of column "available" from "package" row
func (r *PackageRow) GetAvailable() bool { return *r.Data.Available }

// SetAvailable sets value of column "available" in "package" row
func (r *PackageRow) SetAvailable(available bool) { r.Data.Available = &available }

// ClearAvailable sets value of column "available" null in "package" row
func (r *PackageRow) ClearAvailable() { r.Data.Available = nil }

// HasValidAvailable checks to value of column "available" is not null
func (r *PackageRow) HasValidAvailable() bool { return r.Data.Available != nil }

// PackageID represents key defined by PRIMARY KEY constraint "package_pkey" for table "package"
type PackageID struct {
	ID string `json:"id"`
}

func (r *PackageRow) KeyID() *PackageID {
	return &PackageID{r.GetID()}
}

// PackageRows represents multiple rows for table "package"
type PackageRows []*PackageRow

func (rs PackageRows) KeyID() (keys []*PackageID) {
	keys = make([]*PackageID, len(rs))
	for i, r := range rs {
		keys[i] = r.KeyID()
	}
	return keys
}

// NewPackageTable(h SQLHandle) creates new PackageTable
func NewPackageTable(h SQLHandle) *PackageTable {
	return &PackageTable{h}
}

// PackageTable provides access methods for table "package"
type PackageTable struct {
	h SQLHandle
}

func (t *PackageTable) Find(ctx context.Context, filter PackageValues) (PackageRows, error) {
	return FindPackageRows(ctx, t.h, filter)
}

func (t *PackageTable) Count(ctx context.Context, filter PackageValues) (int, error) {
	return CountPackageRows(ctx, t.h, filter)
}

func (t *PackageTable) Update(ctx context.Context, changeset, filter PackageValues) (int64, error) {
	return UpdatePackageRows(ctx, t.h, changeset, filter)
}

func (t *PackageTable) Insert(ctx context.Context, rows ...*PackageRow) (int, error) {
	return InsertReturningPackageRows(ctx, t.h, rows...)
}

func (t *PackageTable) Delete(ctx context.Context, filter PackageValues) (int64, error) {
	return DeletePackageRows(ctx, t.h, filter)
}

func (t *PackageTable) Save(ctx context.Context, rows ...*PackageRow) error {
	return SaveReturningPackageRows(ctx, t.h, rows...)
}

func (t *PackageTable) GetByID(ctx context.Context, keys ...*PackageID) (map[PackageID]*PackageRow, error) {
	return GetPackageRowsByID(ctx, t.h, keys...)
}

func (t *PackageTable) UpdateByID(ctx context.Context, changeset PackageValues, keys ...*PackageID) (int64, error) {
	return UpdatePackageRowsByID(ctx, t.h, changeset, keys...)
}

func (t *PackageTable) DeleteByID(ctx context.Context, keys ...*PackageID) (int64, error) {
	return DeletePackageRowsByID(ctx, t.h, keys...)
}

type PackageValues struct {
	ID        *string `json:"id"`
	Name      *string `json:"name"`
	Available *bool   `json:"available"`
}

// InsertPackageRows inserts the rows into table "package"
func InsertPackageRows(ctx context.Context, db SQLHandle, rows ...*PackageRow) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLInsertPackageRows, rows)
	if err != nil {
		return numRows, formatError("InsertPackageRows", err)
	}
	return numRows, nil
}

// InsertReturningPackageRows inserts the rows into table "package" and returns the rows.
func InsertReturningPackageRows(ctx context.Context, db SQLHandle, inputs ...*PackageRow) (numRows int, err error) {
	rows := PackageRows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturningPackageRows, rows)
	if err != nil {
		return numRows, formatError("InsertReturningPackageRows", err)
	}
	return numRows, nil
}

// FindPackageRows finds the rows matching the condition from table "package"
func FindPackageRows(ctx context.Context, db SQLHandle, cond PackageValues) (rows PackageRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFindPackageRows, cond); err != nil {
		return nil, formatError("FindPackageRows", err)
	}
	return rows, nil
}

// DeletePackageRows deletes the rows matching the condition from table "package"
func DeletePackageRows(ctx context.Context, db SQLHandle, cond PackageValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDeletePackageRows, cond); err != nil {
		return numRows, formatError("DeletePackageRows", err)
	}
	return numRows, nil
}

func UpdatePackageRows(ctx context.Context, db SQLHandle, changeset, filter PackageValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdatePackageRows, changeset, filter); err != nil {
		return numRows, formatError("UpdatePackageRows", err)
	}
	return numRows, nil
}

// CountPackageRows counts the number of rows matching the condition from table "package"
func CountPackageRows(ctx context.Context, db SQLHandle, cond PackageValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, SQLCountPackageRows, cond); err != nil {
		return 0, formatError("CountPackageRows", err)
	}
	return count, nil
}

// SavePackageRows upserts the given rows for table "package" checking uniqueness by contstraint "package_pkey"
func SavePackageRows(ctx context.Context, db SQLHandle, rows ...*PackageRow) (err error) {
	_, err = execWithJSONArgs(ctx, db, SQLSavePackageRows, rows)
	if err != nil {
		return formatError("SavePackageRows", err)
	}
	return nil
}

// SaveReturningPackageRows upserts the given rows for table "package" checking uniqueness by contstraint "package_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningPackageRows(ctx context.Context, db SQLHandle, inputs ...*PackageRow) (err error) {
	rows := PackageRows(inputs)
	_, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLSaveReturningPackageRows, rows)
	if err != nil {
		return formatError("SaveReturningPackageRows", err)
	}
	return nil
}

// GetPackageRowsByID gets matching rows for given ID keys from table "package"
func GetPackageRowsByID(ctx context.Context, db SQLHandle, keys ...*PackageID) (rs map[PackageID]*PackageRow, err error) {
	ukm := make(map[PackageID]struct{}, len(keys))
	for _, k := range keys {
		if k != nil {
			ukm[*k] = struct{}{}
		}
	}
	uks := make([]PackageID, len(ukm))
	i := 0
	for k := range ukm {
		uks[i] = k
		i++
	}

	var r PackageRow
	rs = make(map[PackageID]*PackageRow, len(uks))
	if _, err = queryWithJSONArgs(ctx, db, func(i int) []interface{} {
		if i > 0 {
			r := r
			rs[*r.KeyID()] = &r
		}
		return r.ReceiveRow()
	}, SQLGetPackageRowsByID, uks); err != nil {
		return nil, formatError("GetPackageRowsByID", err)
	}
	rs[*r.KeyID()] = &r
	return rs, nil
}

// DeletePackageRowsByID deletes matching rows by PackageID keys from table "package"
func DeletePackageRowsByID(ctx context.Context, db SQLHandle, keys ...*PackageID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLDeletePackageRowsByID, keys)
	if err != nil {
		return numRows, formatError("DeletePackageRowsByID", err)
	}
	return numRows, nil
}

// UpdatePackageRowsByID deletes matching rows by PackageID keys from table "package"
func UpdatePackageRowsByID(ctx context.Context, db SQLHandle, changeset PackageValues, keys ...*PackageID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLUpdatePackageRowsByID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdatePackageRowsByID", err)
	}
	return numRows, nil
}

func (r *PackageRow) ReceiveRow() []interface{} {
	return []interface{}{&r.Data.ID, &r.Data.Name, &r.Data.Available}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PackageRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PackageRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PackageRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PackageRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Data)
}

var (
	SQLFindPackageRows = `
		WITH __f AS (SELECT "id", "name", "available" FROM json_populate_record(null::"wise"."package", $1))
		SELECT __t.id, __t.name, __t.available
		FROM "wise"."package" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))`
	SQLCountPackageRows = `
		WITH __f AS (SELECT "id", "name", "available" FROM json_populate_record(null::"wise"."package", $1))
		SELECT count(*) FROM "wise"."package" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))`
	SQLReturningPackageRows = `
		RETURNING "id", "name", "available"`
	SQLInsertPackageRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package", $1))
		INSERT INTO "wise"."package" AS __t ("id", "name", "available")
		SELECT 
			__v."id", 
			__v."name", 
			COALESCE(__v."available", true) FROM __v`
	SQLInsertReturningPackageRows = SQLInsertPackageRows + SQLReturningPackageRows
	SQLDeletePackageRows          = `
		DELETE FROM "wise"."package" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS uuid) = __t."id")
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS text) = __t."name")
			AND (($1::json->>'available' IS NULL) OR CAST($1::json->>'available' AS boolean) = __t."available")`
	SQLDeleteReturningPackageRows = SQLDeletePackageRows + SQLReturningPackageRows
	SQLUpdatePackageRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."package", $2))
		UPDATE "wise"."package" AS __t
		SET ("id", "name", "available") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."available", __t."available") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))`
	SQLUpdateReturningPackageRows = SQLUpdatePackageRows + SQLReturningPackageRows
	SQLReplacePackageRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package", $1))
		UPDATE "wise"."package" AS __t
			SET ("id", "name", "available") = (SELECT 
				COALESCE(__v."id", __t."id"), 
				COALESCE(__v."name", __t."name"), 
				COALESCE(__v."available", __t."available")
			FROM __v WHERE __v."id" = __t."id")
		FROM __v WHERE __v."id" = __t."id"`
	SQLReplaceReturningPackageRows = SQLReplacePackageRows + SQLReturningPackageRows
	SQLSavePackageRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package", $1))
		INSERT INTO "wise"."package" AS __t ("id", "name", "available")
		SELECT 
			__v."id", 
			__v."name", 
			COALESCE(__v."available", true) FROM __v
		ON CONFLICT ("id") DO UPDATE
		SET ("id", "name", "available") = (
			SELECT "id", "name", "available" FROM __v
			WHERE __v."id" = __t."id"
		)`
	SQLSaveReturningPackageRows = SQLSavePackageRows + SQLReturningPackageRows
	SQLGetPackageRowsByID       = `
		WITH __key AS (SELECT DISTINCT "id" FROM json_populate_recordset(null::"wise"."package", $1))
		SELECT "id", "name", "available"
		FROM __key JOIN "wise"."package" AS __t USING ("id")
		`
	SQLUpdatePackageRowsByID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package", $1)),
		  __key AS (SELECT id FROM json_populate_recordset(null::"wise"."package", $2))
		UPDATE "wise"."package" AS __t
		SET ("id", "name", "available") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."available", __t."available")
		FROM __v)
		FROM __key WHERE (__key."id" = __t."id")`
	SQLDeletePackageRowsByID = `
		WITH __key AS (SELECT id FROM json_populate_recordset(null::"wise"."package", $1))
		DELETE FROM "wise"."package" AS __t USING __key WHERE (__key."id" = __t."id")`
	SQLDeleteReturningPackageRowsByID = SQLDeletePackageRowsByID + SQLReturningPackageRows
)
