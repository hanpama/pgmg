// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package tables

import (
	"context"
	"encoding/json"
)

// PackageRow represents a row for table "package"
type PackageRow struct {
	v PackageData
}

type PackageData struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Available *bool  `json:"available"`
}

func NewPackageRow(data PackageData) *PackageRow {
	return &PackageRow{data}
}

func NewPackageRows(data ...PackageData) PackageRows {
	rows := make(PackageRows, len(data))
	for i, d := range data {
		rows[i] = NewPackageRow(d)
	}
	return rows
}

// GetID gets value of column "id" from "package" row
func (r *PackageRow) GetID() string { return r.v.ID }

// SetID sets value of column "id" in "package" row
func (r *PackageRow) SetID(id string) { r.v.ID = id }

// GetName gets value of column "name" from "package" row
func (r *PackageRow) GetName() string { return r.v.Name }

// SetName sets value of column "name" in "package" row
func (r *PackageRow) SetName(name string) { r.v.Name = name }

// GetAvailable gets value of column "available" from "package" row
func (r *PackageRow) GetAvailable() bool { return *r.v.Available }

// SetAvailable sets value of column "available" in "package" row
func (r *PackageRow) SetAvailable(available bool) { r.v.Available = &available }

// ClearAvailable sets value of column "available" null in "package" row
func (r *PackageRow) ClearAvailable() { r.v.Available = nil }

// HasValidAvailable checks to value of column "available" is not null
func (r *PackageRow) HasValidAvailable() bool { return r.v.Available != nil }

// PackageID represents key defined by PRIMARY KEY constraint "package_pkey" for table "package"
type PackageID struct {
	ID string `json:"id"`
}

func (r *PackageRow) KeyID() PackageID {
	return PackageID{r.GetID()}
}

// PackageRows represents multiple rows for table "package"
type PackageRows []*PackageRow

// PackageIDKeyset is a set of key PackageID
type PackageIDKeyset map[PackageID]struct{}

func (rs PackageRows) KeyID() (keys PackageIDKeyset) {
	keys = make(PackageIDKeyset)
	for _, r := range rs {
		keys[r.KeyID()] = struct{}{}
	}
	return keys
}

// NewPackageTable(h SQLHandle) creates new PackageTable
func NewPackageTable(h SQLHandle) *PackageTable {
	return &PackageTable{h}
}

// PackageTable provides access methods for table "package"
type PackageTable struct {
	h SQLHandle
}

func (t *PackageTable) Find(ctx context.Context, filter PackageValues) (PackageRows, error) {
	return FindPackageRows(ctx, t.h, filter)
}

func (t *PackageTable) Count(ctx context.Context, filter PackageValues) (int, error) {
	return CountPackageRows(ctx, t.h, filter)
}

func (t *PackageTable) Update(ctx context.Context, changeset, filter PackageValues) (int64, error) {
	return UpdatePackageRows(ctx, t.h, changeset, filter)
}

func (t *PackageTable) Insert(ctx context.Context, rows ...*PackageRow) (int, error) {
	return InsertReturningPackageRows(ctx, t.h, rows...)
}

func (t *PackageTable) Delete(ctx context.Context, filter PackageValues) (int64, error) {
	return DeletePackageRows(ctx, t.h, filter)
}

func (t *PackageTable) Save(ctx context.Context, rows ...*PackageRow) error {
	return SaveReturningPackageRows(ctx, t.h, rows...)
}

func (t *PackageTable) GetByID(ctx context.Context, keys ...PackageID) (PackageRows, error) {
	return GetPackageRowsByID(ctx, t.h, keys...)
}

func (t *PackageTable) UpdateByID(ctx context.Context, changeset PackageValues, keys ...PackageID) (int64, error) {
	return UpdatePackageRowsByID(ctx, t.h, changeset, keys...)
}

func (t *PackageTable) DeleteByID(ctx context.Context, keys ...PackageID) (int64, error) {
	return DeletePackageRowsByID(ctx, t.h, keys...)
}

type PackageValues struct {
	ID        *string `json:"id"`
	Name      *string `json:"name"`
	Available *bool   `json:"available"`
}

// InsertPackageRows inserts the rows into table "package"
func InsertPackageRows(ctx context.Context, db SQLHandle, rows ...*PackageRow) (affected int64, err error) {
	affected, err = execWithJSONArgs(ctx, db, sqlInsertPackageRows, rows)
	if err != nil {
		return affected, formatError("InsertPackageRows", err)
	}
	return affected, nil
}

// InsertReturningPackageRows inserts the rows into table "package" and returns the rows.
func InsertReturningPackageRows(ctx context.Context, db SQLHandle, inputs ...*PackageRow) (affected int, err error) {
	rows := PackageRows(inputs)
	affected, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlInsertReturningPackageRows, rows)
	if err != nil {
		return affected, formatError("InsertReturningPackageRows", err)
	}
	return affected, nil
}

// FindPackageRows finds the rows matching the condition from table "package"
func FindPackageRows(ctx context.Context, db SQLHandle, cond PackageValues) (rows PackageRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlFindPackageRows, cond); err != nil {
		return nil, err
	}
	return rows, nil
}

// DeletePackageRows deletes the rows matching the condition from table "package"
func DeletePackageRows(ctx context.Context, db SQLHandle, cond PackageValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlDeletePackageRows, cond)
}

func UpdatePackageRows(ctx context.Context, db SQLHandle, changeset, filter PackageValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlUpdatePackageRows, changeset, filter)
}

// CountPackageRows counts the number of rows matching the condition from table "package"
func CountPackageRows(ctx context.Context, db SQLHandle, cond PackageValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, sqlCountPackageRows, cond); err != nil {
		return 0, err
	}
	return count, nil
}

// SavePackageRows upserts the given rows for table "package" checking uniqueness by contstraint "package_pkey"
func SavePackageRows(ctx context.Context, db SQLHandle, rows ...*PackageRow) (err error) {
	numRows, err := execWithJSONArgs(ctx, db, sqlSavePackageRows, rows)
	if err != nil {
		return formatError("Save", err)
	}
	if int64(len(rows)) != numRows {
		return formatError("Save", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// SaveReturningPackageRows upserts the given rows for table "package" checking uniqueness by contstraint "package_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningPackageRows(ctx context.Context, db SQLHandle, inputs ...*PackageRow) (err error) {
	rows := PackageRows(inputs)
	numRows, err := queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlSaveReturningPackageRows, rows)
	if err != nil {
		return formatError("SaveReturning", err)
	}
	if len(rows) != numRows {
		return formatError("SaveReturning", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// GetPackageRowsByID gets matching rows for given ID keys from table "package"
func GetPackageRowsByID(ctx context.Context, db SQLHandle, keys ...PackageID) (rows PackageRows, err error) {
	rows = make(PackageRows, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlGetPackageRowsByID, keys); err != nil {
		return nil, formatError("GetPackageRowsByID", err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].KeyID() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// DeletePackageRowsByID deletes matching rows by PackageID keys from table "package"
func DeletePackageRowsByID(ctx context.Context, db SQLHandle, keys ...PackageID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlDeletePackageRowsByID, keys)
	if err != nil {
		return numRows, formatError("DeleteByID", err)
	}
	return numRows, nil
}

// UpdatePackageRowsByID deletes matching rows by PackageID keys from table "package"
func UpdatePackageRowsByID(ctx context.Context, db SQLHandle, changeset PackageValues, keys ...PackageID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlUpdatePackageRowsByID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateByID", err)
	}
	return numRows, nil
}

func (r *PackageRow) ReceiveRow() []interface{} {
	return []interface{}{&r.v.ID, &r.v.Name, &r.v.Available}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PackageRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PackageRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PackageRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PackageRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.v)
}

func (keyset PackageIDKeyset) Keys() (keys []PackageID) {
	for k := range keyset {
		keys = append(keys, k)
	}
	return keys
}

func (keyset PackageIDKeyset) Add(keys ...PackageID) {
	for _, k := range keys {
		keyset[k] = struct{}{}
	}
}

func (keyset PackageIDKeyset) Remove(keys ...PackageID) {
	for _, k := range keys {
		delete(keyset, k)
	}
}

var (
	sqlFindPackageRows = `
		WITH __f AS (SELECT "id", "name", "available" FROM json_populate_record(null::"wise"."package", $1))
		SELECT __t.id, __t.name, __t.available
		FROM "wise"."package" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))`
	sqlCountPackageRows = `
		WITH __f AS (SELECT "id", "name", "available" FROM json_populate_record(null::"wise"."package", $1))
		SELECT count(*) FROM "wise"."package" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))`
	sqlReturningPackageRows = `
		RETURNING "id", "name", "available"`
	sqlInsertPackageRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package", $1))
		INSERT INTO "wise"."package" AS __t ("id", "name", "available")
		SELECT 
			__v."id", 
			__v."name", 
			COALESCE(__v."available", true) FROM __v`
	sqlInsertReturningPackageRows = sqlInsertPackageRows + sqlReturningPackageRows
	sqlDeletePackageRows          = `
		DELETE FROM "wise"."package" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS uuid) = __t."id")
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS text) = __t."name")
			AND (($1::json->>'available' IS NULL) OR CAST($1::json->>'available' AS boolean) = __t."available")`
	sqlDeleteReturningPackageRows = sqlDeletePackageRows + sqlReturningPackageRows
	sqlUpdatePackageRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."package", $2))
		UPDATE "wise"."package" AS __t
		SET ("id", "name", "available") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."available", __t."available") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))`
	sqlUpdateReturningPackageRows = sqlUpdatePackageRows + sqlReturningPackageRows
	sqlReplacePackageRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package", $1))
		UPDATE "wise"."package" AS __t
			SET ("id", "name", "available") = (SELECT 
				COALESCE(__v."id", __t."id"), 
				COALESCE(__v."name", __t."name"), 
				COALESCE(__v."available", __t."available")
			FROM __v WHERE __v."id" = __t."id")
		FROM __v WHERE __v."id" = __t."id"`
	sqlReplaceReturningPackageRows = sqlReplacePackageRows + sqlReturningPackageRows
	sqlSavePackageRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package", $1))
		INSERT INTO "wise"."package" AS __t ("id", "name", "available")
		SELECT 
			__v."id", 
			__v."name", 
			COALESCE(__v."available", true) FROM __v
		ON CONFLICT ("id") DO UPDATE
		SET ("id", "name", "available") = (
			SELECT "id", "name", "available" FROM __v
			WHERE __v."id" = __t."id"
		)`
	sqlSaveReturningPackageRows = sqlSavePackageRows + sqlReturningPackageRows
	sqlGetPackageRowsByID       = `
		WITH __key AS (SELECT ROW_NUMBER() over () __idx, "id" FROM json_populate_recordset(null::"wise"."package", $1))
		SELECT "id", "name", "available"
		FROM __key JOIN "wise"."package" AS __t USING ("id")
		ORDER BY __idx`
	sqlUpdatePackageRowsByID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package", $1)),
		  __key AS (SELECT id FROM json_populate_recordset(null::"wise"."package", $2))
		UPDATE "wise"."package" AS __t
		SET ("id", "name", "available") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."available", __t."available")
		FROM __v)
		FROM __key WHERE (__key."id" = __t."id")`
	sqlDeletePackageRowsByID = `
		WITH __key AS (SELECT id FROM json_populate_recordset(null::"wise"."package", $1))
		DELETE FROM "wise"."package" AS __t USING __key WHERE (__key."id" = __t."id")`
	sqlDeleteReturningPackageRowsByID = sqlDeletePackageRowsByID + sqlReturningPackageRows
)
