// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package schema

import (
	"context"
	"encoding/json"
	"fmt"
	"time"
)

// PackageRow represents a row for table "package"
type PackageRow struct {
	Data PackageData
}

type PackageData struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Available *bool  `json:"available"`
}

func NewPackageRow(data PackageData) *PackageRow {
	return &PackageRow{data}
}

func NewPackageRows(data ...PackageData) PackageRows {
	rows := make(PackageRows, len(data))
	for i, d := range data {
		rows[i] = NewPackageRow(d)
	}
	return rows
}

// GetID gets value of column "id" from "package" row
func (r *PackageRow) GetID() string { return r.Data.ID }

// SetID sets value of column "id" in "package" row
func (r *PackageRow) SetID(id string) { r.Data.ID = id }

// GetName gets value of column "name" from "package" row
func (r *PackageRow) GetName() string { return r.Data.Name }

// SetName sets value of column "name" in "package" row
func (r *PackageRow) SetName(name string) { r.Data.Name = name }

// GetAvailable gets value of column "available" from "package" row
func (r *PackageRow) GetAvailable() bool { return *r.Data.Available }

// SetAvailable sets value of column "available" in "package" row
func (r *PackageRow) SetAvailable(available bool) { r.Data.Available = &available }

// ClearAvailable sets value of column "available" null in "package" row
func (r *PackageRow) ClearAvailable() { r.Data.Available = nil }

// HasValidAvailable checks to value of column "available" is not null
func (r *PackageRow) HasValidAvailable() bool { return r.Data.Available != nil }

// PackageID represents key defined by PRIMARY KEY constraint "package_pkey" for table "package"
type PackageID struct {
	ID string `json:"id"`
}

func (r *PackageRow) KeyID() *PackageID {
	return &PackageID{r.GetID()}
}

// PackageRows represents multiple rows for table "package"
type PackageRows []*PackageRow

func (rs PackageRows) KeyID() (keys []*PackageID) {
	keys = make([]*PackageID, len(rs))
	for i, r := range rs {
		keys[i] = r.KeyID()
	}
	return keys
}

// NewPackageTable(h SQLHandle) creates new PackageTable
func NewPackageTable(h SQLHandle) *PackageTable {
	return &PackageTable{h}
}

// PackageTable provides access methods for table "package"
type PackageTable struct {
	h SQLHandle
}

func (t *PackageTable) Find(ctx context.Context, filter PackageValues) (PackageRows, error) {
	return FindPackageRows(ctx, t.h, filter)
}

func (t *PackageTable) Count(ctx context.Context, filter PackageValues) (int, error) {
	return CountPackageRows(ctx, t.h, filter)
}

func (t *PackageTable) Update(ctx context.Context, changeset, filter PackageValues) (int64, error) {
	return UpdatePackageRows(ctx, t.h, changeset, filter)
}

func (t *PackageTable) Insert(ctx context.Context, rows ...*PackageRow) (int, error) {
	return InsertReturningPackageRows(ctx, t.h, rows...)
}

func (t *PackageTable) Delete(ctx context.Context, filter PackageValues) (int64, error) {
	return DeletePackageRows(ctx, t.h, filter)
}

func (t *PackageTable) Save(ctx context.Context, rows ...*PackageRow) error {
	return SaveReturningPackageRows(ctx, t.h, rows...)
}

func (t *PackageTable) GetByID(ctx context.Context, keys ...*PackageID) (map[PackageID]*PackageRow, error) {
	return GetPackageRowsByID(ctx, t.h, keys...)
}

func (t *PackageTable) UpdateByID(ctx context.Context, changeset PackageValues, keys ...*PackageID) (int64, error) {
	return UpdatePackageRowsByID(ctx, t.h, changeset, keys...)
}

func (t *PackageTable) DeleteByID(ctx context.Context, keys ...*PackageID) (int64, error) {
	return DeletePackageRowsByID(ctx, t.h, keys...)
}

type PackageValues struct {
	ID        *string `json:"id"`
	Name      *string `json:"name"`
	Available *bool   `json:"available"`
}

// InsertPackageRows inserts the rows into table "package"
func InsertPackageRows(ctx context.Context, db SQLHandle, rows ...*PackageRow) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLInsertPackageRows, rows)
	if err != nil {
		return numRows, formatError("InsertPackageRows", err)
	}
	return numRows, nil
}

// InsertReturningPackageRows inserts the rows into table "package" and returns the rows.
func InsertReturningPackageRows(ctx context.Context, db SQLHandle, inputs ...*PackageRow) (numRows int, err error) {
	rows := PackageRows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturningPackageRows, rows)
	if err != nil {
		return numRows, formatError("InsertReturningPackageRows", err)
	}
	return numRows, nil
}

// FindPackageRows finds the rows matching the condition from table "package"
func FindPackageRows(ctx context.Context, db SQLHandle, cond PackageValues) (rows PackageRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFindPackageRows, cond); err != nil {
		return nil, formatError("FindPackageRows", err)
	}
	return rows, nil
}

// DeletePackageRows deletes the rows matching the condition from table "package"
func DeletePackageRows(ctx context.Context, db SQLHandle, cond PackageValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDeletePackageRows, cond); err != nil {
		return numRows, formatError("DeletePackageRows", err)
	}
	return numRows, nil
}

func UpdatePackageRows(ctx context.Context, db SQLHandle, changeset, filter PackageValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdatePackageRows, changeset, filter); err != nil {
		return numRows, formatError("UpdatePackageRows", err)
	}
	return numRows, nil
}

// CountPackageRows counts the number of rows matching the condition from table "package"
func CountPackageRows(ctx context.Context, db SQLHandle, cond PackageValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, SQLCountPackageRows, cond); err != nil {
		return 0, formatError("CountPackageRows", err)
	}
	return count, nil
}

// SavePackageRows upserts the given rows for table "package" checking uniqueness by contstraint "package_pkey"
func SavePackageRows(ctx context.Context, db SQLHandle, rows ...*PackageRow) (err error) {
	_, err = execWithJSONArgs(ctx, db, SQLSavePackageRows, rows)
	if err != nil {
		return formatError("SavePackageRows", err)
	}
	return nil
}

// SaveReturningPackageRows upserts the given rows for table "package" checking uniqueness by contstraint "package_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningPackageRows(ctx context.Context, db SQLHandle, inputs ...*PackageRow) (err error) {
	rows := PackageRows(inputs)
	_, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLSaveReturningPackageRows, rows)
	if err != nil {
		return formatError("SaveReturningPackageRows", err)
	}
	return nil
}

// GetPackageRowsByID gets matching rows for given ID keys from table "package"
func GetPackageRowsByID(ctx context.Context, db SQLHandle, keys ...*PackageID) (rs map[PackageID]*PackageRow, err error) {
	ukm := make(map[PackageID]struct{}, len(keys))
	for _, k := range keys {
		if k != nil {
			ukm[*k] = struct{}{}
		}
	}
	uks := make([]PackageID, len(ukm))
	i := 0
	for k := range ukm {
		uks[i] = k
		i++
	}

	var r PackageRow
	rs = make(map[PackageID]*PackageRow, len(uks))
	if _, err = queryWithJSONArgs(ctx, db, func(i int) []interface{} {
		if i > 0 {
			r := r
			rs[*r.KeyID()] = &r
		}
		return r.ReceiveRow()
	}, SQLGetPackageRowsByID, uks); err != nil {
		return nil, formatError("GetPackageRowsByID", err)
	}
	rs[*r.KeyID()] = &r
	return rs, nil
}

// DeletePackageRowsByID deletes matching rows by PackageID keys from table "package"
func DeletePackageRowsByID(ctx context.Context, db SQLHandle, keys ...*PackageID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLDeletePackageRowsByID, keys)
	if err != nil {
		return numRows, formatError("DeletePackageRowsByID", err)
	}
	return numRows, nil
}

// UpdatePackageRowsByID deletes matching rows by PackageID keys from table "package"
func UpdatePackageRowsByID(ctx context.Context, db SQLHandle, changeset PackageValues, keys ...*PackageID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLUpdatePackageRowsByID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdatePackageRowsByID", err)
	}
	return numRows, nil
}

func (r *PackageRow) ReceiveRow() []interface{} {
	return []interface{}{&r.Data.ID, &r.Data.Name, &r.Data.Available}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PackageRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PackageRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PackageRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PackageRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Data)
}

var (
	SQLFindPackageRows = `
		WITH __f AS (SELECT "id", "name", "available" FROM json_populate_record(null::"wise"."package", $1))
		SELECT __t.id, __t.name, __t.available
		FROM "wise"."package" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))`
	SQLCountPackageRows = `
		WITH __f AS (SELECT "id", "name", "available" FROM json_populate_record(null::"wise"."package", $1))
		SELECT count(*) FROM "wise"."package" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))`
	SQLReturningPackageRows = `
		RETURNING "id", "name", "available"`
	SQLInsertPackageRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package", $1))
		INSERT INTO "wise"."package" AS __t ("id", "name", "available")
		SELECT 
			__v."id", 
			__v."name", 
			COALESCE(__v."available", true) FROM __v`
	SQLInsertReturningPackageRows = SQLInsertPackageRows + SQLReturningPackageRows
	SQLDeletePackageRows          = `
		DELETE FROM "wise"."package" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS uuid) = __t."id")
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS text) = __t."name")
			AND (($1::json->>'available' IS NULL) OR CAST($1::json->>'available' AS boolean) = __t."available")`
	SQLDeleteReturningPackageRows = SQLDeletePackageRows + SQLReturningPackageRows
	SQLUpdatePackageRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."package", $2))
		UPDATE "wise"."package" AS __t
		SET ("id", "name", "available") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."available", __t."available") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))`
	SQLUpdateReturningPackageRows = SQLUpdatePackageRows + SQLReturningPackageRows
	SQLReplacePackageRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package", $1))
		UPDATE "wise"."package" AS __t
			SET ("id", "name", "available") = (SELECT 
				COALESCE(__v."id", __t."id"), 
				COALESCE(__v."name", __t."name"), 
				COALESCE(__v."available", __t."available")
			FROM __v WHERE __v."id" = __t."id")
		FROM __v WHERE __v."id" = __t."id"`
	SQLReplaceReturningPackageRows = SQLReplacePackageRows + SQLReturningPackageRows
	SQLSavePackageRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package", $1))
		INSERT INTO "wise"."package" AS __t ("id", "name", "available")
		SELECT 
			__v."id", 
			__v."name", 
			COALESCE(__v."available", true) FROM __v
		ON CONFLICT ("id") DO UPDATE
		SET ("id", "name", "available") = (
			SELECT "id", "name", "available" FROM __v
			WHERE __v."id" = __t."id"
		)`
	SQLSaveReturningPackageRows = SQLSavePackageRows + SQLReturningPackageRows
	SQLGetPackageRowsByID       = `
		WITH __key AS (SELECT DISTINCT "id" FROM json_populate_recordset(null::"wise"."package", $1))
		SELECT "id", "name", "available"
		FROM __key JOIN "wise"."package" AS __t USING ("id")
		`
	SQLUpdatePackageRowsByID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package", $1)),
		  __key AS (SELECT id FROM json_populate_recordset(null::"wise"."package", $2))
		UPDATE "wise"."package" AS __t
		SET ("id", "name", "available") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."available", __t."available")
		FROM __v)
		FROM __key WHERE (__key."id" = __t."id")`
	SQLDeletePackageRowsByID = `
		WITH __key AS (SELECT id FROM json_populate_recordset(null::"wise"."package", $1))
		DELETE FROM "wise"."package" AS __t USING __key WHERE (__key."id" = __t."id")`
	SQLDeleteReturningPackageRowsByID = SQLDeletePackageRowsByID + SQLReturningPackageRows
)

// PackageProductRow represents a row for table "package_product"
type PackageProductRow struct {
	Data PackageProductData
}

type PackageProductData struct {
	PackageID string `json:"package_id"`
	ProductID int32  `json:"product_id"`
}

func NewPackageProductRow(data PackageProductData) *PackageProductRow {
	return &PackageProductRow{data}
}

func NewPackageProductRows(data ...PackageProductData) PackageProductRows {
	rows := make(PackageProductRows, len(data))
	for i, d := range data {
		rows[i] = NewPackageProductRow(d)
	}
	return rows
}

// GetPackageID gets value of column "package_id" from "package_product" row
func (r *PackageProductRow) GetPackageID() string { return r.Data.PackageID }

// SetPackageID sets value of column "package_id" in "package_product" row
func (r *PackageProductRow) SetPackageID(packageID string) { r.Data.PackageID = packageID }

// GetProductID gets value of column "product_id" from "package_product" row
func (r *PackageProductRow) GetProductID() int32 { return r.Data.ProductID }

// SetProductID sets value of column "product_id" in "package_product" row
func (r *PackageProductRow) SetProductID(productID int32) { r.Data.ProductID = productID }

// PackageProductPackageIDProductID represents key defined by UNIQUE constraint "package_product_package_id_product_id_key" for table "package_product"
type PackageProductPackageIDProductID struct {
	PackageID string `json:"package_id"`
	ProductID int32  `json:"product_id"`
}

func (r *PackageProductRow) KeyPackageIDProductID() *PackageProductPackageIDProductID {
	return &PackageProductPackageIDProductID{r.GetPackageID(), r.GetProductID()}
}

// PackageProductRows represents multiple rows for table "package_product"
type PackageProductRows []*PackageProductRow

func (rs PackageProductRows) KeyPackageIDProductID() (keys []*PackageProductPackageIDProductID) {
	keys = make([]*PackageProductPackageIDProductID, len(rs))
	for i, r := range rs {
		keys[i] = r.KeyPackageIDProductID()
	}
	return keys
}

func (r *PackageProductRow) RefPackageID() *PackageID {
	return &PackageID{r.GetPackageID()}
}

func (rs PackageProductRows) RefPackageID() (keys []*PackageID) {
	keys = make([]*PackageID, len(rs))
	for i, r := range rs {
		keys[i] = r.RefPackageID()
	}
	return keys
}
func (r *PackageProductRow) RefProductID() *ProductID {
	return &ProductID{r.GetProductID()}
}

func (rs PackageProductRows) RefProductID() (keys []*ProductID) {
	keys = make([]*ProductID, len(rs))
	for i, r := range rs {
		keys[i] = r.RefProductID()
	}
	return keys
}

// NewPackageProductTable(h SQLHandle) creates new PackageProductTable
func NewPackageProductTable(h SQLHandle) *PackageProductTable {
	return &PackageProductTable{h}
}

// PackageProductTable provides access methods for table "package_product"
type PackageProductTable struct {
	h SQLHandle
}

func (t *PackageProductTable) Find(ctx context.Context, filter PackageProductValues) (PackageProductRows, error) {
	return FindPackageProductRows(ctx, t.h, filter)
}

func (t *PackageProductTable) Count(ctx context.Context, filter PackageProductValues) (int, error) {
	return CountPackageProductRows(ctx, t.h, filter)
}

func (t *PackageProductTable) Update(ctx context.Context, changeset, filter PackageProductValues) (int64, error) {
	return UpdatePackageProductRows(ctx, t.h, changeset, filter)
}

func (t *PackageProductTable) Insert(ctx context.Context, rows ...*PackageProductRow) (int, error) {
	return InsertReturningPackageProductRows(ctx, t.h, rows...)
}

func (t *PackageProductTable) Delete(ctx context.Context, filter PackageProductValues) (int64, error) {
	return DeletePackageProductRows(ctx, t.h, filter)
}

func (t *PackageProductTable) Save(ctx context.Context, rows ...*PackageProductRow) error {
	return SaveReturningPackageProductRows(ctx, t.h, rows...)
}

func (t *PackageProductTable) GetByPackageIDProductID(ctx context.Context, keys ...*PackageProductPackageIDProductID) (map[PackageProductPackageIDProductID]*PackageProductRow, error) {
	return GetPackageProductRowsByPackageIDProductID(ctx, t.h, keys...)
}

func (t *PackageProductTable) UpdateByPackageIDProductID(ctx context.Context, changeset PackageProductValues, keys ...*PackageProductPackageIDProductID) (int64, error) {
	return UpdatePackageProductRowsByPackageIDProductID(ctx, t.h, changeset, keys...)
}

func (t *PackageProductTable) DeleteByPackageIDProductID(ctx context.Context, keys ...*PackageProductPackageIDProductID) (int64, error) {
	return DeletePackageProductRowsByPackageIDProductID(ctx, t.h, keys...)
}

type PackageProductValues struct {
	PackageID *string `json:"package_id"`
	ProductID *int32  `json:"product_id"`
}

// InsertPackageProductRows inserts the rows into table "package_product"
func InsertPackageProductRows(ctx context.Context, db SQLHandle, rows ...*PackageProductRow) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLInsertPackageProductRows, rows)
	if err != nil {
		return numRows, formatError("InsertPackageProductRows", err)
	}
	return numRows, nil
}

// InsertReturningPackageProductRows inserts the rows into table "package_product" and returns the rows.
func InsertReturningPackageProductRows(ctx context.Context, db SQLHandle, inputs ...*PackageProductRow) (numRows int, err error) {
	rows := PackageProductRows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturningPackageProductRows, rows)
	if err != nil {
		return numRows, formatError("InsertReturningPackageProductRows", err)
	}
	return numRows, nil
}

// FindPackageProductRows finds the rows matching the condition from table "package_product"
func FindPackageProductRows(ctx context.Context, db SQLHandle, cond PackageProductValues) (rows PackageProductRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFindPackageProductRows, cond); err != nil {
		return nil, formatError("FindPackageProductRows", err)
	}
	return rows, nil
}

// DeletePackageProductRows deletes the rows matching the condition from table "package_product"
func DeletePackageProductRows(ctx context.Context, db SQLHandle, cond PackageProductValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDeletePackageProductRows, cond); err != nil {
		return numRows, formatError("DeletePackageProductRows", err)
	}
	return numRows, nil
}

func UpdatePackageProductRows(ctx context.Context, db SQLHandle, changeset, filter PackageProductValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdatePackageProductRows, changeset, filter); err != nil {
		return numRows, formatError("UpdatePackageProductRows", err)
	}
	return numRows, nil
}

// CountPackageProductRows counts the number of rows matching the condition from table "package_product"
func CountPackageProductRows(ctx context.Context, db SQLHandle, cond PackageProductValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, SQLCountPackageProductRows, cond); err != nil {
		return 0, formatError("CountPackageProductRows", err)
	}
	return count, nil
}

// SavePackageProductRows upserts the given rows for table "package_product" checking uniqueness by contstraint "package_product_package_id_product_id_key"
func SavePackageProductRows(ctx context.Context, db SQLHandle, rows ...*PackageProductRow) (err error) {
	_, err = execWithJSONArgs(ctx, db, SQLSavePackageProductRows, rows)
	if err != nil {
		return formatError("SavePackageProductRows", err)
	}
	return nil
}

// SaveReturningPackageProductRows upserts the given rows for table "package_product" checking uniqueness by contstraint "package_product_package_id_product_id_key"
// It returns the new values and scan them into given row references.
func SaveReturningPackageProductRows(ctx context.Context, db SQLHandle, inputs ...*PackageProductRow) (err error) {
	rows := PackageProductRows(inputs)
	_, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLSaveReturningPackageProductRows, rows)
	if err != nil {
		return formatError("SaveReturningPackageProductRows", err)
	}
	return nil
}

// GetPackageProductRowsByPackageIDProductID gets matching rows for given PackageIDProductID keys from table "package_product"
func GetPackageProductRowsByPackageIDProductID(ctx context.Context, db SQLHandle, keys ...*PackageProductPackageIDProductID) (rs map[PackageProductPackageIDProductID]*PackageProductRow, err error) {
	ukm := make(map[PackageProductPackageIDProductID]struct{}, len(keys))
	for _, k := range keys {
		if k != nil {
			ukm[*k] = struct{}{}
		}
	}
	uks := make([]PackageProductPackageIDProductID, len(ukm))
	i := 0
	for k := range ukm {
		uks[i] = k
		i++
	}

	var r PackageProductRow
	rs = make(map[PackageProductPackageIDProductID]*PackageProductRow, len(uks))
	if _, err = queryWithJSONArgs(ctx, db, func(i int) []interface{} {
		if i > 0 {
			r := r
			rs[*r.KeyPackageIDProductID()] = &r
		}
		return r.ReceiveRow()
	}, SQLGetPackageProductRowsByPackageIDProductID, uks); err != nil {
		return nil, formatError("GetPackageProductRowsByPackageIDProductID", err)
	}
	rs[*r.KeyPackageIDProductID()] = &r
	return rs, nil
}

// DeletePackageProductRowsByPackageIDProductID deletes matching rows by PackageProductPackageIDProductID keys from table "package_product"
func DeletePackageProductRowsByPackageIDProductID(ctx context.Context, db SQLHandle, keys ...*PackageProductPackageIDProductID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLDeletePackageProductRowsByPackageIDProductID, keys)
	if err != nil {
		return numRows, formatError("DeletePackageProductRowsByPackageIDProductID", err)
	}
	return numRows, nil
}

// UpdatePackageProductRowsByPackageIDProductID deletes matching rows by PackageProductPackageIDProductID keys from table "package_product"
func UpdatePackageProductRowsByPackageIDProductID(ctx context.Context, db SQLHandle, changeset PackageProductValues, keys ...*PackageProductPackageIDProductID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLUpdatePackageProductRowsByPackageIDProductID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdatePackageProductRowsByPackageIDProductID", err)
	}
	return numRows, nil
}

func (r *PackageProductRow) ReceiveRow() []interface{} {
	return []interface{}{&r.Data.PackageID, &r.Data.ProductID}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PackageProductRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PackageProductRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PackageProductRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PackageProductRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Data)
}

var (
	SQLFindPackageProductRows = `
		WITH __f AS (SELECT "package_id", "product_id" FROM json_populate_record(null::"wise"."package_product", $1))
		SELECT __t.package_id, __t.product_id
		FROM "wise"."package_product" AS __t
		WHERE ((SELECT __f."package_id" IS NULL FROM __f) OR (SELECT __f."package_id" = __t."package_id" FROM __f))
			AND ((SELECT __f."product_id" IS NULL FROM __f) OR (SELECT __f."product_id" = __t."product_id" FROM __f))`
	SQLCountPackageProductRows = `
		WITH __f AS (SELECT "package_id", "product_id" FROM json_populate_record(null::"wise"."package_product", $1))
		SELECT count(*) FROM "wise"."package_product" AS __t
		WHERE ((SELECT __f."package_id" IS NULL FROM __f) OR (SELECT __f."package_id" = __t."package_id" FROM __f))
			AND ((SELECT __f."product_id" IS NULL FROM __f) OR (SELECT __f."product_id" = __t."product_id" FROM __f))`
	SQLReturningPackageProductRows = `
		RETURNING "package_id", "product_id"`
	SQLInsertPackageProductRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package_product", $1))
		INSERT INTO "wise"."package_product" AS __t ("package_id", "product_id")
		SELECT 
			__v."package_id", 
			__v."product_id" FROM __v`
	SQLInsertReturningPackageProductRows = SQLInsertPackageProductRows + SQLReturningPackageProductRows
	SQLDeletePackageProductRows          = `
		DELETE FROM "wise"."package_product" AS __t
		WHERE TRUE
			AND (($1::json->>'package_id' IS NULL) OR CAST($1::json->>'package_id' AS uuid) = __t."package_id")
			AND (($1::json->>'product_id' IS NULL) OR CAST($1::json->>'product_id' AS integer) = __t."product_id")`
	SQLDeleteReturningPackageProductRows = SQLDeletePackageProductRows + SQLReturningPackageProductRows
	SQLUpdatePackageProductRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package_product", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."package_product", $2))
		UPDATE "wise"."package_product" AS __t
		SET ("package_id", "product_id") = (SELECT 
			COALESCE(__v."package_id", __t."package_id"), 
			COALESCE(__v."product_id", __t."product_id") FROM __v)
		WHERE ((SELECT __f."package_id" IS NULL FROM __f) OR (SELECT __f."package_id" = __t."package_id" FROM __f))
			AND ((SELECT __f."product_id" IS NULL FROM __f) OR (SELECT __f."product_id" = __t."product_id" FROM __f))`
	SQLUpdateReturningPackageProductRows = SQLUpdatePackageProductRows + SQLReturningPackageProductRows
	SQLReplacePackageProductRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package_product", $1))
		UPDATE "wise"."package_product" AS __t
			SET ("package_id", "product_id") = (SELECT 
				COALESCE(__v."package_id", __t."package_id"), 
				COALESCE(__v."product_id", __t."product_id")
			FROM __v WHERE __v."package_id" = __t."package_id" AND __v."product_id" = __t."product_id")
		FROM __v WHERE __v."package_id" = __t."package_id" AND __v."product_id" = __t."product_id"`
	SQLReplaceReturningPackageProductRows = SQLReplacePackageProductRows + SQLReturningPackageProductRows
	SQLSavePackageProductRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package_product", $1))
		INSERT INTO "wise"."package_product" AS __t ("package_id", "product_id")
		SELECT 
			__v."package_id", 
			__v."product_id" FROM __v
		ON CONFLICT ("package_id", "product_id") DO UPDATE
		SET ("package_id", "product_id") = (
			SELECT "package_id", "product_id" FROM __v
			WHERE __v."package_id" = __t."package_id"
				AND __v."product_id" = __t."product_id"
		)`
	SQLSaveReturningPackageProductRows           = SQLSavePackageProductRows + SQLReturningPackageProductRows
	SQLGetPackageProductRowsByPackageIDProductID = `
		WITH __key AS (SELECT DISTINCT "package_id", "product_id" FROM json_populate_recordset(null::"wise"."package_product", $1))
		SELECT "package_id", "product_id"
		FROM __key JOIN "wise"."package_product" AS __t USING ("package_id", "product_id")
		`
	SQLUpdatePackageProductRowsByPackageIDProductID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package_product", $1)),
		  __key AS (SELECT package_id, product_id FROM json_populate_recordset(null::"wise"."package_product", $2))
		UPDATE "wise"."package_product" AS __t
		SET ("package_id", "product_id") = (SELECT
			COALESCE(__v."package_id", __t."package_id"), 
			COALESCE(__v."product_id", __t."product_id")
		FROM __v)
		FROM __key WHERE (__key."package_id" = __t."package_id")AND (__key."product_id" = __t."product_id")`
	SQLDeletePackageProductRowsByPackageIDProductID = `
		WITH __key AS (SELECT package_id, product_id FROM json_populate_recordset(null::"wise"."package_product", $1))
		DELETE FROM "wise"."package_product" AS __t USING __key WHERE (__key."package_id" = __t."package_id") AND (__key."product_id" = __t."product_id")`
	SQLDeleteReturningPackageProductRowsByPackageIDProductID = SQLDeletePackageProductRowsByPackageIDProductID + SQLReturningPackageProductRows
)

// ProductRow represents a row for table "product"
type ProductRow struct {
	Data ProductData
}

type ProductData struct {
	ID      *int32     `json:"id"`
	Price   string     `json:"price"`
	Name    string     `json:"name"`
	Alias   string     `json:"alias"`
	Stocked time.Time  `json:"stocked"`
	Sold    *time.Time `json:"sold"`
}

func NewProductRow(data ProductData) *ProductRow {
	return &ProductRow{data}
}

func NewProductRows(data ...ProductData) ProductRows {
	rows := make(ProductRows, len(data))
	for i, d := range data {
		rows[i] = NewProductRow(d)
	}
	return rows
}

// GetID gets value of column "id" from "product" row
func (r *ProductRow) GetID() int32 { return *r.Data.ID }

// SetID sets value of column "id" in "product" row
func (r *ProductRow) SetID(id int32) { r.Data.ID = &id }

// ClearID sets value of column "id" null in "product" row
func (r *ProductRow) ClearID() { r.Data.ID = nil }

// HasValidID checks to value of column "id" is not null
func (r *ProductRow) HasValidID() bool { return r.Data.ID != nil }

// GetPrice gets value of column "price" from "product" row
func (r *ProductRow) GetPrice() string { return r.Data.Price }

// SetPrice sets value of column "price" in "product" row
func (r *ProductRow) SetPrice(price string) { r.Data.Price = price }

// GetName gets value of column "name" from "product" row
func (r *ProductRow) GetName() string { return r.Data.Name }

// SetName sets value of column "name" in "product" row
func (r *ProductRow) SetName(name string) { r.Data.Name = name }

// GetAlias gets value of column "alias" from "product" row
func (r *ProductRow) GetAlias() string { return r.Data.Alias }

// SetAlias sets value of column "alias" in "product" row
func (r *ProductRow) SetAlias(alias string) { r.Data.Alias = alias }

// GetStocked gets value of column "stocked" from "product" row
func (r *ProductRow) GetStocked() time.Time { return r.Data.Stocked }

// SetStocked sets value of column "stocked" in "product" row
func (r *ProductRow) SetStocked(stocked time.Time) { r.Data.Stocked = stocked }

// GetSold gets value of column "sold" from "product" row
func (r *ProductRow) GetSold() time.Time { return *r.Data.Sold }

// SetSold sets value of column "sold" in "product" row
func (r *ProductRow) SetSold(sold time.Time) { r.Data.Sold = &sold }

// ClearSold sets value of column "sold" null in "product" row
func (r *ProductRow) ClearSold() { r.Data.Sold = nil }

// HasValidSold checks to value of column "sold" is not null
func (r *ProductRow) HasValidSold() bool { return r.Data.Sold != nil }

// ProductID represents key defined by PRIMARY KEY constraint "product_pkey" for table "product"
type ProductID struct {
	ID int32 `json:"id"`
}

func (r *ProductRow) KeyID() *ProductID {
	return &ProductID{r.GetID()}
}

// ProductAlias represents key defined by UNIQUE constraint "product_alias_key" for table "product"
type ProductAlias struct {
	Alias string `json:"alias"`
}

func (r *ProductRow) KeyAlias() *ProductAlias {
	return &ProductAlias{r.GetAlias()}
}

// ProductRows represents multiple rows for table "product"
type ProductRows []*ProductRow

func (rs ProductRows) KeyID() (keys []*ProductID) {
	keys = make([]*ProductID, len(rs))
	for i, r := range rs {
		keys[i] = r.KeyID()
	}
	return keys
}

func (rs ProductRows) KeyAlias() (keys []*ProductAlias) {
	keys = make([]*ProductAlias, len(rs))
	for i, r := range rs {
		keys[i] = r.KeyAlias()
	}
	return keys
}

// NewProductTable(h SQLHandle) creates new ProductTable
func NewProductTable(h SQLHandle) *ProductTable {
	return &ProductTable{h}
}

// ProductTable provides access methods for table "product"
type ProductTable struct {
	h SQLHandle
}

func (t *ProductTable) Find(ctx context.Context, filter ProductValues) (ProductRows, error) {
	return FindProductRows(ctx, t.h, filter)
}

func (t *ProductTable) Count(ctx context.Context, filter ProductValues) (int, error) {
	return CountProductRows(ctx, t.h, filter)
}

func (t *ProductTable) Update(ctx context.Context, changeset, filter ProductValues) (int64, error) {
	return UpdateProductRows(ctx, t.h, changeset, filter)
}

func (t *ProductTable) Insert(ctx context.Context, rows ...*ProductRow) (int, error) {
	return InsertReturningProductRows(ctx, t.h, rows...)
}

func (t *ProductTable) Delete(ctx context.Context, filter ProductValues) (int64, error) {
	return DeleteProductRows(ctx, t.h, filter)
}

func (t *ProductTable) Save(ctx context.Context, rows ...*ProductRow) error {
	return SaveReturningProductRows(ctx, t.h, rows...)
}

func (t *ProductTable) GetByID(ctx context.Context, keys ...*ProductID) (map[ProductID]*ProductRow, error) {
	return GetProductRowsByID(ctx, t.h, keys...)
}

func (t *ProductTable) UpdateByID(ctx context.Context, changeset ProductValues, keys ...*ProductID) (int64, error) {
	return UpdateProductRowsByID(ctx, t.h, changeset, keys...)
}

func (t *ProductTable) DeleteByID(ctx context.Context, keys ...*ProductID) (int64, error) {
	return DeleteProductRowsByID(ctx, t.h, keys...)
}

func (t *ProductTable) GetByAlias(ctx context.Context, keys ...*ProductAlias) (map[ProductAlias]*ProductRow, error) {
	return GetProductRowsByAlias(ctx, t.h, keys...)
}

func (t *ProductTable) UpdateByAlias(ctx context.Context, changeset ProductValues, keys ...*ProductAlias) (int64, error) {
	return UpdateProductRowsByAlias(ctx, t.h, changeset, keys...)
}

func (t *ProductTable) DeleteByAlias(ctx context.Context, keys ...*ProductAlias) (int64, error) {
	return DeleteProductRowsByAlias(ctx, t.h, keys...)
}

type ProductValues struct {
	ID      *int32     `json:"id"`
	Price   *string    `json:"price"`
	Name    *string    `json:"name"`
	Alias   *string    `json:"alias"`
	Stocked *time.Time `json:"stocked"`
	Sold    *time.Time `json:"sold"`
}

// InsertProductRows inserts the rows into table "product"
func InsertProductRows(ctx context.Context, db SQLHandle, rows ...*ProductRow) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLInsertProductRows, rows)
	if err != nil {
		return numRows, formatError("InsertProductRows", err)
	}
	return numRows, nil
}

// InsertReturningProductRows inserts the rows into table "product" and returns the rows.
func InsertReturningProductRows(ctx context.Context, db SQLHandle, inputs ...*ProductRow) (numRows int, err error) {
	rows := ProductRows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturningProductRows, rows)
	if err != nil {
		return numRows, formatError("InsertReturningProductRows", err)
	}
	return numRows, nil
}

// FindProductRows finds the rows matching the condition from table "product"
func FindProductRows(ctx context.Context, db SQLHandle, cond ProductValues) (rows ProductRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFindProductRows, cond); err != nil {
		return nil, formatError("FindProductRows", err)
	}
	return rows, nil
}

// DeleteProductRows deletes the rows matching the condition from table "product"
func DeleteProductRows(ctx context.Context, db SQLHandle, cond ProductValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDeleteProductRows, cond); err != nil {
		return numRows, formatError("DeleteProductRows", err)
	}
	return numRows, nil
}

func UpdateProductRows(ctx context.Context, db SQLHandle, changeset, filter ProductValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdateProductRows, changeset, filter); err != nil {
		return numRows, formatError("UpdateProductRows", err)
	}
	return numRows, nil
}

// CountProductRows counts the number of rows matching the condition from table "product"
func CountProductRows(ctx context.Context, db SQLHandle, cond ProductValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, SQLCountProductRows, cond); err != nil {
		return 0, formatError("CountProductRows", err)
	}
	return count, nil
}

// SaveProductRows upserts the given rows for table "product" checking uniqueness by contstraint "product_pkey"
func SaveProductRows(ctx context.Context, db SQLHandle, rows ...*ProductRow) (err error) {
	_, err = execWithJSONArgs(ctx, db, SQLSaveProductRows, rows)
	if err != nil {
		return formatError("SaveProductRows", err)
	}
	return nil
}

// SaveReturningProductRows upserts the given rows for table "product" checking uniqueness by contstraint "product_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningProductRows(ctx context.Context, db SQLHandle, inputs ...*ProductRow) (err error) {
	rows := ProductRows(inputs)
	_, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLSaveReturningProductRows, rows)
	if err != nil {
		return formatError("SaveReturningProductRows", err)
	}
	return nil
}

// GetProductRowsByID gets matching rows for given ID keys from table "product"
func GetProductRowsByID(ctx context.Context, db SQLHandle, keys ...*ProductID) (rs map[ProductID]*ProductRow, err error) {
	ukm := make(map[ProductID]struct{}, len(keys))
	for _, k := range keys {
		if k != nil {
			ukm[*k] = struct{}{}
		}
	}
	uks := make([]ProductID, len(ukm))
	i := 0
	for k := range ukm {
		uks[i] = k
		i++
	}

	var r ProductRow
	rs = make(map[ProductID]*ProductRow, len(uks))
	if _, err = queryWithJSONArgs(ctx, db, func(i int) []interface{} {
		if i > 0 {
			r := r
			rs[*r.KeyID()] = &r
		}
		return r.ReceiveRow()
	}, SQLGetProductRowsByID, uks); err != nil {
		return nil, formatError("GetProductRowsByID", err)
	}
	rs[*r.KeyID()] = &r
	return rs, nil
}

// DeleteProductRowsByID deletes matching rows by ProductID keys from table "product"
func DeleteProductRowsByID(ctx context.Context, db SQLHandle, keys ...*ProductID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLDeleteProductRowsByID, keys)
	if err != nil {
		return numRows, formatError("DeleteProductRowsByID", err)
	}
	return numRows, nil
}

// UpdateProductRowsByID deletes matching rows by ProductID keys from table "product"
func UpdateProductRowsByID(ctx context.Context, db SQLHandle, changeset ProductValues, keys ...*ProductID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLUpdateProductRowsByID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateProductRowsByID", err)
	}
	return numRows, nil
}

// GetProductRowsByAlias gets matching rows for given Alias keys from table "product"
func GetProductRowsByAlias(ctx context.Context, db SQLHandle, keys ...*ProductAlias) (rs map[ProductAlias]*ProductRow, err error) {
	ukm := make(map[ProductAlias]struct{}, len(keys))
	for _, k := range keys {
		if k != nil {
			ukm[*k] = struct{}{}
		}
	}
	uks := make([]ProductAlias, len(ukm))
	i := 0
	for k := range ukm {
		uks[i] = k
		i++
	}

	var r ProductRow
	rs = make(map[ProductAlias]*ProductRow, len(uks))
	if _, err = queryWithJSONArgs(ctx, db, func(i int) []interface{} {
		if i > 0 {
			r := r
			rs[*r.KeyAlias()] = &r
		}
		return r.ReceiveRow()
	}, SQLGetProductRowsByAlias, uks); err != nil {
		return nil, formatError("GetProductRowsByAlias", err)
	}
	rs[*r.KeyAlias()] = &r
	return rs, nil
}

// DeleteProductRowsByAlias deletes matching rows by ProductAlias keys from table "product"
func DeleteProductRowsByAlias(ctx context.Context, db SQLHandle, keys ...*ProductAlias) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLDeleteProductRowsByAlias, keys)
	if err != nil {
		return numRows, formatError("DeleteProductRowsByAlias", err)
	}
	return numRows, nil
}

// UpdateProductRowsByAlias deletes matching rows by ProductAlias keys from table "product"
func UpdateProductRowsByAlias(ctx context.Context, db SQLHandle, changeset ProductValues, keys ...*ProductAlias) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLUpdateProductRowsByAlias, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateProductRowsByAlias", err)
	}
	return numRows, nil
}

func (r *ProductRow) ReceiveRow() []interface{} {
	return []interface{}{&r.Data.ID, &r.Data.Price, &r.Data.Name, &r.Data.Alias, &r.Data.Stocked, &r.Data.Sold}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *ProductRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(ProductRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(ProductRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *ProductRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Data)
}

var (
	SQLFindProductRows = `
		WITH __f AS (SELECT "id", "price", "name", "alias", "stocked", "sold" FROM json_populate_record(null::"wise"."product", $1))
		SELECT __t.id, __t.price, __t.name, __t.alias, __t.stocked, __t.sold
		FROM "wise"."product" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."price" IS NULL FROM __f) OR (SELECT __f."price" = __t."price" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."alias" IS NULL FROM __f) OR (SELECT __f."alias" = __t."alias" FROM __f))
			AND ((SELECT __f."stocked" IS NULL FROM __f) OR (SELECT __f."stocked" = __t."stocked" FROM __f))
			AND ((SELECT __f."sold" IS NULL FROM __f) OR (SELECT __f."sold" = __t."sold" FROM __f))`
	SQLCountProductRows = `
		WITH __f AS (SELECT "id", "price", "name", "alias", "stocked", "sold" FROM json_populate_record(null::"wise"."product", $1))
		SELECT count(*) FROM "wise"."product" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."price" IS NULL FROM __f) OR (SELECT __f."price" = __t."price" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."alias" IS NULL FROM __f) OR (SELECT __f."alias" = __t."alias" FROM __f))
			AND ((SELECT __f."stocked" IS NULL FROM __f) OR (SELECT __f."stocked" = __t."stocked" FROM __f))
			AND ((SELECT __f."sold" IS NULL FROM __f) OR (SELECT __f."sold" = __t."sold" FROM __f))`
	SQLReturningProductRows = `
		RETURNING "id", "price", "name", "alias", "stocked", "sold"`
	SQLInsertProductRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."product", $1))
		INSERT INTO "wise"."product" AS __t ("id", "price", "name", "alias", "stocked", "sold")
		SELECT 
			COALESCE(__v."id", nextval('wise.product_id_seq'::regclass)), 
			__v."price", 
			__v."name", 
			__v."alias", 
			__v."stocked", 
			__v."sold" FROM __v`
	SQLInsertReturningProductRows = SQLInsertProductRows + SQLReturningProductRows
	SQLDeleteProductRows          = `
		DELETE FROM "wise"."product" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS integer) = __t."id")
			AND (($1::json->>'price' IS NULL) OR CAST($1::json->>'price' AS money) = __t."price")
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS character varying) = __t."name")
			AND (($1::json->>'alias' IS NULL) OR CAST($1::json->>'alias' AS character varying) = __t."alias")
			AND (($1::json->>'stocked' IS NULL) OR CAST($1::json->>'stocked' AS timestamp with time zone) = __t."stocked")
			AND (($1::json->>'sold' IS NULL) OR CAST($1::json->>'sold' AS timestamp with time zone) = __t."sold")`
	SQLDeleteReturningProductRows = SQLDeleteProductRows + SQLReturningProductRows
	SQLUpdateProductRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."product", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."product", $2))
		UPDATE "wise"."product" AS __t
		SET ("id", "price", "name", "alias", "stocked", "sold") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."price", __t."price"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."alias", __t."alias"), 
			COALESCE(__v."stocked", __t."stocked"), 
			COALESCE(__v."sold", __t."sold") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."price" IS NULL FROM __f) OR (SELECT __f."price" = __t."price" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."alias" IS NULL FROM __f) OR (SELECT __f."alias" = __t."alias" FROM __f))
			AND ((SELECT __f."stocked" IS NULL FROM __f) OR (SELECT __f."stocked" = __t."stocked" FROM __f))
			AND ((SELECT __f."sold" IS NULL FROM __f) OR (SELECT __f."sold" = __t."sold" FROM __f))`
	SQLUpdateReturningProductRows = SQLUpdateProductRows + SQLReturningProductRows
	SQLReplaceProductRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."product", $1))
		UPDATE "wise"."product" AS __t
			SET ("id", "price", "name", "alias", "stocked", "sold") = (SELECT 
				COALESCE(__v."id", __t."id"), 
				COALESCE(__v."price", __t."price"), 
				COALESCE(__v."name", __t."name"), 
				COALESCE(__v."alias", __t."alias"), 
				COALESCE(__v."stocked", __t."stocked"), 
				COALESCE(__v."sold", __t."sold")
			FROM __v WHERE __v."id" = __t."id")
		FROM __v WHERE __v."id" = __t."id"`
	SQLReplaceReturningProductRows = SQLReplaceProductRows + SQLReturningProductRows
	SQLSaveProductRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."product", $1))
		INSERT INTO "wise"."product" AS __t ("id", "price", "name", "alias", "stocked", "sold")
		SELECT 
			COALESCE(__v."id", nextval('wise.product_id_seq'::regclass)), 
			__v."price", 
			__v."name", 
			__v."alias", 
			__v."stocked", 
			__v."sold" FROM __v
		ON CONFLICT ("id") DO UPDATE
		SET ("id", "price", "name", "alias", "stocked", "sold") = (
			SELECT "id", "price", "name", "alias", "stocked", "sold" FROM __v
			WHERE __v."id" = __t."id"
		)`
	SQLSaveReturningProductRows = SQLSaveProductRows + SQLReturningProductRows
	SQLGetProductRowsByID       = `
		WITH __key AS (SELECT DISTINCT "id" FROM json_populate_recordset(null::"wise"."product", $1))
		SELECT "id", "price", "name", "alias", "stocked", "sold"
		FROM __key JOIN "wise"."product" AS __t USING ("id")
		`
	SQLUpdateProductRowsByID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."product", $1)),
		  __key AS (SELECT id FROM json_populate_recordset(null::"wise"."product", $2))
		UPDATE "wise"."product" AS __t
		SET ("id", "price", "name", "alias", "stocked", "sold") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."price", __t."price"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."alias", __t."alias"), 
			COALESCE(__v."stocked", __t."stocked"), 
			COALESCE(__v."sold", __t."sold")
		FROM __v)
		FROM __key WHERE (__key."id" = __t."id")`
	SQLDeleteProductRowsByID = `
		WITH __key AS (SELECT id FROM json_populate_recordset(null::"wise"."product", $1))
		DELETE FROM "wise"."product" AS __t USING __key WHERE (__key."id" = __t."id")`
	SQLDeleteReturningProductRowsByID = SQLDeleteProductRowsByID + SQLReturningProductRows
	SQLGetProductRowsByAlias          = `
		WITH __key AS (SELECT DISTINCT "alias" FROM json_populate_recordset(null::"wise"."product", $1))
		SELECT "id", "price", "name", "alias", "stocked", "sold"
		FROM __key JOIN "wise"."product" AS __t USING ("alias")
		`
	SQLUpdateProductRowsByAlias = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."product", $1)),
		  __key AS (SELECT alias FROM json_populate_recordset(null::"wise"."product", $2))
		UPDATE "wise"."product" AS __t
		SET ("id", "price", "name", "alias", "stocked", "sold") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."price", __t."price"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."alias", __t."alias"), 
			COALESCE(__v."stocked", __t."stocked"), 
			COALESCE(__v."sold", __t."sold")
		FROM __v)
		FROM __key WHERE (__key."alias" = __t."alias")`
	SQLDeleteProductRowsByAlias = `
		WITH __key AS (SELECT alias FROM json_populate_recordset(null::"wise"."product", $1))
		DELETE FROM "wise"."product" AS __t USING __key WHERE (__key."alias" = __t."alias")`
	SQLDeleteReturningProductRowsByAlias = SQLDeleteProductRowsByAlias + SQLReturningProductRows
)

// PopRow represents a row for table "pop"
type PopRow struct {
	Data PopData
}

type PopData struct {
	Name        string `json:"name"`
	Year        int32  `json:"year"`
	Description string `json:"description"`
}

func NewPopRow(data PopData) *PopRow {
	return &PopRow{data}
}

func NewPopRows(data ...PopData) PopRows {
	rows := make(PopRows, len(data))
	for i, d := range data {
		rows[i] = NewPopRow(d)
	}
	return rows
}

// GetName gets value of column "name" from "pop" row
func (r *PopRow) GetName() string { return r.Data.Name }

// SetName sets value of column "name" in "pop" row
func (r *PopRow) SetName(name string) { r.Data.Name = name }

// GetYear gets value of column "year" from "pop" row
func (r *PopRow) GetYear() int32 { return r.Data.Year }

// SetYear sets value of column "year" in "pop" row
func (r *PopRow) SetYear(year int32) { r.Data.Year = year }

// GetDescription gets value of column "description" from "pop" row
func (r *PopRow) GetDescription() string { return r.Data.Description }

// SetDescription sets value of column "description" in "pop" row
func (r *PopRow) SetDescription(description string) { r.Data.Description = description }

// PopNameYear represents key defined by PRIMARY KEY constraint "pop_pkey" for table "pop"
type PopNameYear struct {
	Name string `json:"name"`
	Year int32  `json:"year"`
}

func (r *PopRow) KeyNameYear() *PopNameYear {
	return &PopNameYear{r.GetName(), r.GetYear()}
}

// PopRows represents multiple rows for table "pop"
type PopRows []*PopRow

func (rs PopRows) KeyNameYear() (keys []*PopNameYear) {
	keys = make([]*PopNameYear, len(rs))
	for i, r := range rs {
		keys[i] = r.KeyNameYear()
	}
	return keys
}

// NewPopTable(h SQLHandle) creates new PopTable
func NewPopTable(h SQLHandle) *PopTable {
	return &PopTable{h}
}

// PopTable provides access methods for table "pop"
type PopTable struct {
	h SQLHandle
}

func (t *PopTable) Find(ctx context.Context, filter PopValues) (PopRows, error) {
	return FindPopRows(ctx, t.h, filter)
}

func (t *PopTable) Count(ctx context.Context, filter PopValues) (int, error) {
	return CountPopRows(ctx, t.h, filter)
}

func (t *PopTable) Update(ctx context.Context, changeset, filter PopValues) (int64, error) {
	return UpdatePopRows(ctx, t.h, changeset, filter)
}

func (t *PopTable) Insert(ctx context.Context, rows ...*PopRow) (int, error) {
	return InsertReturningPopRows(ctx, t.h, rows...)
}

func (t *PopTable) Delete(ctx context.Context, filter PopValues) (int64, error) {
	return DeletePopRows(ctx, t.h, filter)
}

func (t *PopTable) Save(ctx context.Context, rows ...*PopRow) error {
	return SaveReturningPopRows(ctx, t.h, rows...)
}

func (t *PopTable) GetByNameYear(ctx context.Context, keys ...*PopNameYear) (map[PopNameYear]*PopRow, error) {
	return GetPopRowsByNameYear(ctx, t.h, keys...)
}

func (t *PopTable) UpdateByNameYear(ctx context.Context, changeset PopValues, keys ...*PopNameYear) (int64, error) {
	return UpdatePopRowsByNameYear(ctx, t.h, changeset, keys...)
}

func (t *PopTable) DeleteByNameYear(ctx context.Context, keys ...*PopNameYear) (int64, error) {
	return DeletePopRowsByNameYear(ctx, t.h, keys...)
}

type PopValues struct {
	Name        *string `json:"name"`
	Year        *int32  `json:"year"`
	Description *string `json:"description"`
}

// InsertPopRows inserts the rows into table "pop"
func InsertPopRows(ctx context.Context, db SQLHandle, rows ...*PopRow) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLInsertPopRows, rows)
	if err != nil {
		return numRows, formatError("InsertPopRows", err)
	}
	return numRows, nil
}

// InsertReturningPopRows inserts the rows into table "pop" and returns the rows.
func InsertReturningPopRows(ctx context.Context, db SQLHandle, inputs ...*PopRow) (numRows int, err error) {
	rows := PopRows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturningPopRows, rows)
	if err != nil {
		return numRows, formatError("InsertReturningPopRows", err)
	}
	return numRows, nil
}

// FindPopRows finds the rows matching the condition from table "pop"
func FindPopRows(ctx context.Context, db SQLHandle, cond PopValues) (rows PopRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFindPopRows, cond); err != nil {
		return nil, formatError("FindPopRows", err)
	}
	return rows, nil
}

// DeletePopRows deletes the rows matching the condition from table "pop"
func DeletePopRows(ctx context.Context, db SQLHandle, cond PopValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDeletePopRows, cond); err != nil {
		return numRows, formatError("DeletePopRows", err)
	}
	return numRows, nil
}

func UpdatePopRows(ctx context.Context, db SQLHandle, changeset, filter PopValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdatePopRows, changeset, filter); err != nil {
		return numRows, formatError("UpdatePopRows", err)
	}
	return numRows, nil
}

// CountPopRows counts the number of rows matching the condition from table "pop"
func CountPopRows(ctx context.Context, db SQLHandle, cond PopValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, SQLCountPopRows, cond); err != nil {
		return 0, formatError("CountPopRows", err)
	}
	return count, nil
}

// SavePopRows upserts the given rows for table "pop" checking uniqueness by contstraint "pop_pkey"
func SavePopRows(ctx context.Context, db SQLHandle, rows ...*PopRow) (err error) {
	_, err = execWithJSONArgs(ctx, db, SQLSavePopRows, rows)
	if err != nil {
		return formatError("SavePopRows", err)
	}
	return nil
}

// SaveReturningPopRows upserts the given rows for table "pop" checking uniqueness by contstraint "pop_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningPopRows(ctx context.Context, db SQLHandle, inputs ...*PopRow) (err error) {
	rows := PopRows(inputs)
	_, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLSaveReturningPopRows, rows)
	if err != nil {
		return formatError("SaveReturningPopRows", err)
	}
	return nil
}

// GetPopRowsByNameYear gets matching rows for given NameYear keys from table "pop"
func GetPopRowsByNameYear(ctx context.Context, db SQLHandle, keys ...*PopNameYear) (rs map[PopNameYear]*PopRow, err error) {
	ukm := make(map[PopNameYear]struct{}, len(keys))
	for _, k := range keys {
		if k != nil {
			ukm[*k] = struct{}{}
		}
	}
	uks := make([]PopNameYear, len(ukm))
	i := 0
	for k := range ukm {
		uks[i] = k
		i++
	}

	var r PopRow
	rs = make(map[PopNameYear]*PopRow, len(uks))
	if _, err = queryWithJSONArgs(ctx, db, func(i int) []interface{} {
		if i > 0 {
			r := r
			rs[*r.KeyNameYear()] = &r
		}
		return r.ReceiveRow()
	}, SQLGetPopRowsByNameYear, uks); err != nil {
		return nil, formatError("GetPopRowsByNameYear", err)
	}
	rs[*r.KeyNameYear()] = &r
	return rs, nil
}

// DeletePopRowsByNameYear deletes matching rows by PopNameYear keys from table "pop"
func DeletePopRowsByNameYear(ctx context.Context, db SQLHandle, keys ...*PopNameYear) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLDeletePopRowsByNameYear, keys)
	if err != nil {
		return numRows, formatError("DeletePopRowsByNameYear", err)
	}
	return numRows, nil
}

// UpdatePopRowsByNameYear deletes matching rows by PopNameYear keys from table "pop"
func UpdatePopRowsByNameYear(ctx context.Context, db SQLHandle, changeset PopValues, keys ...*PopNameYear) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLUpdatePopRowsByNameYear, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdatePopRowsByNameYear", err)
	}
	return numRows, nil
}

func (r *PopRow) ReceiveRow() []interface{} {
	return []interface{}{&r.Data.Name, &r.Data.Year, &r.Data.Description}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PopRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PopRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PopRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PopRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Data)
}

var (
	SQLFindPopRows = `
		WITH __f AS (SELECT "name", "year", "description" FROM json_populate_record(null::"wise"."pop", $1))
		SELECT __t.name, __t.year, __t.description
		FROM "wise"."pop" AS __t
		WHERE ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."year" IS NULL FROM __f) OR (SELECT __f."year" = __t."year" FROM __f))
			AND ((SELECT __f."description" IS NULL FROM __f) OR (SELECT __f."description" = __t."description" FROM __f))`
	SQLCountPopRows = `
		WITH __f AS (SELECT "name", "year", "description" FROM json_populate_record(null::"wise"."pop", $1))
		SELECT count(*) FROM "wise"."pop" AS __t
		WHERE ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."year" IS NULL FROM __f) OR (SELECT __f."year" = __t."year" FROM __f))
			AND ((SELECT __f."description" IS NULL FROM __f) OR (SELECT __f."description" = __t."description" FROM __f))`
	SQLReturningPopRows = `
		RETURNING "name", "year", "description"`
	SQLInsertPopRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."pop", $1))
		INSERT INTO "wise"."pop" AS __t ("name", "year", "description")
		SELECT 
			__v."name", 
			__v."year", 
			__v."description" FROM __v`
	SQLInsertReturningPopRows = SQLInsertPopRows + SQLReturningPopRows
	SQLDeletePopRows          = `
		DELETE FROM "wise"."pop" AS __t
		WHERE TRUE
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS text) = __t."name")
			AND (($1::json->>'year' IS NULL) OR CAST($1::json->>'year' AS integer) = __t."year")
			AND (($1::json->>'description' IS NULL) OR CAST($1::json->>'description' AS text) = __t."description")`
	SQLDeleteReturningPopRows = SQLDeletePopRows + SQLReturningPopRows
	SQLUpdatePopRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."pop", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."pop", $2))
		UPDATE "wise"."pop" AS __t
		SET ("name", "year", "description") = (SELECT 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."year", __t."year"), 
			COALESCE(__v."description", __t."description") FROM __v)
		WHERE ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."year" IS NULL FROM __f) OR (SELECT __f."year" = __t."year" FROM __f))
			AND ((SELECT __f."description" IS NULL FROM __f) OR (SELECT __f."description" = __t."description" FROM __f))`
	SQLUpdateReturningPopRows = SQLUpdatePopRows + SQLReturningPopRows
	SQLReplacePopRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."pop", $1))
		UPDATE "wise"."pop" AS __t
			SET ("name", "year", "description") = (SELECT 
				COALESCE(__v."name", __t."name"), 
				COALESCE(__v."year", __t."year"), 
				COALESCE(__v."description", __t."description")
			FROM __v WHERE __v."name" = __t."name" AND __v."year" = __t."year")
		FROM __v WHERE __v."name" = __t."name" AND __v."year" = __t."year"`
	SQLReplaceReturningPopRows = SQLReplacePopRows + SQLReturningPopRows
	SQLSavePopRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."pop", $1))
		INSERT INTO "wise"."pop" AS __t ("name", "year", "description")
		SELECT 
			__v."name", 
			__v."year", 
			__v."description" FROM __v
		ON CONFLICT ("name", "year") DO UPDATE
		SET ("name", "year", "description") = (
			SELECT "name", "year", "description" FROM __v
			WHERE __v."name" = __t."name"
				AND __v."year" = __t."year"
		)`
	SQLSaveReturningPopRows = SQLSavePopRows + SQLReturningPopRows
	SQLGetPopRowsByNameYear = `
		WITH __key AS (SELECT DISTINCT "name", "year" FROM json_populate_recordset(null::"wise"."pop", $1))
		SELECT "name", "year", "description"
		FROM __key JOIN "wise"."pop" AS __t USING ("name", "year")
		`
	SQLUpdatePopRowsByNameYear = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."pop", $1)),
		  __key AS (SELECT name, year FROM json_populate_recordset(null::"wise"."pop", $2))
		UPDATE "wise"."pop" AS __t
		SET ("name", "year", "description") = (SELECT
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."year", __t."year"), 
			COALESCE(__v."description", __t."description")
		FROM __v)
		FROM __key WHERE (__key."name" = __t."name")AND (__key."year" = __t."year")`
	SQLDeletePopRowsByNameYear = `
		WITH __key AS (SELECT name, year FROM json_populate_recordset(null::"wise"."pop", $1))
		DELETE FROM "wise"."pop" AS __t USING __key WHERE (__key."name" = __t."name") AND (__key."year" = __t."year")`
	SQLDeleteReturningPopRowsByNameYear = SQLDeletePopRowsByNameYear + SQLReturningPopRows
)

// CampaignRow represents a row for table "campaign"
type CampaignRow struct {
	Data CampaignData
}

type CampaignData struct {
	ID      string  `json:"id"`
	PopName *string `json:"pop_name"`
	PopYear *int32  `json:"pop_year"`
}

func NewCampaignRow(data CampaignData) *CampaignRow {
	return &CampaignRow{data}
}

func NewCampaignRows(data ...CampaignData) CampaignRows {
	rows := make(CampaignRows, len(data))
	for i, d := range data {
		rows[i] = NewCampaignRow(d)
	}
	return rows
}

// GetID gets value of column "id" from "campaign" row
func (r *CampaignRow) GetID() string { return r.Data.ID }

// SetID sets value of column "id" in "campaign" row
func (r *CampaignRow) SetID(id string) { r.Data.ID = id }

// GetPopName gets value of column "pop_name" from "campaign" row
func (r *CampaignRow) GetPopName() string { return *r.Data.PopName }

// SetPopName sets value of column "pop_name" in "campaign" row
func (r *CampaignRow) SetPopName(popName string) { r.Data.PopName = &popName }

// ClearPopName sets value of column "pop_name" null in "campaign" row
func (r *CampaignRow) ClearPopName() { r.Data.PopName = nil }

// HasValidPopName checks to value of column "pop_name" is not null
func (r *CampaignRow) HasValidPopName() bool { return r.Data.PopName != nil }

// GetPopYear gets value of column "pop_year" from "campaign" row
func (r *CampaignRow) GetPopYear() int32 { return *r.Data.PopYear }

// SetPopYear sets value of column "pop_year" in "campaign" row
func (r *CampaignRow) SetPopYear(popYear int32) { r.Data.PopYear = &popYear }

// ClearPopYear sets value of column "pop_year" null in "campaign" row
func (r *CampaignRow) ClearPopYear() { r.Data.PopYear = nil }

// HasValidPopYear checks to value of column "pop_year" is not null
func (r *CampaignRow) HasValidPopYear() bool { return r.Data.PopYear != nil }

// CampaignID represents key defined by PRIMARY KEY constraint "campaign_pkey" for table "campaign"
type CampaignID struct {
	ID string `json:"id"`
}

func (r *CampaignRow) KeyID() *CampaignID {
	return &CampaignID{r.GetID()}
}

// CampaignRows represents multiple rows for table "campaign"
type CampaignRows []*CampaignRow

func (rs CampaignRows) KeyID() (keys []*CampaignID) {
	keys = make([]*CampaignID, len(rs))
	for i, r := range rs {
		keys[i] = r.KeyID()
	}
	return keys
}

func (r *CampaignRow) RefPopNamePopYear() *PopNameYear {
	if !r.HasValidPopName() {
		return nil
	}
	if !r.HasValidPopYear() {
		return nil
	}
	return &PopNameYear{r.GetPopName(), r.GetPopYear()}
}

func (rs CampaignRows) RefPopNamePopYear() (keys []*PopNameYear) {
	keys = make([]*PopNameYear, len(rs))
	for i, r := range rs {
		keys[i] = r.RefPopNamePopYear()
	}
	return keys
}

// NewCampaignTable(h SQLHandle) creates new CampaignTable
func NewCampaignTable(h SQLHandle) *CampaignTable {
	return &CampaignTable{h}
}

// CampaignTable provides access methods for table "campaign"
type CampaignTable struct {
	h SQLHandle
}

func (t *CampaignTable) Find(ctx context.Context, filter CampaignValues) (CampaignRows, error) {
	return FindCampaignRows(ctx, t.h, filter)
}

func (t *CampaignTable) Count(ctx context.Context, filter CampaignValues) (int, error) {
	return CountCampaignRows(ctx, t.h, filter)
}

func (t *CampaignTable) Update(ctx context.Context, changeset, filter CampaignValues) (int64, error) {
	return UpdateCampaignRows(ctx, t.h, changeset, filter)
}

func (t *CampaignTable) Insert(ctx context.Context, rows ...*CampaignRow) (int, error) {
	return InsertReturningCampaignRows(ctx, t.h, rows...)
}

func (t *CampaignTable) Delete(ctx context.Context, filter CampaignValues) (int64, error) {
	return DeleteCampaignRows(ctx, t.h, filter)
}

func (t *CampaignTable) Save(ctx context.Context, rows ...*CampaignRow) error {
	return SaveReturningCampaignRows(ctx, t.h, rows...)
}

func (t *CampaignTable) GetByID(ctx context.Context, keys ...*CampaignID) (map[CampaignID]*CampaignRow, error) {
	return GetCampaignRowsByID(ctx, t.h, keys...)
}

func (t *CampaignTable) UpdateByID(ctx context.Context, changeset CampaignValues, keys ...*CampaignID) (int64, error) {
	return UpdateCampaignRowsByID(ctx, t.h, changeset, keys...)
}

func (t *CampaignTable) DeleteByID(ctx context.Context, keys ...*CampaignID) (int64, error) {
	return DeleteCampaignRowsByID(ctx, t.h, keys...)
}

type CampaignValues struct {
	ID      *string `json:"id"`
	PopName *string `json:"pop_name"`
	PopYear *int32  `json:"pop_year"`
}

// InsertCampaignRows inserts the rows into table "campaign"
func InsertCampaignRows(ctx context.Context, db SQLHandle, rows ...*CampaignRow) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLInsertCampaignRows, rows)
	if err != nil {
		return numRows, formatError("InsertCampaignRows", err)
	}
	return numRows, nil
}

// InsertReturningCampaignRows inserts the rows into table "campaign" and returns the rows.
func InsertReturningCampaignRows(ctx context.Context, db SQLHandle, inputs ...*CampaignRow) (numRows int, err error) {
	rows := CampaignRows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturningCampaignRows, rows)
	if err != nil {
		return numRows, formatError("InsertReturningCampaignRows", err)
	}
	return numRows, nil
}

// FindCampaignRows finds the rows matching the condition from table "campaign"
func FindCampaignRows(ctx context.Context, db SQLHandle, cond CampaignValues) (rows CampaignRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFindCampaignRows, cond); err != nil {
		return nil, formatError("FindCampaignRows", err)
	}
	return rows, nil
}

// DeleteCampaignRows deletes the rows matching the condition from table "campaign"
func DeleteCampaignRows(ctx context.Context, db SQLHandle, cond CampaignValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDeleteCampaignRows, cond); err != nil {
		return numRows, formatError("DeleteCampaignRows", err)
	}
	return numRows, nil
}

func UpdateCampaignRows(ctx context.Context, db SQLHandle, changeset, filter CampaignValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdateCampaignRows, changeset, filter); err != nil {
		return numRows, formatError("UpdateCampaignRows", err)
	}
	return numRows, nil
}

// CountCampaignRows counts the number of rows matching the condition from table "campaign"
func CountCampaignRows(ctx context.Context, db SQLHandle, cond CampaignValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, SQLCountCampaignRows, cond); err != nil {
		return 0, formatError("CountCampaignRows", err)
	}
	return count, nil
}

// SaveCampaignRows upserts the given rows for table "campaign" checking uniqueness by contstraint "campaign_pkey"
func SaveCampaignRows(ctx context.Context, db SQLHandle, rows ...*CampaignRow) (err error) {
	_, err = execWithJSONArgs(ctx, db, SQLSaveCampaignRows, rows)
	if err != nil {
		return formatError("SaveCampaignRows", err)
	}
	return nil
}

// SaveReturningCampaignRows upserts the given rows for table "campaign" checking uniqueness by contstraint "campaign_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningCampaignRows(ctx context.Context, db SQLHandle, inputs ...*CampaignRow) (err error) {
	rows := CampaignRows(inputs)
	_, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLSaveReturningCampaignRows, rows)
	if err != nil {
		return formatError("SaveReturningCampaignRows", err)
	}
	return nil
}

// GetCampaignRowsByID gets matching rows for given ID keys from table "campaign"
func GetCampaignRowsByID(ctx context.Context, db SQLHandle, keys ...*CampaignID) (rs map[CampaignID]*CampaignRow, err error) {
	ukm := make(map[CampaignID]struct{}, len(keys))
	for _, k := range keys {
		if k != nil {
			ukm[*k] = struct{}{}
		}
	}
	uks := make([]CampaignID, len(ukm))
	i := 0
	for k := range ukm {
		uks[i] = k
		i++
	}

	var r CampaignRow
	rs = make(map[CampaignID]*CampaignRow, len(uks))
	if _, err = queryWithJSONArgs(ctx, db, func(i int) []interface{} {
		if i > 0 {
			r := r
			rs[*r.KeyID()] = &r
		}
		return r.ReceiveRow()
	}, SQLGetCampaignRowsByID, uks); err != nil {
		return nil, formatError("GetCampaignRowsByID", err)
	}
	rs[*r.KeyID()] = &r
	return rs, nil
}

// DeleteCampaignRowsByID deletes matching rows by CampaignID keys from table "campaign"
func DeleteCampaignRowsByID(ctx context.Context, db SQLHandle, keys ...*CampaignID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLDeleteCampaignRowsByID, keys)
	if err != nil {
		return numRows, formatError("DeleteCampaignRowsByID", err)
	}
	return numRows, nil
}

// UpdateCampaignRowsByID deletes matching rows by CampaignID keys from table "campaign"
func UpdateCampaignRowsByID(ctx context.Context, db SQLHandle, changeset CampaignValues, keys ...*CampaignID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLUpdateCampaignRowsByID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateCampaignRowsByID", err)
	}
	return numRows, nil
}

func (r *CampaignRow) ReceiveRow() []interface{} {
	return []interface{}{&r.Data.ID, &r.Data.PopName, &r.Data.PopYear}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *CampaignRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(CampaignRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(CampaignRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *CampaignRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Data)
}

var (
	SQLFindCampaignRows = `
		WITH __f AS (SELECT "id", "pop_name", "pop_year" FROM json_populate_record(null::"wise"."campaign", $1))
		SELECT __t.id, __t.pop_name, __t.pop_year
		FROM "wise"."campaign" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."pop_name" IS NULL FROM __f) OR (SELECT __f."pop_name" = __t."pop_name" FROM __f))
			AND ((SELECT __f."pop_year" IS NULL FROM __f) OR (SELECT __f."pop_year" = __t."pop_year" FROM __f))`
	SQLCountCampaignRows = `
		WITH __f AS (SELECT "id", "pop_name", "pop_year" FROM json_populate_record(null::"wise"."campaign", $1))
		SELECT count(*) FROM "wise"."campaign" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."pop_name" IS NULL FROM __f) OR (SELECT __f."pop_name" = __t."pop_name" FROM __f))
			AND ((SELECT __f."pop_year" IS NULL FROM __f) OR (SELECT __f."pop_year" = __t."pop_year" FROM __f))`
	SQLReturningCampaignRows = `
		RETURNING "id", "pop_name", "pop_year"`
	SQLInsertCampaignRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."campaign", $1))
		INSERT INTO "wise"."campaign" AS __t ("id", "pop_name", "pop_year")
		SELECT 
			__v."id", 
			__v."pop_name", 
			__v."pop_year" FROM __v`
	SQLInsertReturningCampaignRows = SQLInsertCampaignRows + SQLReturningCampaignRows
	SQLDeleteCampaignRows          = `
		DELETE FROM "wise"."campaign" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS uuid) = __t."id")
			AND (($1::json->>'pop_name' IS NULL) OR CAST($1::json->>'pop_name' AS text) = __t."pop_name")
			AND (($1::json->>'pop_year' IS NULL) OR CAST($1::json->>'pop_year' AS integer) = __t."pop_year")`
	SQLDeleteReturningCampaignRows = SQLDeleteCampaignRows + SQLReturningCampaignRows
	SQLUpdateCampaignRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."campaign", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."campaign", $2))
		UPDATE "wise"."campaign" AS __t
		SET ("id", "pop_name", "pop_year") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."pop_name", __t."pop_name"), 
			COALESCE(__v."pop_year", __t."pop_year") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."pop_name" IS NULL FROM __f) OR (SELECT __f."pop_name" = __t."pop_name" FROM __f))
			AND ((SELECT __f."pop_year" IS NULL FROM __f) OR (SELECT __f."pop_year" = __t."pop_year" FROM __f))`
	SQLUpdateReturningCampaignRows = SQLUpdateCampaignRows + SQLReturningCampaignRows
	SQLReplaceCampaignRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."campaign", $1))
		UPDATE "wise"."campaign" AS __t
			SET ("id", "pop_name", "pop_year") = (SELECT 
				COALESCE(__v."id", __t."id"), 
				COALESCE(__v."pop_name", __t."pop_name"), 
				COALESCE(__v."pop_year", __t."pop_year")
			FROM __v WHERE __v."id" = __t."id")
		FROM __v WHERE __v."id" = __t."id"`
	SQLReplaceReturningCampaignRows = SQLReplaceCampaignRows + SQLReturningCampaignRows
	SQLSaveCampaignRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."campaign", $1))
		INSERT INTO "wise"."campaign" AS __t ("id", "pop_name", "pop_year")
		SELECT 
			__v."id", 
			__v."pop_name", 
			__v."pop_year" FROM __v
		ON CONFLICT ("id") DO UPDATE
		SET ("id", "pop_name", "pop_year") = (
			SELECT "id", "pop_name", "pop_year" FROM __v
			WHERE __v."id" = __t."id"
		)`
	SQLSaveReturningCampaignRows = SQLSaveCampaignRows + SQLReturningCampaignRows
	SQLGetCampaignRowsByID       = `
		WITH __key AS (SELECT DISTINCT "id" FROM json_populate_recordset(null::"wise"."campaign", $1))
		SELECT "id", "pop_name", "pop_year"
		FROM __key JOIN "wise"."campaign" AS __t USING ("id")
		`
	SQLUpdateCampaignRowsByID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."campaign", $1)),
		  __key AS (SELECT id FROM json_populate_recordset(null::"wise"."campaign", $2))
		UPDATE "wise"."campaign" AS __t
		SET ("id", "pop_name", "pop_year") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."pop_name", __t."pop_name"), 
			COALESCE(__v."pop_year", __t."pop_year")
		FROM __v)
		FROM __key WHERE (__key."id" = __t."id")`
	SQLDeleteCampaignRowsByID = `
		WITH __key AS (SELECT id FROM json_populate_recordset(null::"wise"."campaign", $1))
		DELETE FROM "wise"."campaign" AS __t USING __key WHERE (__key."id" = __t."id")`
	SQLDeleteReturningCampaignRowsByID = SQLDeleteCampaignRowsByID + SQLReturningCampaignRows
)

// PackageAggRow represents a row for table "package_agg"
type PackageAggRow struct {
	Data PackageAggData
}

type PackageAggData struct {
	ID        *string `json:"id"`
	Name      *string `json:"name"`
	Available *bool   `json:"available"`
	Count     *int64  `json:"count"`
}

func NewPackageAggRow(data PackageAggData) *PackageAggRow {
	return &PackageAggRow{data}
}

func NewPackageAggRows(data ...PackageAggData) PackageAggRows {
	rows := make(PackageAggRows, len(data))
	for i, d := range data {
		rows[i] = NewPackageAggRow(d)
	}
	return rows
}

// GetID gets value of column "id" from "package_agg" row
func (r *PackageAggRow) GetID() string { return *r.Data.ID }

// SetID sets value of column "id" in "package_agg" row
func (r *PackageAggRow) SetID(id string) { r.Data.ID = &id }

// ClearID sets value of column "id" null in "package_agg" row
func (r *PackageAggRow) ClearID() { r.Data.ID = nil }

// HasValidID checks to value of column "id" is not null
func (r *PackageAggRow) HasValidID() bool { return r.Data.ID != nil }

// GetName gets value of column "name" from "package_agg" row
func (r *PackageAggRow) GetName() string { return *r.Data.Name }

// SetName sets value of column "name" in "package_agg" row
func (r *PackageAggRow) SetName(name string) { r.Data.Name = &name }

// ClearName sets value of column "name" null in "package_agg" row
func (r *PackageAggRow) ClearName() { r.Data.Name = nil }

// HasValidName checks to value of column "name" is not null
func (r *PackageAggRow) HasValidName() bool { return r.Data.Name != nil }

// GetAvailable gets value of column "available" from "package_agg" row
func (r *PackageAggRow) GetAvailable() bool { return *r.Data.Available }

// SetAvailable sets value of column "available" in "package_agg" row
func (r *PackageAggRow) SetAvailable(available bool) { r.Data.Available = &available }

// ClearAvailable sets value of column "available" null in "package_agg" row
func (r *PackageAggRow) ClearAvailable() { r.Data.Available = nil }

// HasValidAvailable checks to value of column "available" is not null
func (r *PackageAggRow) HasValidAvailable() bool { return r.Data.Available != nil }

// GetCount gets value of column "count" from "package_agg" row
func (r *PackageAggRow) GetCount() int64 { return *r.Data.Count }

// SetCount sets value of column "count" in "package_agg" row
func (r *PackageAggRow) SetCount(count int64) { r.Data.Count = &count }

// ClearCount sets value of column "count" null in "package_agg" row
func (r *PackageAggRow) ClearCount() { r.Data.Count = nil }

// HasValidCount checks to value of column "count" is not null
func (r *PackageAggRow) HasValidCount() bool { return r.Data.Count != nil }

// PackageAggRows represents multiple rows for table "package_agg"
type PackageAggRows []*PackageAggRow

// NewPackageAggTable(h SQLHandle) creates new PackageAggTable
func NewPackageAggTable(h SQLHandle) *PackageAggTable {
	return &PackageAggTable{h}
}

// PackageAggTable provides access methods for table "package_agg"
type PackageAggTable struct {
	h SQLHandle
}

func (t *PackageAggTable) Find(ctx context.Context, filter PackageAggValues) (PackageAggRows, error) {
	return FindPackageAggRows(ctx, t.h, filter)
}

func (t *PackageAggTable) Count(ctx context.Context, filter PackageAggValues) (int, error) {
	return CountPackageAggRows(ctx, t.h, filter)
}

func (t *PackageAggTable) Update(ctx context.Context, changeset, filter PackageAggValues) (int64, error) {
	return UpdatePackageAggRows(ctx, t.h, changeset, filter)
}

func (t *PackageAggTable) Insert(ctx context.Context, rows ...*PackageAggRow) (int, error) {
	return InsertReturningPackageAggRows(ctx, t.h, rows...)
}

func (t *PackageAggTable) Delete(ctx context.Context, filter PackageAggValues) (int64, error) {
	return DeletePackageAggRows(ctx, t.h, filter)
}

type PackageAggValues struct {
	ID        *string `json:"id"`
	Name      *string `json:"name"`
	Available *bool   `json:"available"`
	Count     *int64  `json:"count"`
}

// InsertPackageAggRows inserts the rows into table "package_agg"
func InsertPackageAggRows(ctx context.Context, db SQLHandle, rows ...*PackageAggRow) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, SQLInsertPackageAggRows, rows)
	if err != nil {
		return numRows, formatError("InsertPackageAggRows", err)
	}
	return numRows, nil
}

// InsertReturningPackageAggRows inserts the rows into table "package_agg" and returns the rows.
func InsertReturningPackageAggRows(ctx context.Context, db SQLHandle, inputs ...*PackageAggRow) (numRows int, err error) {
	rows := PackageAggRows(inputs)
	numRows, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLInsertReturningPackageAggRows, rows)
	if err != nil {
		return numRows, formatError("InsertReturningPackageAggRows", err)
	}
	return numRows, nil
}

// FindPackageAggRows finds the rows matching the condition from table "package_agg"
func FindPackageAggRows(ctx context.Context, db SQLHandle, cond PackageAggValues) (rows PackageAggRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, SQLFindPackageAggRows, cond); err != nil {
		return nil, formatError("FindPackageAggRows", err)
	}
	return rows, nil
}

// DeletePackageAggRows deletes the rows matching the condition from table "package_agg"
func DeletePackageAggRows(ctx context.Context, db SQLHandle, cond PackageAggValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLDeletePackageAggRows, cond); err != nil {
		return numRows, formatError("DeletePackageAggRows", err)
	}
	return numRows, nil
}

func UpdatePackageAggRows(ctx context.Context, db SQLHandle, changeset, filter PackageAggValues) (numRows int64, err error) {
	if numRows, err = execWithJSONArgs(ctx, db, SQLUpdatePackageAggRows, changeset, filter); err != nil {
		return numRows, formatError("UpdatePackageAggRows", err)
	}
	return numRows, nil
}

// CountPackageAggRows counts the number of rows matching the condition from table "package_agg"
func CountPackageAggRows(ctx context.Context, db SQLHandle, cond PackageAggValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, SQLCountPackageAggRows, cond); err != nil {
		return 0, formatError("CountPackageAggRows", err)
	}
	return count, nil
}

func (r *PackageAggRow) ReceiveRow() []interface{} {
	return []interface{}{&r.Data.ID, &r.Data.Name, &r.Data.Available, &r.Data.Count}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PackageAggRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PackageAggRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PackageAggRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PackageAggRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.Data)
}

var (
	SQLFindPackageAggRows = `
		WITH __f AS (SELECT "id", "name", "available", "count" FROM json_populate_record(null::"wise"."package_agg", $1))
		SELECT __t.id, __t.name, __t.available, __t.count
		FROM "wise"."package_agg" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))
			AND ((SELECT __f."count" IS NULL FROM __f) OR (SELECT __f."count" = __t."count" FROM __f))`
	SQLCountPackageAggRows = `
		WITH __f AS (SELECT "id", "name", "available", "count" FROM json_populate_record(null::"wise"."package_agg", $1))
		SELECT count(*) FROM "wise"."package_agg" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))
			AND ((SELECT __f."count" IS NULL FROM __f) OR (SELECT __f."count" = __t."count" FROM __f))`
	SQLReturningPackageAggRows = `
		RETURNING "id", "name", "available", "count"`
	SQLInsertPackageAggRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package_agg", $1))
		INSERT INTO "wise"."package_agg" AS __t ("id", "name", "available")
		SELECT 
			__v."id", 
			__v."name", 
			__v."available" FROM __v`
	SQLInsertReturningPackageAggRows = SQLInsertPackageAggRows + SQLReturningPackageAggRows
	SQLDeletePackageAggRows          = `
		DELETE FROM "wise"."package_agg" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS uuid) = __t."id")
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS text) = __t."name")
			AND (($1::json->>'available' IS NULL) OR CAST($1::json->>'available' AS boolean) = __t."available")
			AND (($1::json->>'count' IS NULL) OR CAST($1::json->>'count' AS bigint) = __t."count")`
	SQLDeleteReturningPackageAggRows = SQLDeletePackageAggRows + SQLReturningPackageAggRows
	SQLUpdatePackageAggRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package_agg", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."package_agg", $2))
		UPDATE "wise"."package_agg" AS __t
		SET ("id", "name", "available") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."available", __t."available") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))
			AND ((SELECT __f."count" IS NULL FROM __f) OR (SELECT __f."count" = __t."count" FROM __f))`
	SQLUpdateReturningPackageAggRows = SQLUpdatePackageAggRows + SQLReturningPackageAggRows
)

func execWithJSONArgs(ctx context.Context, db SQLHandle, sql string, args ...interface{}) (numRows int64, err error) {
	bArgs := make([]interface{}, len(args))
	for i, arg := range args {
		if bArgs[i], err = json.Marshal(arg); err != nil {
			return 0, err
		}
	}
	return db.ExecAndCount(ctx, sql, bArgs...)
}

func queryWithJSONArgs(ctx context.Context, db SQLHandle, receive func(int) []interface{}, sql string, args ...interface{}) (numRows int, err error) {
	bArgs := make([]interface{}, len(args))
	for i, arg := range args {
		if bArgs[i], err = json.Marshal(arg); err != nil {
			return 0, err
		}
	}
	return db.QueryAndReceive(ctx, receive, sql, bArgs...)
}

func formatError(methodName string, err error) error {
	return fmt.Errorf("%w(%s, %s)", ErrPGMG, methodName, err.Error())
}

var ErrPGMG = fmt.Errorf("errPGMG")

type SQLHandle interface {
	QueryAndReceive(ctx context.Context, receiver func(int) []interface{}, sql string, args ...interface{}) (int, error)
	ExecAndCount(ctx context.Context, sql string, args ...interface{}) (int64, error)
}
