// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package schema

import (
	"context"
	"encoding/json"
	"fmt"
	"time"
)

// PackageRow represents a row for table "package"
type PackageRow struct {
	v PackageData
}

type PackageData struct {
	ID        string `json:"id"`
	Name      string `json:"name"`
	Available *bool  `json:"available"`
}

func NewPackageRow(data PackageData) *PackageRow {
	return &PackageRow{data}
}

func NewPackageRows(data ...PackageData) PackageRows {
	rows := make(PackageRows, len(data))
	for i, d := range data {
		rows[i] = NewPackageRow(d)
	}
	return rows
}

// GetID gets value of column "id" from "package" row
func (r *PackageRow) GetID() string { return r.v.ID }

// SetID sets value of column "id" in "package" row
func (r *PackageRow) SetID(id string) { r.v.ID = id }

// GetName gets value of column "name" from "package" row
func (r *PackageRow) GetName() string { return r.v.Name }

// SetName sets value of column "name" in "package" row
func (r *PackageRow) SetName(name string) { r.v.Name = name }

// GetAvailable gets value of column "available" from "package" row
func (r *PackageRow) GetAvailable() bool { return *r.v.Available }

// SetAvailable sets value of column "available" in "package" row
func (r *PackageRow) SetAvailable(available bool) { r.v.Available = &available }

// ClearAvailable sets value of column "available" null in "package" row
func (r *PackageRow) ClearAvailable() { r.v.Available = nil }

// HasValidAvailable checks to value of column "available" is not null
func (r *PackageRow) HasValidAvailable() bool { return r.v.Available != nil }

// PackageID represents key defined by PRIMARY KEY constraint "package_pkey" for table "package"
type PackageID struct {
	ID string `json:"id"`
}

func (r *PackageRow) KeyID() PackageID {
	return PackageID{r.GetID()}
}

// PackageRows represents multiple rows for table "package"
type PackageRows []*PackageRow

// PackageIDKeyset is a set of key PackageID
type PackageIDKeyset map[PackageID]struct{}

func (rs PackageRows) KeyID() (keys PackageIDKeyset) {
	keys = make(PackageIDKeyset)
	for _, r := range rs {
		keys[r.KeyID()] = struct{}{}
	}
	return keys
}

// NewPackageTable(h SQLHandle) creates new PackageTable
func NewPackageTable(h SQLHandle) *PackageTable {
	return &PackageTable{h}
}

// PackageTable provides access methods for table "package"
type PackageTable struct {
	h SQLHandle
}

func (t *PackageTable) Find(ctx context.Context, filter PackageValues) (PackageRows, error) {
	return FindPackageRows(ctx, t.h, filter)
}

func (t *PackageTable) Count(ctx context.Context, filter PackageValues) (int, error) {
	return CountPackageRows(ctx, t.h, filter)
}

func (t *PackageTable) Update(ctx context.Context, changeset, filter PackageValues) (int64, error) {
	return UpdatePackageRows(ctx, t.h, changeset, filter)
}

func (t *PackageTable) Insert(ctx context.Context, rows ...*PackageRow) (int, error) {
	return InsertReturningPackageRows(ctx, t.h, rows...)
}

func (t *PackageTable) Delete(ctx context.Context, filter PackageValues) (int64, error) {
	return DeletePackageRows(ctx, t.h, filter)
}

func (t *PackageTable) Save(ctx context.Context, rows ...*PackageRow) error {
	return SaveReturningPackageRows(ctx, t.h, rows...)
}

func (t *PackageTable) GetByID(ctx context.Context, keys ...PackageID) (PackageRows, error) {
	return GetPackageRowsByID(ctx, t.h, keys...)
}

func (t *PackageTable) UpdateByID(ctx context.Context, changeset PackageValues, keys ...PackageID) (int64, error) {
	return UpdatePackageRowsByID(ctx, t.h, changeset, keys...)
}

func (t *PackageTable) DeleteByID(ctx context.Context, keys ...PackageID) (int64, error) {
	return DeletePackageRowsByID(ctx, t.h, keys...)
}

type PackageValues struct {
	ID        *string `json:"id"`
	Name      *string `json:"name"`
	Available *bool   `json:"available"`
}

// InsertPackageRows inserts the rows into table "package"
func InsertPackageRows(ctx context.Context, db SQLHandle, rows ...*PackageRow) (affected int64, err error) {
	affected, err = execWithJSONArgs(ctx, db, sqlInsertPackageRows, rows)
	if err != nil {
		return affected, formatError("InsertPackageRows", err)
	}
	return affected, nil
}

// InsertReturningPackageRows inserts the rows into table "package" and returns the rows.
func InsertReturningPackageRows(ctx context.Context, db SQLHandle, inputs ...*PackageRow) (affected int, err error) {
	rows := PackageRows(inputs)
	affected, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlInsertReturningPackageRows, rows)
	if err != nil {
		return affected, formatError("InsertReturningPackageRows", err)
	}
	return affected, nil
}

// FindPackageRows finds the rows matching the condition from table "package"
func FindPackageRows(ctx context.Context, db SQLHandle, cond PackageValues) (rows PackageRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlFindPackageRows, cond); err != nil {
		return nil, err
	}
	return rows, nil
}

// DeletePackageRows deletes the rows matching the condition from table "package"
func DeletePackageRows(ctx context.Context, db SQLHandle, cond PackageValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlDeletePackageRows, cond)
}

func UpdatePackageRows(ctx context.Context, db SQLHandle, changeset, filter PackageValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlUpdatePackageRows, changeset, filter)
}

// CountPackageRows counts the number of rows matching the condition from table "package"
func CountPackageRows(ctx context.Context, db SQLHandle, cond PackageValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, sqlCountPackageRows, cond); err != nil {
		return 0, err
	}
	return count, nil
}

// SavePackageRows upserts the given rows for table "package" checking uniqueness by contstraint "package_pkey"
func SavePackageRows(ctx context.Context, db SQLHandle, rows ...*PackageRow) (err error) {
	numRows, err := execWithJSONArgs(ctx, db, sqlSavePackageRows, rows)
	if err != nil {
		return formatError("Save", err)
	}
	if int64(len(rows)) != numRows {
		return formatError("Save", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// SaveReturningPackageRows upserts the given rows for table "package" checking uniqueness by contstraint "package_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningPackageRows(ctx context.Context, db SQLHandle, inputs ...*PackageRow) (err error) {
	rows := PackageRows(inputs)
	numRows, err := queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlSaveReturningPackageRows, rows)
	if err != nil {
		return formatError("SaveReturning", err)
	}
	if len(rows) != numRows {
		return formatError("SaveReturning", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// GetPackageRowsByID gets matching rows for given ID keys from table "package"
func GetPackageRowsByID(ctx context.Context, db SQLHandle, keys ...PackageID) (rows PackageRows, err error) {
	rows = make(PackageRows, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlGetPackageRowsByID, keys); err != nil {
		return nil, formatError("GetPackageRowsByID", err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].KeyID() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// DeletePackageRowsByID deletes matching rows by PackageID keys from table "package"
func DeletePackageRowsByID(ctx context.Context, db SQLHandle, keys ...PackageID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlDeletePackageRowsByID, keys)
	if err != nil {
		return numRows, formatError("DeleteByID", err)
	}
	return numRows, nil
}

// UpdatePackageRowsByID deletes matching rows by PackageID keys from table "package"
func UpdatePackageRowsByID(ctx context.Context, db SQLHandle, changeset PackageValues, keys ...PackageID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlUpdatePackageRowsByID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateByID", err)
	}
	return numRows, nil
}

func (r *PackageRow) ReceiveRow() []interface{} {
	return []interface{}{&r.v.ID, &r.v.Name, &r.v.Available}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PackageRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PackageRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PackageRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PackageRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.v)
}

func (keyset PackageIDKeyset) Keys() (keys []PackageID) {
	for k := range keyset {
		keys = append(keys, k)
	}
	return keys
}

func (keyset PackageIDKeyset) Add(keys ...PackageID) {
	for _, k := range keys {
		keyset[k] = struct{}{}
	}
}

func (keyset PackageIDKeyset) Remove(keys ...PackageID) {
	for _, k := range keys {
		delete(keyset, k)
	}
}

var (
	sqlFindPackageRows = `
		WITH __f AS (SELECT "id", "name", "available" FROM json_populate_record(null::"wise"."package", $1))
		SELECT __t.id, __t.name, __t.available
		FROM "wise"."package" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))`
	sqlCountPackageRows = `
		WITH __f AS (SELECT "id", "name", "available" FROM json_populate_record(null::"wise"."package", $1))
		SELECT count(*) FROM "wise"."package" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))`
	sqlReturningPackageRows = `
		RETURNING "id", "name", "available"`
	sqlInsertPackageRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package", $1))
		INSERT INTO "wise"."package" AS __t ("id", "name", "available")
		SELECT 
			__v."id", 
			__v."name", 
			COALESCE(__v."available", true) FROM __v`
	sqlInsertReturningPackageRows = sqlInsertPackageRows + sqlReturningPackageRows
	sqlDeletePackageRows          = `
		DELETE FROM "wise"."package" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS uuid) = __t."id")
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS text) = __t."name")
			AND (($1::json->>'available' IS NULL) OR CAST($1::json->>'available' AS boolean) = __t."available")`
	sqlDeleteReturningPackageRows = sqlDeletePackageRows + sqlReturningPackageRows
	sqlUpdatePackageRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."package", $2))
		UPDATE "wise"."package" AS __t
		SET ("id", "name", "available") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."available", __t."available") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))`
	sqlUpdateReturningPackageRows = sqlUpdatePackageRows + sqlReturningPackageRows
	sqlReplacePackageRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package", $1))
		UPDATE "wise"."package" AS __t
			SET ("id", "name", "available") = (SELECT 
				COALESCE(__v."id", __t."id"), 
				COALESCE(__v."name", __t."name"), 
				COALESCE(__v."available", __t."available")
			FROM __v WHERE __v."id" = __t."id")
		FROM __v WHERE __v."id" = __t."id"`
	sqlReplaceReturningPackageRows = sqlReplacePackageRows + sqlReturningPackageRows
	sqlSavePackageRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package", $1))
		INSERT INTO "wise"."package" AS __t ("id", "name", "available")
		SELECT 
			__v."id", 
			__v."name", 
			COALESCE(__v."available", true) FROM __v
		ON CONFLICT ("id") DO UPDATE
		SET ("id", "name", "available") = (
			SELECT "id", "name", "available" FROM __v
			WHERE __v."id" = __t."id"
		)`
	sqlSaveReturningPackageRows = sqlSavePackageRows + sqlReturningPackageRows
	sqlGetPackageRowsByID       = `
		WITH __key AS (SELECT ROW_NUMBER() over () __idx, "id" FROM json_populate_recordset(null::"wise"."package", $1))
		SELECT "id", "name", "available"
		FROM __key JOIN "wise"."package" AS __t USING ("id")
		ORDER BY __idx`
	sqlUpdatePackageRowsByID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package", $1)),
		  __key AS (SELECT id FROM json_populate_recordset(null::"wise"."package", $2))
		UPDATE "wise"."package" AS __t
		SET ("id", "name", "available") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."available", __t."available")
		FROM __v)
		FROM __key WHERE (__key."id" = __t."id")`
	sqlDeletePackageRowsByID = `
		WITH __key AS (SELECT id FROM json_populate_recordset(null::"wise"."package", $1))
		DELETE FROM "wise"."package" AS __t USING __key WHERE (__key."id" = __t."id")`
	sqlDeleteReturningPackageRowsByID = sqlDeletePackageRowsByID + sqlReturningPackageRows
)

// PackageProductRow represents a row for table "package_product"
type PackageProductRow struct {
	v PackageProductData
}

type PackageProductData struct {
	PackageID string `json:"package_id"`
	ProductID int32  `json:"product_id"`
}

func NewPackageProductRow(data PackageProductData) *PackageProductRow {
	return &PackageProductRow{data}
}

func NewPackageProductRows(data ...PackageProductData) PackageProductRows {
	rows := make(PackageProductRows, len(data))
	for i, d := range data {
		rows[i] = NewPackageProductRow(d)
	}
	return rows
}

// GetPackageID gets value of column "package_id" from "package_product" row
func (r *PackageProductRow) GetPackageID() string { return r.v.PackageID }

// SetPackageID sets value of column "package_id" in "package_product" row
func (r *PackageProductRow) SetPackageID(packageID string) { r.v.PackageID = packageID }

// GetProductID gets value of column "product_id" from "package_product" row
func (r *PackageProductRow) GetProductID() int32 { return r.v.ProductID }

// SetProductID sets value of column "product_id" in "package_product" row
func (r *PackageProductRow) SetProductID(productID int32) { r.v.ProductID = productID }

// PackageProductPackageIDProductID represents key defined by UNIQUE constraint "package_product_package_id_product_id_key" for table "package_product"
type PackageProductPackageIDProductID struct {
	PackageID string `json:"package_id"`
	ProductID int32  `json:"product_id"`
}

func (r *PackageProductRow) KeyPackageIDProductID() PackageProductPackageIDProductID {
	return PackageProductPackageIDProductID{r.GetPackageID(), r.GetProductID()}
}

// PackageProductRows represents multiple rows for table "package_product"
type PackageProductRows []*PackageProductRow

// PackageProductPackageIDProductIDKeyset is a set of key PackageProductPackageIDProductID
type PackageProductPackageIDProductIDKeyset map[PackageProductPackageIDProductID]struct{}

func (rs PackageProductRows) KeyPackageIDProductID() (keys PackageProductPackageIDProductIDKeyset) {
	keys = make(PackageProductPackageIDProductIDKeyset)
	for _, r := range rs {
		keys[r.KeyPackageIDProductID()] = struct{}{}
	}
	return keys
}

func (r *PackageProductRow) RefPackageID() PackageID {
	return PackageID{r.GetPackageID()}
}

func (rs PackageProductRows) RefPackageID() (keys PackageIDKeyset) {
	keys = make(PackageIDKeyset)
	for _, r := range rs {
		keys[r.RefPackageID()] = struct{}{}
	}
	return keys
}
func (r *PackageProductRow) RefProductID() ProductID {
	return ProductID{r.GetProductID()}
}

func (rs PackageProductRows) RefProductID() (keys ProductIDKeyset) {
	keys = make(ProductIDKeyset)
	for _, r := range rs {
		keys[r.RefProductID()] = struct{}{}
	}
	return keys
}

// NewPackageProductTable(h SQLHandle) creates new PackageProductTable
func NewPackageProductTable(h SQLHandle) *PackageProductTable {
	return &PackageProductTable{h}
}

// PackageProductTable provides access methods for table "package_product"
type PackageProductTable struct {
	h SQLHandle
}

func (t *PackageProductTable) Find(ctx context.Context, filter PackageProductValues) (PackageProductRows, error) {
	return FindPackageProductRows(ctx, t.h, filter)
}

func (t *PackageProductTable) Count(ctx context.Context, filter PackageProductValues) (int, error) {
	return CountPackageProductRows(ctx, t.h, filter)
}

func (t *PackageProductTable) Update(ctx context.Context, changeset, filter PackageProductValues) (int64, error) {
	return UpdatePackageProductRows(ctx, t.h, changeset, filter)
}

func (t *PackageProductTable) Insert(ctx context.Context, rows ...*PackageProductRow) (int, error) {
	return InsertReturningPackageProductRows(ctx, t.h, rows...)
}

func (t *PackageProductTable) Delete(ctx context.Context, filter PackageProductValues) (int64, error) {
	return DeletePackageProductRows(ctx, t.h, filter)
}

func (t *PackageProductTable) Save(ctx context.Context, rows ...*PackageProductRow) error {
	return SaveReturningPackageProductRows(ctx, t.h, rows...)
}

func (t *PackageProductTable) GetByPackageIDProductID(ctx context.Context, keys ...PackageProductPackageIDProductID) (PackageProductRows, error) {
	return GetPackageProductRowsByPackageIDProductID(ctx, t.h, keys...)
}

func (t *PackageProductTable) UpdateByPackageIDProductID(ctx context.Context, changeset PackageProductValues, keys ...PackageProductPackageIDProductID) (int64, error) {
	return UpdatePackageProductRowsByPackageIDProductID(ctx, t.h, changeset, keys...)
}

func (t *PackageProductTable) DeleteByPackageIDProductID(ctx context.Context, keys ...PackageProductPackageIDProductID) (int64, error) {
	return DeletePackageProductRowsByPackageIDProductID(ctx, t.h, keys...)
}

type PackageProductValues struct {
	PackageID *string `json:"package_id"`
	ProductID *int32  `json:"product_id"`
}

// InsertPackageProductRows inserts the rows into table "package_product"
func InsertPackageProductRows(ctx context.Context, db SQLHandle, rows ...*PackageProductRow) (affected int64, err error) {
	affected, err = execWithJSONArgs(ctx, db, sqlInsertPackageProductRows, rows)
	if err != nil {
		return affected, formatError("InsertPackageProductRows", err)
	}
	return affected, nil
}

// InsertReturningPackageProductRows inserts the rows into table "package_product" and returns the rows.
func InsertReturningPackageProductRows(ctx context.Context, db SQLHandle, inputs ...*PackageProductRow) (affected int, err error) {
	rows := PackageProductRows(inputs)
	affected, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlInsertReturningPackageProductRows, rows)
	if err != nil {
		return affected, formatError("InsertReturningPackageProductRows", err)
	}
	return affected, nil
}

// FindPackageProductRows finds the rows matching the condition from table "package_product"
func FindPackageProductRows(ctx context.Context, db SQLHandle, cond PackageProductValues) (rows PackageProductRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlFindPackageProductRows, cond); err != nil {
		return nil, err
	}
	return rows, nil
}

// DeletePackageProductRows deletes the rows matching the condition from table "package_product"
func DeletePackageProductRows(ctx context.Context, db SQLHandle, cond PackageProductValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlDeletePackageProductRows, cond)
}

func UpdatePackageProductRows(ctx context.Context, db SQLHandle, changeset, filter PackageProductValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlUpdatePackageProductRows, changeset, filter)
}

// CountPackageProductRows counts the number of rows matching the condition from table "package_product"
func CountPackageProductRows(ctx context.Context, db SQLHandle, cond PackageProductValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, sqlCountPackageProductRows, cond); err != nil {
		return 0, err
	}
	return count, nil
}

// SavePackageProductRows upserts the given rows for table "package_product" checking uniqueness by contstraint "package_product_package_id_product_id_key"
func SavePackageProductRows(ctx context.Context, db SQLHandle, rows ...*PackageProductRow) (err error) {
	numRows, err := execWithJSONArgs(ctx, db, sqlSavePackageProductRows, rows)
	if err != nil {
		return formatError("Save", err)
	}
	if int64(len(rows)) != numRows {
		return formatError("Save", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// SaveReturningPackageProductRows upserts the given rows for table "package_product" checking uniqueness by contstraint "package_product_package_id_product_id_key"
// It returns the new values and scan them into given row references.
func SaveReturningPackageProductRows(ctx context.Context, db SQLHandle, inputs ...*PackageProductRow) (err error) {
	rows := PackageProductRows(inputs)
	numRows, err := queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlSaveReturningPackageProductRows, rows)
	if err != nil {
		return formatError("SaveReturning", err)
	}
	if len(rows) != numRows {
		return formatError("SaveReturning", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// GetPackageProductRowsByPackageIDProductID gets matching rows for given PackageIDProductID keys from table "package_product"
func GetPackageProductRowsByPackageIDProductID(ctx context.Context, db SQLHandle, keys ...PackageProductPackageIDProductID) (rows PackageProductRows, err error) {
	rows = make(PackageProductRows, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlGetPackageProductRowsByPackageIDProductID, keys); err != nil {
		return nil, formatError("GetPackageProductRowsByPackageIDProductID", err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].KeyPackageIDProductID() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// DeletePackageProductRowsByPackageIDProductID deletes matching rows by PackageProductPackageIDProductID keys from table "package_product"
func DeletePackageProductRowsByPackageIDProductID(ctx context.Context, db SQLHandle, keys ...PackageProductPackageIDProductID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlDeletePackageProductRowsByPackageIDProductID, keys)
	if err != nil {
		return numRows, formatError("DeleteByPackageIDProductID", err)
	}
	return numRows, nil
}

// UpdatePackageProductRowsByPackageIDProductID deletes matching rows by PackageProductPackageIDProductID keys from table "package_product"
func UpdatePackageProductRowsByPackageIDProductID(ctx context.Context, db SQLHandle, changeset PackageProductValues, keys ...PackageProductPackageIDProductID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlUpdatePackageProductRowsByPackageIDProductID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateByPackageIDProductID", err)
	}
	return numRows, nil
}

func (r *PackageProductRow) ReceiveRow() []interface{} {
	return []interface{}{&r.v.PackageID, &r.v.ProductID}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PackageProductRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PackageProductRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PackageProductRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PackageProductRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.v)
}

func (keyset PackageProductPackageIDProductIDKeyset) Keys() (keys []PackageProductPackageIDProductID) {
	for k := range keyset {
		keys = append(keys, k)
	}
	return keys
}

func (keyset PackageProductPackageIDProductIDKeyset) Add(keys ...PackageProductPackageIDProductID) {
	for _, k := range keys {
		keyset[k] = struct{}{}
	}
}

func (keyset PackageProductPackageIDProductIDKeyset) Remove(keys ...PackageProductPackageIDProductID) {
	for _, k := range keys {
		delete(keyset, k)
	}
}

var (
	sqlFindPackageProductRows = `
		WITH __f AS (SELECT "package_id", "product_id" FROM json_populate_record(null::"wise"."package_product", $1))
		SELECT __t.package_id, __t.product_id
		FROM "wise"."package_product" AS __t
		WHERE ((SELECT __f."package_id" IS NULL FROM __f) OR (SELECT __f."package_id" = __t."package_id" FROM __f))
			AND ((SELECT __f."product_id" IS NULL FROM __f) OR (SELECT __f."product_id" = __t."product_id" FROM __f))`
	sqlCountPackageProductRows = `
		WITH __f AS (SELECT "package_id", "product_id" FROM json_populate_record(null::"wise"."package_product", $1))
		SELECT count(*) FROM "wise"."package_product" AS __t
		WHERE ((SELECT __f."package_id" IS NULL FROM __f) OR (SELECT __f."package_id" = __t."package_id" FROM __f))
			AND ((SELECT __f."product_id" IS NULL FROM __f) OR (SELECT __f."product_id" = __t."product_id" FROM __f))`
	sqlReturningPackageProductRows = `
		RETURNING "package_id", "product_id"`
	sqlInsertPackageProductRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package_product", $1))
		INSERT INTO "wise"."package_product" AS __t ("package_id", "product_id")
		SELECT 
			__v."package_id", 
			__v."product_id" FROM __v`
	sqlInsertReturningPackageProductRows = sqlInsertPackageProductRows + sqlReturningPackageProductRows
	sqlDeletePackageProductRows          = `
		DELETE FROM "wise"."package_product" AS __t
		WHERE TRUE
			AND (($1::json->>'package_id' IS NULL) OR CAST($1::json->>'package_id' AS uuid) = __t."package_id")
			AND (($1::json->>'product_id' IS NULL) OR CAST($1::json->>'product_id' AS integer) = __t."product_id")`
	sqlDeleteReturningPackageProductRows = sqlDeletePackageProductRows + sqlReturningPackageProductRows
	sqlUpdatePackageProductRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package_product", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."package_product", $2))
		UPDATE "wise"."package_product" AS __t
		SET ("package_id", "product_id") = (SELECT 
			COALESCE(__v."package_id", __t."package_id"), 
			COALESCE(__v."product_id", __t."product_id") FROM __v)
		WHERE ((SELECT __f."package_id" IS NULL FROM __f) OR (SELECT __f."package_id" = __t."package_id" FROM __f))
			AND ((SELECT __f."product_id" IS NULL FROM __f) OR (SELECT __f."product_id" = __t."product_id" FROM __f))`
	sqlUpdateReturningPackageProductRows = sqlUpdatePackageProductRows + sqlReturningPackageProductRows
	sqlReplacePackageProductRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package_product", $1))
		UPDATE "wise"."package_product" AS __t
			SET ("package_id", "product_id") = (SELECT 
				COALESCE(__v."package_id", __t."package_id"), 
				COALESCE(__v."product_id", __t."product_id")
			FROM __v WHERE __v."package_id" = __t."package_id" AND __v."product_id" = __t."product_id")
		FROM __v WHERE __v."package_id" = __t."package_id" AND __v."product_id" = __t."product_id"`
	sqlReplaceReturningPackageProductRows = sqlReplacePackageProductRows + sqlReturningPackageProductRows
	sqlSavePackageProductRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package_product", $1))
		INSERT INTO "wise"."package_product" AS __t ("package_id", "product_id")
		SELECT 
			__v."package_id", 
			__v."product_id" FROM __v
		ON CONFLICT ("package_id", "product_id") DO UPDATE
		SET ("package_id", "product_id") = (
			SELECT "package_id", "product_id" FROM __v
			WHERE __v."package_id" = __t."package_id"
				AND __v."product_id" = __t."product_id"
		)`
	sqlSaveReturningPackageProductRows           = sqlSavePackageProductRows + sqlReturningPackageProductRows
	sqlGetPackageProductRowsByPackageIDProductID = `
		WITH __key AS (SELECT ROW_NUMBER() over () __idx, "package_id", "product_id" FROM json_populate_recordset(null::"wise"."package_product", $1))
		SELECT "package_id", "product_id"
		FROM __key JOIN "wise"."package_product" AS __t USING ("package_id", "product_id")
		ORDER BY __idx`
	sqlUpdatePackageProductRowsByPackageIDProductID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package_product", $1)),
		  __key AS (SELECT package_id, product_id FROM json_populate_recordset(null::"wise"."package_product", $2))
		UPDATE "wise"."package_product" AS __t
		SET ("package_id", "product_id") = (SELECT
			COALESCE(__v."package_id", __t."package_id"), 
			COALESCE(__v."product_id", __t."product_id")
		FROM __v)
		FROM __key WHERE (__key."package_id" = __t."package_id")AND (__key."product_id" = __t."product_id")`
	sqlDeletePackageProductRowsByPackageIDProductID = `
		WITH __key AS (SELECT package_id, product_id FROM json_populate_recordset(null::"wise"."package_product", $1))
		DELETE FROM "wise"."package_product" AS __t USING __key WHERE (__key."package_id" = __t."package_id") AND (__key."product_id" = __t."product_id")`
	sqlDeleteReturningPackageProductRowsByPackageIDProductID = sqlDeletePackageProductRowsByPackageIDProductID + sqlReturningPackageProductRows
)

// ProductRow represents a row for table "product"
type ProductRow struct {
	v ProductData
}

type ProductData struct {
	ID      *int32     `json:"id"`
	Price   string     `json:"price"`
	Name    string     `json:"name"`
	Alias   string     `json:"alias"`
	Stocked time.Time  `json:"stocked"`
	Sold    *time.Time `json:"sold"`
}

func NewProductRow(data ProductData) *ProductRow {
	return &ProductRow{data}
}

func NewProductRows(data ...ProductData) ProductRows {
	rows := make(ProductRows, len(data))
	for i, d := range data {
		rows[i] = NewProductRow(d)
	}
	return rows
}

// GetID gets value of column "id" from "product" row
func (r *ProductRow) GetID() int32 { return *r.v.ID }

// SetID sets value of column "id" in "product" row
func (r *ProductRow) SetID(id int32) { r.v.ID = &id }

// ClearID sets value of column "id" null in "product" row
func (r *ProductRow) ClearID() { r.v.ID = nil }

// HasValidID checks to value of column "id" is not null
func (r *ProductRow) HasValidID() bool { return r.v.ID != nil }

// GetPrice gets value of column "price" from "product" row
func (r *ProductRow) GetPrice() string { return r.v.Price }

// SetPrice sets value of column "price" in "product" row
func (r *ProductRow) SetPrice(price string) { r.v.Price = price }

// GetName gets value of column "name" from "product" row
func (r *ProductRow) GetName() string { return r.v.Name }

// SetName sets value of column "name" in "product" row
func (r *ProductRow) SetName(name string) { r.v.Name = name }

// GetAlias gets value of column "alias" from "product" row
func (r *ProductRow) GetAlias() string { return r.v.Alias }

// SetAlias sets value of column "alias" in "product" row
func (r *ProductRow) SetAlias(alias string) { r.v.Alias = alias }

// GetStocked gets value of column "stocked" from "product" row
func (r *ProductRow) GetStocked() time.Time { return r.v.Stocked }

// SetStocked sets value of column "stocked" in "product" row
func (r *ProductRow) SetStocked(stocked time.Time) { r.v.Stocked = stocked }

// GetSold gets value of column "sold" from "product" row
func (r *ProductRow) GetSold() time.Time { return *r.v.Sold }

// SetSold sets value of column "sold" in "product" row
func (r *ProductRow) SetSold(sold time.Time) { r.v.Sold = &sold }

// ClearSold sets value of column "sold" null in "product" row
func (r *ProductRow) ClearSold() { r.v.Sold = nil }

// HasValidSold checks to value of column "sold" is not null
func (r *ProductRow) HasValidSold() bool { return r.v.Sold != nil }

// ProductID represents key defined by PRIMARY KEY constraint "product_pkey" for table "product"
type ProductID struct {
	ID int32 `json:"id"`
}

func (r *ProductRow) KeyID() ProductID {
	return ProductID{r.GetID()}
}

// ProductAlias represents key defined by UNIQUE constraint "product_alias_key" for table "product"
type ProductAlias struct {
	Alias string `json:"alias"`
}

func (r *ProductRow) KeyAlias() ProductAlias {
	return ProductAlias{r.GetAlias()}
}

// ProductRows represents multiple rows for table "product"
type ProductRows []*ProductRow

// ProductIDKeyset is a set of key ProductID
type ProductIDKeyset map[ProductID]struct{}

func (rs ProductRows) KeyID() (keys ProductIDKeyset) {
	keys = make(ProductIDKeyset)
	for _, r := range rs {
		keys[r.KeyID()] = struct{}{}
	}
	return keys
}

// ProductAliasKeyset is a set of key ProductAlias
type ProductAliasKeyset map[ProductAlias]struct{}

func (rs ProductRows) KeyAlias() (keys ProductAliasKeyset) {
	keys = make(ProductAliasKeyset)
	for _, r := range rs {
		keys[r.KeyAlias()] = struct{}{}
	}
	return keys
}

// NewProductTable(h SQLHandle) creates new ProductTable
func NewProductTable(h SQLHandle) *ProductTable {
	return &ProductTable{h}
}

// ProductTable provides access methods for table "product"
type ProductTable struct {
	h SQLHandle
}

func (t *ProductTable) Find(ctx context.Context, filter ProductValues) (ProductRows, error) {
	return FindProductRows(ctx, t.h, filter)
}

func (t *ProductTable) Count(ctx context.Context, filter ProductValues) (int, error) {
	return CountProductRows(ctx, t.h, filter)
}

func (t *ProductTable) Update(ctx context.Context, changeset, filter ProductValues) (int64, error) {
	return UpdateProductRows(ctx, t.h, changeset, filter)
}

func (t *ProductTable) Insert(ctx context.Context, rows ...*ProductRow) (int, error) {
	return InsertReturningProductRows(ctx, t.h, rows...)
}

func (t *ProductTable) Delete(ctx context.Context, filter ProductValues) (int64, error) {
	return DeleteProductRows(ctx, t.h, filter)
}

func (t *ProductTable) Save(ctx context.Context, rows ...*ProductRow) error {
	return SaveReturningProductRows(ctx, t.h, rows...)
}

func (t *ProductTable) GetByID(ctx context.Context, keys ...ProductID) (ProductRows, error) {
	return GetProductRowsByID(ctx, t.h, keys...)
}

func (t *ProductTable) UpdateByID(ctx context.Context, changeset ProductValues, keys ...ProductID) (int64, error) {
	return UpdateProductRowsByID(ctx, t.h, changeset, keys...)
}

func (t *ProductTable) DeleteByID(ctx context.Context, keys ...ProductID) (int64, error) {
	return DeleteProductRowsByID(ctx, t.h, keys...)
}

func (t *ProductTable) GetByAlias(ctx context.Context, keys ...ProductAlias) (ProductRows, error) {
	return GetProductRowsByAlias(ctx, t.h, keys...)
}

func (t *ProductTable) UpdateByAlias(ctx context.Context, changeset ProductValues, keys ...ProductAlias) (int64, error) {
	return UpdateProductRowsByAlias(ctx, t.h, changeset, keys...)
}

func (t *ProductTable) DeleteByAlias(ctx context.Context, keys ...ProductAlias) (int64, error) {
	return DeleteProductRowsByAlias(ctx, t.h, keys...)
}

type ProductValues struct {
	ID      *int32     `json:"id"`
	Price   *string    `json:"price"`
	Name    *string    `json:"name"`
	Alias   *string    `json:"alias"`
	Stocked *time.Time `json:"stocked"`
	Sold    *time.Time `json:"sold"`
}

// InsertProductRows inserts the rows into table "product"
func InsertProductRows(ctx context.Context, db SQLHandle, rows ...*ProductRow) (affected int64, err error) {
	affected, err = execWithJSONArgs(ctx, db, sqlInsertProductRows, rows)
	if err != nil {
		return affected, formatError("InsertProductRows", err)
	}
	return affected, nil
}

// InsertReturningProductRows inserts the rows into table "product" and returns the rows.
func InsertReturningProductRows(ctx context.Context, db SQLHandle, inputs ...*ProductRow) (affected int, err error) {
	rows := ProductRows(inputs)
	affected, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlInsertReturningProductRows, rows)
	if err != nil {
		return affected, formatError("InsertReturningProductRows", err)
	}
	return affected, nil
}

// FindProductRows finds the rows matching the condition from table "product"
func FindProductRows(ctx context.Context, db SQLHandle, cond ProductValues) (rows ProductRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlFindProductRows, cond); err != nil {
		return nil, err
	}
	return rows, nil
}

// DeleteProductRows deletes the rows matching the condition from table "product"
func DeleteProductRows(ctx context.Context, db SQLHandle, cond ProductValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlDeleteProductRows, cond)
}

func UpdateProductRows(ctx context.Context, db SQLHandle, changeset, filter ProductValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlUpdateProductRows, changeset, filter)
}

// CountProductRows counts the number of rows matching the condition from table "product"
func CountProductRows(ctx context.Context, db SQLHandle, cond ProductValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, sqlCountProductRows, cond); err != nil {
		return 0, err
	}
	return count, nil
}

// SaveProductRows upserts the given rows for table "product" checking uniqueness by contstraint "product_pkey"
func SaveProductRows(ctx context.Context, db SQLHandle, rows ...*ProductRow) (err error) {
	numRows, err := execWithJSONArgs(ctx, db, sqlSaveProductRows, rows)
	if err != nil {
		return formatError("Save", err)
	}
	if int64(len(rows)) != numRows {
		return formatError("Save", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// SaveReturningProductRows upserts the given rows for table "product" checking uniqueness by contstraint "product_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningProductRows(ctx context.Context, db SQLHandle, inputs ...*ProductRow) (err error) {
	rows := ProductRows(inputs)
	numRows, err := queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlSaveReturningProductRows, rows)
	if err != nil {
		return formatError("SaveReturning", err)
	}
	if len(rows) != numRows {
		return formatError("SaveReturning", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// GetProductRowsByID gets matching rows for given ID keys from table "product"
func GetProductRowsByID(ctx context.Context, db SQLHandle, keys ...ProductID) (rows ProductRows, err error) {
	rows = make(ProductRows, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlGetProductRowsByID, keys); err != nil {
		return nil, formatError("GetProductRowsByID", err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].KeyID() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// DeleteProductRowsByID deletes matching rows by ProductID keys from table "product"
func DeleteProductRowsByID(ctx context.Context, db SQLHandle, keys ...ProductID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlDeleteProductRowsByID, keys)
	if err != nil {
		return numRows, formatError("DeleteByID", err)
	}
	return numRows, nil
}

// UpdateProductRowsByID deletes matching rows by ProductID keys from table "product"
func UpdateProductRowsByID(ctx context.Context, db SQLHandle, changeset ProductValues, keys ...ProductID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlUpdateProductRowsByID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateByID", err)
	}
	return numRows, nil
}

// GetProductRowsByAlias gets matching rows for given Alias keys from table "product"
func GetProductRowsByAlias(ctx context.Context, db SQLHandle, keys ...ProductAlias) (rows ProductRows, err error) {
	rows = make(ProductRows, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlGetProductRowsByAlias, keys); err != nil {
		return nil, formatError("GetProductRowsByAlias", err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].KeyAlias() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// DeleteProductRowsByAlias deletes matching rows by ProductAlias keys from table "product"
func DeleteProductRowsByAlias(ctx context.Context, db SQLHandle, keys ...ProductAlias) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlDeleteProductRowsByAlias, keys)
	if err != nil {
		return numRows, formatError("DeleteByAlias", err)
	}
	return numRows, nil
}

// UpdateProductRowsByAlias deletes matching rows by ProductAlias keys from table "product"
func UpdateProductRowsByAlias(ctx context.Context, db SQLHandle, changeset ProductValues, keys ...ProductAlias) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlUpdateProductRowsByAlias, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateByAlias", err)
	}
	return numRows, nil
}

func (r *ProductRow) ReceiveRow() []interface{} {
	return []interface{}{&r.v.ID, &r.v.Price, &r.v.Name, &r.v.Alias, &r.v.Stocked, &r.v.Sold}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *ProductRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(ProductRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(ProductRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *ProductRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.v)
}

func (keyset ProductIDKeyset) Keys() (keys []ProductID) {
	for k := range keyset {
		keys = append(keys, k)
	}
	return keys
}

func (keyset ProductIDKeyset) Add(keys ...ProductID) {
	for _, k := range keys {
		keyset[k] = struct{}{}
	}
}

func (keyset ProductIDKeyset) Remove(keys ...ProductID) {
	for _, k := range keys {
		delete(keyset, k)
	}
}
func (keyset ProductAliasKeyset) Keys() (keys []ProductAlias) {
	for k := range keyset {
		keys = append(keys, k)
	}
	return keys
}

func (keyset ProductAliasKeyset) Add(keys ...ProductAlias) {
	for _, k := range keys {
		keyset[k] = struct{}{}
	}
}

func (keyset ProductAliasKeyset) Remove(keys ...ProductAlias) {
	for _, k := range keys {
		delete(keyset, k)
	}
}

var (
	sqlFindProductRows = `
		WITH __f AS (SELECT "id", "price", "name", "alias", "stocked", "sold" FROM json_populate_record(null::"wise"."product", $1))
		SELECT __t.id, __t.price, __t.name, __t.alias, __t.stocked, __t.sold
		FROM "wise"."product" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."price" IS NULL FROM __f) OR (SELECT __f."price" = __t."price" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."alias" IS NULL FROM __f) OR (SELECT __f."alias" = __t."alias" FROM __f))
			AND ((SELECT __f."stocked" IS NULL FROM __f) OR (SELECT __f."stocked" = __t."stocked" FROM __f))
			AND ((SELECT __f."sold" IS NULL FROM __f) OR (SELECT __f."sold" = __t."sold" FROM __f))`
	sqlCountProductRows = `
		WITH __f AS (SELECT "id", "price", "name", "alias", "stocked", "sold" FROM json_populate_record(null::"wise"."product", $1))
		SELECT count(*) FROM "wise"."product" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."price" IS NULL FROM __f) OR (SELECT __f."price" = __t."price" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."alias" IS NULL FROM __f) OR (SELECT __f."alias" = __t."alias" FROM __f))
			AND ((SELECT __f."stocked" IS NULL FROM __f) OR (SELECT __f."stocked" = __t."stocked" FROM __f))
			AND ((SELECT __f."sold" IS NULL FROM __f) OR (SELECT __f."sold" = __t."sold" FROM __f))`
	sqlReturningProductRows = `
		RETURNING "id", "price", "name", "alias", "stocked", "sold"`
	sqlInsertProductRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."product", $1))
		INSERT INTO "wise"."product" AS __t ("id", "price", "name", "alias", "stocked", "sold")
		SELECT 
			COALESCE(__v."id", nextval('wise.product_id_seq'::regclass)), 
			__v."price", 
			__v."name", 
			__v."alias", 
			__v."stocked", 
			__v."sold" FROM __v`
	sqlInsertReturningProductRows = sqlInsertProductRows + sqlReturningProductRows
	sqlDeleteProductRows          = `
		DELETE FROM "wise"."product" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS integer) = __t."id")
			AND (($1::json->>'price' IS NULL) OR CAST($1::json->>'price' AS money) = __t."price")
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS character varying) = __t."name")
			AND (($1::json->>'alias' IS NULL) OR CAST($1::json->>'alias' AS character varying) = __t."alias")
			AND (($1::json->>'stocked' IS NULL) OR CAST($1::json->>'stocked' AS timestamp with time zone) = __t."stocked")
			AND (($1::json->>'sold' IS NULL) OR CAST($1::json->>'sold' AS timestamp with time zone) = __t."sold")`
	sqlDeleteReturningProductRows = sqlDeleteProductRows + sqlReturningProductRows
	sqlUpdateProductRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."product", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."product", $2))
		UPDATE "wise"."product" AS __t
		SET ("id", "price", "name", "alias", "stocked", "sold") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."price", __t."price"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."alias", __t."alias"), 
			COALESCE(__v."stocked", __t."stocked"), 
			COALESCE(__v."sold", __t."sold") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."price" IS NULL FROM __f) OR (SELECT __f."price" = __t."price" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."alias" IS NULL FROM __f) OR (SELECT __f."alias" = __t."alias" FROM __f))
			AND ((SELECT __f."stocked" IS NULL FROM __f) OR (SELECT __f."stocked" = __t."stocked" FROM __f))
			AND ((SELECT __f."sold" IS NULL FROM __f) OR (SELECT __f."sold" = __t."sold" FROM __f))`
	sqlUpdateReturningProductRows = sqlUpdateProductRows + sqlReturningProductRows
	sqlReplaceProductRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."product", $1))
		UPDATE "wise"."product" AS __t
			SET ("id", "price", "name", "alias", "stocked", "sold") = (SELECT 
				COALESCE(__v."id", __t."id"), 
				COALESCE(__v."price", __t."price"), 
				COALESCE(__v."name", __t."name"), 
				COALESCE(__v."alias", __t."alias"), 
				COALESCE(__v."stocked", __t."stocked"), 
				COALESCE(__v."sold", __t."sold")
			FROM __v WHERE __v."id" = __t."id")
		FROM __v WHERE __v."id" = __t."id"`
	sqlReplaceReturningProductRows = sqlReplaceProductRows + sqlReturningProductRows
	sqlSaveProductRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."product", $1))
		INSERT INTO "wise"."product" AS __t ("id", "price", "name", "alias", "stocked", "sold")
		SELECT 
			COALESCE(__v."id", nextval('wise.product_id_seq'::regclass)), 
			__v."price", 
			__v."name", 
			__v."alias", 
			__v."stocked", 
			__v."sold" FROM __v
		ON CONFLICT ("id") DO UPDATE
		SET ("id", "price", "name", "alias", "stocked", "sold") = (
			SELECT "id", "price", "name", "alias", "stocked", "sold" FROM __v
			WHERE __v."id" = __t."id"
		)`
	sqlSaveReturningProductRows = sqlSaveProductRows + sqlReturningProductRows
	sqlGetProductRowsByID       = `
		WITH __key AS (SELECT ROW_NUMBER() over () __idx, "id" FROM json_populate_recordset(null::"wise"."product", $1))
		SELECT "id", "price", "name", "alias", "stocked", "sold"
		FROM __key JOIN "wise"."product" AS __t USING ("id")
		ORDER BY __idx`
	sqlUpdateProductRowsByID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."product", $1)),
		  __key AS (SELECT id FROM json_populate_recordset(null::"wise"."product", $2))
		UPDATE "wise"."product" AS __t
		SET ("id", "price", "name", "alias", "stocked", "sold") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."price", __t."price"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."alias", __t."alias"), 
			COALESCE(__v."stocked", __t."stocked"), 
			COALESCE(__v."sold", __t."sold")
		FROM __v)
		FROM __key WHERE (__key."id" = __t."id")`
	sqlDeleteProductRowsByID = `
		WITH __key AS (SELECT id FROM json_populate_recordset(null::"wise"."product", $1))
		DELETE FROM "wise"."product" AS __t USING __key WHERE (__key."id" = __t."id")`
	sqlDeleteReturningProductRowsByID = sqlDeleteProductRowsByID + sqlReturningProductRows
	sqlGetProductRowsByAlias          = `
		WITH __key AS (SELECT ROW_NUMBER() over () __idx, "alias" FROM json_populate_recordset(null::"wise"."product", $1))
		SELECT "id", "price", "name", "alias", "stocked", "sold"
		FROM __key JOIN "wise"."product" AS __t USING ("alias")
		ORDER BY __idx`
	sqlUpdateProductRowsByAlias = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."product", $1)),
		  __key AS (SELECT alias FROM json_populate_recordset(null::"wise"."product", $2))
		UPDATE "wise"."product" AS __t
		SET ("id", "price", "name", "alias", "stocked", "sold") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."price", __t."price"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."alias", __t."alias"), 
			COALESCE(__v."stocked", __t."stocked"), 
			COALESCE(__v."sold", __t."sold")
		FROM __v)
		FROM __key WHERE (__key."alias" = __t."alias")`
	sqlDeleteProductRowsByAlias = `
		WITH __key AS (SELECT alias FROM json_populate_recordset(null::"wise"."product", $1))
		DELETE FROM "wise"."product" AS __t USING __key WHERE (__key."alias" = __t."alias")`
	sqlDeleteReturningProductRowsByAlias = sqlDeleteProductRowsByAlias + sqlReturningProductRows
)

// PopRow represents a row for table "pop"
type PopRow struct {
	v PopData
}

type PopData struct {
	Name        string `json:"name"`
	Year        int32  `json:"year"`
	Description string `json:"description"`
}

func NewPopRow(data PopData) *PopRow {
	return &PopRow{data}
}

func NewPopRows(data ...PopData) PopRows {
	rows := make(PopRows, len(data))
	for i, d := range data {
		rows[i] = NewPopRow(d)
	}
	return rows
}

// GetName gets value of column "name" from "pop" row
func (r *PopRow) GetName() string { return r.v.Name }

// SetName sets value of column "name" in "pop" row
func (r *PopRow) SetName(name string) { r.v.Name = name }

// GetYear gets value of column "year" from "pop" row
func (r *PopRow) GetYear() int32 { return r.v.Year }

// SetYear sets value of column "year" in "pop" row
func (r *PopRow) SetYear(year int32) { r.v.Year = year }

// GetDescription gets value of column "description" from "pop" row
func (r *PopRow) GetDescription() string { return r.v.Description }

// SetDescription sets value of column "description" in "pop" row
func (r *PopRow) SetDescription(description string) { r.v.Description = description }

// PopNameYear represents key defined by PRIMARY KEY constraint "pop_pkey" for table "pop"
type PopNameYear struct {
	Name string `json:"name"`
	Year int32  `json:"year"`
}

func (r *PopRow) KeyNameYear() PopNameYear {
	return PopNameYear{r.GetName(), r.GetYear()}
}

// PopRows represents multiple rows for table "pop"
type PopRows []*PopRow

// PopNameYearKeyset is a set of key PopNameYear
type PopNameYearKeyset map[PopNameYear]struct{}

func (rs PopRows) KeyNameYear() (keys PopNameYearKeyset) {
	keys = make(PopNameYearKeyset)
	for _, r := range rs {
		keys[r.KeyNameYear()] = struct{}{}
	}
	return keys
}

// NewPopTable(h SQLHandle) creates new PopTable
func NewPopTable(h SQLHandle) *PopTable {
	return &PopTable{h}
}

// PopTable provides access methods for table "pop"
type PopTable struct {
	h SQLHandle
}

func (t *PopTable) Find(ctx context.Context, filter PopValues) (PopRows, error) {
	return FindPopRows(ctx, t.h, filter)
}

func (t *PopTable) Count(ctx context.Context, filter PopValues) (int, error) {
	return CountPopRows(ctx, t.h, filter)
}

func (t *PopTable) Update(ctx context.Context, changeset, filter PopValues) (int64, error) {
	return UpdatePopRows(ctx, t.h, changeset, filter)
}

func (t *PopTable) Insert(ctx context.Context, rows ...*PopRow) (int, error) {
	return InsertReturningPopRows(ctx, t.h, rows...)
}

func (t *PopTable) Delete(ctx context.Context, filter PopValues) (int64, error) {
	return DeletePopRows(ctx, t.h, filter)
}

func (t *PopTable) Save(ctx context.Context, rows ...*PopRow) error {
	return SaveReturningPopRows(ctx, t.h, rows...)
}

func (t *PopTable) GetByNameYear(ctx context.Context, keys ...PopNameYear) (PopRows, error) {
	return GetPopRowsByNameYear(ctx, t.h, keys...)
}

func (t *PopTable) UpdateByNameYear(ctx context.Context, changeset PopValues, keys ...PopNameYear) (int64, error) {
	return UpdatePopRowsByNameYear(ctx, t.h, changeset, keys...)
}

func (t *PopTable) DeleteByNameYear(ctx context.Context, keys ...PopNameYear) (int64, error) {
	return DeletePopRowsByNameYear(ctx, t.h, keys...)
}

type PopValues struct {
	Name        *string `json:"name"`
	Year        *int32  `json:"year"`
	Description *string `json:"description"`
}

// InsertPopRows inserts the rows into table "pop"
func InsertPopRows(ctx context.Context, db SQLHandle, rows ...*PopRow) (affected int64, err error) {
	affected, err = execWithJSONArgs(ctx, db, sqlInsertPopRows, rows)
	if err != nil {
		return affected, formatError("InsertPopRows", err)
	}
	return affected, nil
}

// InsertReturningPopRows inserts the rows into table "pop" and returns the rows.
func InsertReturningPopRows(ctx context.Context, db SQLHandle, inputs ...*PopRow) (affected int, err error) {
	rows := PopRows(inputs)
	affected, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlInsertReturningPopRows, rows)
	if err != nil {
		return affected, formatError("InsertReturningPopRows", err)
	}
	return affected, nil
}

// FindPopRows finds the rows matching the condition from table "pop"
func FindPopRows(ctx context.Context, db SQLHandle, cond PopValues) (rows PopRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlFindPopRows, cond); err != nil {
		return nil, err
	}
	return rows, nil
}

// DeletePopRows deletes the rows matching the condition from table "pop"
func DeletePopRows(ctx context.Context, db SQLHandle, cond PopValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlDeletePopRows, cond)
}

func UpdatePopRows(ctx context.Context, db SQLHandle, changeset, filter PopValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlUpdatePopRows, changeset, filter)
}

// CountPopRows counts the number of rows matching the condition from table "pop"
func CountPopRows(ctx context.Context, db SQLHandle, cond PopValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, sqlCountPopRows, cond); err != nil {
		return 0, err
	}
	return count, nil
}

// SavePopRows upserts the given rows for table "pop" checking uniqueness by contstraint "pop_pkey"
func SavePopRows(ctx context.Context, db SQLHandle, rows ...*PopRow) (err error) {
	numRows, err := execWithJSONArgs(ctx, db, sqlSavePopRows, rows)
	if err != nil {
		return formatError("Save", err)
	}
	if int64(len(rows)) != numRows {
		return formatError("Save", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// SaveReturningPopRows upserts the given rows for table "pop" checking uniqueness by contstraint "pop_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningPopRows(ctx context.Context, db SQLHandle, inputs ...*PopRow) (err error) {
	rows := PopRows(inputs)
	numRows, err := queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlSaveReturningPopRows, rows)
	if err != nil {
		return formatError("SaveReturning", err)
	}
	if len(rows) != numRows {
		return formatError("SaveReturning", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// GetPopRowsByNameYear gets matching rows for given NameYear keys from table "pop"
func GetPopRowsByNameYear(ctx context.Context, db SQLHandle, keys ...PopNameYear) (rows PopRows, err error) {
	rows = make(PopRows, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlGetPopRowsByNameYear, keys); err != nil {
		return nil, formatError("GetPopRowsByNameYear", err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].KeyNameYear() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// DeletePopRowsByNameYear deletes matching rows by PopNameYear keys from table "pop"
func DeletePopRowsByNameYear(ctx context.Context, db SQLHandle, keys ...PopNameYear) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlDeletePopRowsByNameYear, keys)
	if err != nil {
		return numRows, formatError("DeleteByNameYear", err)
	}
	return numRows, nil
}

// UpdatePopRowsByNameYear deletes matching rows by PopNameYear keys from table "pop"
func UpdatePopRowsByNameYear(ctx context.Context, db SQLHandle, changeset PopValues, keys ...PopNameYear) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlUpdatePopRowsByNameYear, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateByNameYear", err)
	}
	return numRows, nil
}

func (r *PopRow) ReceiveRow() []interface{} {
	return []interface{}{&r.v.Name, &r.v.Year, &r.v.Description}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PopRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PopRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PopRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PopRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.v)
}

func (keyset PopNameYearKeyset) Keys() (keys []PopNameYear) {
	for k := range keyset {
		keys = append(keys, k)
	}
	return keys
}

func (keyset PopNameYearKeyset) Add(keys ...PopNameYear) {
	for _, k := range keys {
		keyset[k] = struct{}{}
	}
}

func (keyset PopNameYearKeyset) Remove(keys ...PopNameYear) {
	for _, k := range keys {
		delete(keyset, k)
	}
}

var (
	sqlFindPopRows = `
		WITH __f AS (SELECT "name", "year", "description" FROM json_populate_record(null::"wise"."pop", $1))
		SELECT __t.name, __t.year, __t.description
		FROM "wise"."pop" AS __t
		WHERE ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."year" IS NULL FROM __f) OR (SELECT __f."year" = __t."year" FROM __f))
			AND ((SELECT __f."description" IS NULL FROM __f) OR (SELECT __f."description" = __t."description" FROM __f))`
	sqlCountPopRows = `
		WITH __f AS (SELECT "name", "year", "description" FROM json_populate_record(null::"wise"."pop", $1))
		SELECT count(*) FROM "wise"."pop" AS __t
		WHERE ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."year" IS NULL FROM __f) OR (SELECT __f."year" = __t."year" FROM __f))
			AND ((SELECT __f."description" IS NULL FROM __f) OR (SELECT __f."description" = __t."description" FROM __f))`
	sqlReturningPopRows = `
		RETURNING "name", "year", "description"`
	sqlInsertPopRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."pop", $1))
		INSERT INTO "wise"."pop" AS __t ("name", "year", "description")
		SELECT 
			__v."name", 
			__v."year", 
			__v."description" FROM __v`
	sqlInsertReturningPopRows = sqlInsertPopRows + sqlReturningPopRows
	sqlDeletePopRows          = `
		DELETE FROM "wise"."pop" AS __t
		WHERE TRUE
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS text) = __t."name")
			AND (($1::json->>'year' IS NULL) OR CAST($1::json->>'year' AS integer) = __t."year")
			AND (($1::json->>'description' IS NULL) OR CAST($1::json->>'description' AS text) = __t."description")`
	sqlDeleteReturningPopRows = sqlDeletePopRows + sqlReturningPopRows
	sqlUpdatePopRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."pop", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."pop", $2))
		UPDATE "wise"."pop" AS __t
		SET ("name", "year", "description") = (SELECT 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."year", __t."year"), 
			COALESCE(__v."description", __t."description") FROM __v)
		WHERE ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."year" IS NULL FROM __f) OR (SELECT __f."year" = __t."year" FROM __f))
			AND ((SELECT __f."description" IS NULL FROM __f) OR (SELECT __f."description" = __t."description" FROM __f))`
	sqlUpdateReturningPopRows = sqlUpdatePopRows + sqlReturningPopRows
	sqlReplacePopRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."pop", $1))
		UPDATE "wise"."pop" AS __t
			SET ("name", "year", "description") = (SELECT 
				COALESCE(__v."name", __t."name"), 
				COALESCE(__v."year", __t."year"), 
				COALESCE(__v."description", __t."description")
			FROM __v WHERE __v."name" = __t."name" AND __v."year" = __t."year")
		FROM __v WHERE __v."name" = __t."name" AND __v."year" = __t."year"`
	sqlReplaceReturningPopRows = sqlReplacePopRows + sqlReturningPopRows
	sqlSavePopRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."pop", $1))
		INSERT INTO "wise"."pop" AS __t ("name", "year", "description")
		SELECT 
			__v."name", 
			__v."year", 
			__v."description" FROM __v
		ON CONFLICT ("name", "year") DO UPDATE
		SET ("name", "year", "description") = (
			SELECT "name", "year", "description" FROM __v
			WHERE __v."name" = __t."name"
				AND __v."year" = __t."year"
		)`
	sqlSaveReturningPopRows = sqlSavePopRows + sqlReturningPopRows
	sqlGetPopRowsByNameYear = `
		WITH __key AS (SELECT ROW_NUMBER() over () __idx, "name", "year" FROM json_populate_recordset(null::"wise"."pop", $1))
		SELECT "name", "year", "description"
		FROM __key JOIN "wise"."pop" AS __t USING ("name", "year")
		ORDER BY __idx`
	sqlUpdatePopRowsByNameYear = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."pop", $1)),
		  __key AS (SELECT name, year FROM json_populate_recordset(null::"wise"."pop", $2))
		UPDATE "wise"."pop" AS __t
		SET ("name", "year", "description") = (SELECT
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."year", __t."year"), 
			COALESCE(__v."description", __t."description")
		FROM __v)
		FROM __key WHERE (__key."name" = __t."name")AND (__key."year" = __t."year")`
	sqlDeletePopRowsByNameYear = `
		WITH __key AS (SELECT name, year FROM json_populate_recordset(null::"wise"."pop", $1))
		DELETE FROM "wise"."pop" AS __t USING __key WHERE (__key."name" = __t."name") AND (__key."year" = __t."year")`
	sqlDeleteReturningPopRowsByNameYear = sqlDeletePopRowsByNameYear + sqlReturningPopRows
)

// CampaignRow represents a row for table "campaign"
type CampaignRow struct {
	v CampaignData
}

type CampaignData struct {
	ID      string  `json:"id"`
	PopName *string `json:"pop_name"`
	PopYear *int32  `json:"pop_year"`
}

func NewCampaignRow(data CampaignData) *CampaignRow {
	return &CampaignRow{data}
}

func NewCampaignRows(data ...CampaignData) CampaignRows {
	rows := make(CampaignRows, len(data))
	for i, d := range data {
		rows[i] = NewCampaignRow(d)
	}
	return rows
}

// GetID gets value of column "id" from "campaign" row
func (r *CampaignRow) GetID() string { return r.v.ID }

// SetID sets value of column "id" in "campaign" row
func (r *CampaignRow) SetID(id string) { r.v.ID = id }

// GetPopName gets value of column "pop_name" from "campaign" row
func (r *CampaignRow) GetPopName() string { return *r.v.PopName }

// SetPopName sets value of column "pop_name" in "campaign" row
func (r *CampaignRow) SetPopName(popName string) { r.v.PopName = &popName }

// ClearPopName sets value of column "pop_name" null in "campaign" row
func (r *CampaignRow) ClearPopName() { r.v.PopName = nil }

// HasValidPopName checks to value of column "pop_name" is not null
func (r *CampaignRow) HasValidPopName() bool { return r.v.PopName != nil }

// GetPopYear gets value of column "pop_year" from "campaign" row
func (r *CampaignRow) GetPopYear() int32 { return *r.v.PopYear }

// SetPopYear sets value of column "pop_year" in "campaign" row
func (r *CampaignRow) SetPopYear(popYear int32) { r.v.PopYear = &popYear }

// ClearPopYear sets value of column "pop_year" null in "campaign" row
func (r *CampaignRow) ClearPopYear() { r.v.PopYear = nil }

// HasValidPopYear checks to value of column "pop_year" is not null
func (r *CampaignRow) HasValidPopYear() bool { return r.v.PopYear != nil }

// CampaignID represents key defined by PRIMARY KEY constraint "campaign_pkey" for table "campaign"
type CampaignID struct {
	ID string `json:"id"`
}

func (r *CampaignRow) KeyID() CampaignID {
	return CampaignID{r.GetID()}
}

// CampaignRows represents multiple rows for table "campaign"
type CampaignRows []*CampaignRow

// CampaignIDKeyset is a set of key CampaignID
type CampaignIDKeyset map[CampaignID]struct{}

func (rs CampaignRows) KeyID() (keys CampaignIDKeyset) {
	keys = make(CampaignIDKeyset)
	for _, r := range rs {
		keys[r.KeyID()] = struct{}{}
	}
	return keys
}

func (r *CampaignRow) RefPopNamePopYear() PopNameYear {
	return PopNameYear{r.GetPopName(), r.GetPopYear()}
}

func (rs CampaignRows) RefPopNamePopYear() (keys PopNameYearKeyset) {
	keys = make(PopNameYearKeyset)
	for _, r := range rs {
		keys[r.RefPopNamePopYear()] = struct{}{}
	}
	return keys
}

// NewCampaignTable(h SQLHandle) creates new CampaignTable
func NewCampaignTable(h SQLHandle) *CampaignTable {
	return &CampaignTable{h}
}

// CampaignTable provides access methods for table "campaign"
type CampaignTable struct {
	h SQLHandle
}

func (t *CampaignTable) Find(ctx context.Context, filter CampaignValues) (CampaignRows, error) {
	return FindCampaignRows(ctx, t.h, filter)
}

func (t *CampaignTable) Count(ctx context.Context, filter CampaignValues) (int, error) {
	return CountCampaignRows(ctx, t.h, filter)
}

func (t *CampaignTable) Update(ctx context.Context, changeset, filter CampaignValues) (int64, error) {
	return UpdateCampaignRows(ctx, t.h, changeset, filter)
}

func (t *CampaignTable) Insert(ctx context.Context, rows ...*CampaignRow) (int, error) {
	return InsertReturningCampaignRows(ctx, t.h, rows...)
}

func (t *CampaignTable) Delete(ctx context.Context, filter CampaignValues) (int64, error) {
	return DeleteCampaignRows(ctx, t.h, filter)
}

func (t *CampaignTable) Save(ctx context.Context, rows ...*CampaignRow) error {
	return SaveReturningCampaignRows(ctx, t.h, rows...)
}

func (t *CampaignTable) GetByID(ctx context.Context, keys ...CampaignID) (CampaignRows, error) {
	return GetCampaignRowsByID(ctx, t.h, keys...)
}

func (t *CampaignTable) UpdateByID(ctx context.Context, changeset CampaignValues, keys ...CampaignID) (int64, error) {
	return UpdateCampaignRowsByID(ctx, t.h, changeset, keys...)
}

func (t *CampaignTable) DeleteByID(ctx context.Context, keys ...CampaignID) (int64, error) {
	return DeleteCampaignRowsByID(ctx, t.h, keys...)
}

type CampaignValues struct {
	ID      *string `json:"id"`
	PopName *string `json:"pop_name"`
	PopYear *int32  `json:"pop_year"`
}

// InsertCampaignRows inserts the rows into table "campaign"
func InsertCampaignRows(ctx context.Context, db SQLHandle, rows ...*CampaignRow) (affected int64, err error) {
	affected, err = execWithJSONArgs(ctx, db, sqlInsertCampaignRows, rows)
	if err != nil {
		return affected, formatError("InsertCampaignRows", err)
	}
	return affected, nil
}

// InsertReturningCampaignRows inserts the rows into table "campaign" and returns the rows.
func InsertReturningCampaignRows(ctx context.Context, db SQLHandle, inputs ...*CampaignRow) (affected int, err error) {
	rows := CampaignRows(inputs)
	affected, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlInsertReturningCampaignRows, rows)
	if err != nil {
		return affected, formatError("InsertReturningCampaignRows", err)
	}
	return affected, nil
}

// FindCampaignRows finds the rows matching the condition from table "campaign"
func FindCampaignRows(ctx context.Context, db SQLHandle, cond CampaignValues) (rows CampaignRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlFindCampaignRows, cond); err != nil {
		return nil, err
	}
	return rows, nil
}

// DeleteCampaignRows deletes the rows matching the condition from table "campaign"
func DeleteCampaignRows(ctx context.Context, db SQLHandle, cond CampaignValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlDeleteCampaignRows, cond)
}

func UpdateCampaignRows(ctx context.Context, db SQLHandle, changeset, filter CampaignValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlUpdateCampaignRows, changeset, filter)
}

// CountCampaignRows counts the number of rows matching the condition from table "campaign"
func CountCampaignRows(ctx context.Context, db SQLHandle, cond CampaignValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, sqlCountCampaignRows, cond); err != nil {
		return 0, err
	}
	return count, nil
}

// SaveCampaignRows upserts the given rows for table "campaign" checking uniqueness by contstraint "campaign_pkey"
func SaveCampaignRows(ctx context.Context, db SQLHandle, rows ...*CampaignRow) (err error) {
	numRows, err := execWithJSONArgs(ctx, db, sqlSaveCampaignRows, rows)
	if err != nil {
		return formatError("Save", err)
	}
	if int64(len(rows)) != numRows {
		return formatError("Save", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// SaveReturningCampaignRows upserts the given rows for table "campaign" checking uniqueness by contstraint "campaign_pkey"
// It returns the new values and scan them into given row references.
func SaveReturningCampaignRows(ctx context.Context, db SQLHandle, inputs ...*CampaignRow) (err error) {
	rows := CampaignRows(inputs)
	numRows, err := queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlSaveReturningCampaignRows, rows)
	if err != nil {
		return formatError("SaveReturning", err)
	}
	if len(rows) != numRows {
		return formatError("SaveReturning", ErrUnexpectedRowNumberAffected)
	}
	return nil
}

// GetCampaignRowsByID gets matching rows for given ID keys from table "campaign"
func GetCampaignRowsByID(ctx context.Context, db SQLHandle, keys ...CampaignID) (rows CampaignRows, err error) {
	rows = make(CampaignRows, len(keys))
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlGetCampaignRowsByID, keys); err != nil {
		return nil, formatError("GetCampaignRowsByID", err)
	}
	for i := 0; i < len(keys); i++ {
		if rows[i] == nil {
			break
		} else if rows[i].KeyID() != keys[i] {
			copy(rows[i+1:], rows[i:])
			rows[i] = nil
		}
	}
	return rows, nil
}

// DeleteCampaignRowsByID deletes matching rows by CampaignID keys from table "campaign"
func DeleteCampaignRowsByID(ctx context.Context, db SQLHandle, keys ...CampaignID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlDeleteCampaignRowsByID, keys)
	if err != nil {
		return numRows, formatError("DeleteByID", err)
	}
	return numRows, nil
}

// UpdateCampaignRowsByID deletes matching rows by CampaignID keys from table "campaign"
func UpdateCampaignRowsByID(ctx context.Context, db SQLHandle, changeset CampaignValues, keys ...CampaignID) (numRows int64, err error) {
	numRows, err = execWithJSONArgs(ctx, db, sqlUpdateCampaignRowsByID, changeset, keys)
	if err != nil {
		return numRows, formatError("UpdateByID", err)
	}
	return numRows, nil
}

func (r *CampaignRow) ReceiveRow() []interface{} {
	return []interface{}{&r.v.ID, &r.v.PopName, &r.v.PopYear}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *CampaignRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(CampaignRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(CampaignRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *CampaignRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.v)
}

func (keyset CampaignIDKeyset) Keys() (keys []CampaignID) {
	for k := range keyset {
		keys = append(keys, k)
	}
	return keys
}

func (keyset CampaignIDKeyset) Add(keys ...CampaignID) {
	for _, k := range keys {
		keyset[k] = struct{}{}
	}
}

func (keyset CampaignIDKeyset) Remove(keys ...CampaignID) {
	for _, k := range keys {
		delete(keyset, k)
	}
}

var (
	sqlFindCampaignRows = `
		WITH __f AS (SELECT "id", "pop_name", "pop_year" FROM json_populate_record(null::"wise"."campaign", $1))
		SELECT __t.id, __t.pop_name, __t.pop_year
		FROM "wise"."campaign" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."pop_name" IS NULL FROM __f) OR (SELECT __f."pop_name" = __t."pop_name" FROM __f))
			AND ((SELECT __f."pop_year" IS NULL FROM __f) OR (SELECT __f."pop_year" = __t."pop_year" FROM __f))`
	sqlCountCampaignRows = `
		WITH __f AS (SELECT "id", "pop_name", "pop_year" FROM json_populate_record(null::"wise"."campaign", $1))
		SELECT count(*) FROM "wise"."campaign" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."pop_name" IS NULL FROM __f) OR (SELECT __f."pop_name" = __t."pop_name" FROM __f))
			AND ((SELECT __f."pop_year" IS NULL FROM __f) OR (SELECT __f."pop_year" = __t."pop_year" FROM __f))`
	sqlReturningCampaignRows = `
		RETURNING "id", "pop_name", "pop_year"`
	sqlInsertCampaignRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."campaign", $1))
		INSERT INTO "wise"."campaign" AS __t ("id", "pop_name", "pop_year")
		SELECT 
			__v."id", 
			__v."pop_name", 
			__v."pop_year" FROM __v`
	sqlInsertReturningCampaignRows = sqlInsertCampaignRows + sqlReturningCampaignRows
	sqlDeleteCampaignRows          = `
		DELETE FROM "wise"."campaign" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS uuid) = __t."id")
			AND (($1::json->>'pop_name' IS NULL) OR CAST($1::json->>'pop_name' AS text) = __t."pop_name")
			AND (($1::json->>'pop_year' IS NULL) OR CAST($1::json->>'pop_year' AS integer) = __t."pop_year")`
	sqlDeleteReturningCampaignRows = sqlDeleteCampaignRows + sqlReturningCampaignRows
	sqlUpdateCampaignRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."campaign", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."campaign", $2))
		UPDATE "wise"."campaign" AS __t
		SET ("id", "pop_name", "pop_year") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."pop_name", __t."pop_name"), 
			COALESCE(__v."pop_year", __t."pop_year") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."pop_name" IS NULL FROM __f) OR (SELECT __f."pop_name" = __t."pop_name" FROM __f))
			AND ((SELECT __f."pop_year" IS NULL FROM __f) OR (SELECT __f."pop_year" = __t."pop_year" FROM __f))`
	sqlUpdateReturningCampaignRows = sqlUpdateCampaignRows + sqlReturningCampaignRows
	sqlReplaceCampaignRows         = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."campaign", $1))
		UPDATE "wise"."campaign" AS __t
			SET ("id", "pop_name", "pop_year") = (SELECT 
				COALESCE(__v."id", __t."id"), 
				COALESCE(__v."pop_name", __t."pop_name"), 
				COALESCE(__v."pop_year", __t."pop_year")
			FROM __v WHERE __v."id" = __t."id")
		FROM __v WHERE __v."id" = __t."id"`
	sqlReplaceReturningCampaignRows = sqlReplaceCampaignRows + sqlReturningCampaignRows
	sqlSaveCampaignRows             = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."campaign", $1))
		INSERT INTO "wise"."campaign" AS __t ("id", "pop_name", "pop_year")
		SELECT 
			__v."id", 
			__v."pop_name", 
			__v."pop_year" FROM __v
		ON CONFLICT ("id") DO UPDATE
		SET ("id", "pop_name", "pop_year") = (
			SELECT "id", "pop_name", "pop_year" FROM __v
			WHERE __v."id" = __t."id"
		)`
	sqlSaveReturningCampaignRows = sqlSaveCampaignRows + sqlReturningCampaignRows
	sqlGetCampaignRowsByID       = `
		WITH __key AS (SELECT ROW_NUMBER() over () __idx, "id" FROM json_populate_recordset(null::"wise"."campaign", $1))
		SELECT "id", "pop_name", "pop_year"
		FROM __key JOIN "wise"."campaign" AS __t USING ("id")
		ORDER BY __idx`
	sqlUpdateCampaignRowsByID = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."campaign", $1)),
		  __key AS (SELECT id FROM json_populate_recordset(null::"wise"."campaign", $2))
		UPDATE "wise"."campaign" AS __t
		SET ("id", "pop_name", "pop_year") = (SELECT
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."pop_name", __t."pop_name"), 
			COALESCE(__v."pop_year", __t."pop_year")
		FROM __v)
		FROM __key WHERE (__key."id" = __t."id")`
	sqlDeleteCampaignRowsByID = `
		WITH __key AS (SELECT id FROM json_populate_recordset(null::"wise"."campaign", $1))
		DELETE FROM "wise"."campaign" AS __t USING __key WHERE (__key."id" = __t."id")`
	sqlDeleteReturningCampaignRowsByID = sqlDeleteCampaignRowsByID + sqlReturningCampaignRows
)

// PackageAggRow represents a row for table "package_agg"
type PackageAggRow struct {
	v PackageAggData
}

type PackageAggData struct {
	ID        *string `json:"id"`
	Name      *string `json:"name"`
	Available *bool   `json:"available"`
	Count     *int64  `json:"count"`
}

func NewPackageAggRow(data PackageAggData) *PackageAggRow {
	return &PackageAggRow{data}
}

func NewPackageAggRows(data ...PackageAggData) PackageAggRows {
	rows := make(PackageAggRows, len(data))
	for i, d := range data {
		rows[i] = NewPackageAggRow(d)
	}
	return rows
}

// GetID gets value of column "id" from "package_agg" row
func (r *PackageAggRow) GetID() string { return *r.v.ID }

// SetID sets value of column "id" in "package_agg" row
func (r *PackageAggRow) SetID(id string) { r.v.ID = &id }

// ClearID sets value of column "id" null in "package_agg" row
func (r *PackageAggRow) ClearID() { r.v.ID = nil }

// HasValidID checks to value of column "id" is not null
func (r *PackageAggRow) HasValidID() bool { return r.v.ID != nil }

// GetName gets value of column "name" from "package_agg" row
func (r *PackageAggRow) GetName() string { return *r.v.Name }

// SetName sets value of column "name" in "package_agg" row
func (r *PackageAggRow) SetName(name string) { r.v.Name = &name }

// ClearName sets value of column "name" null in "package_agg" row
func (r *PackageAggRow) ClearName() { r.v.Name = nil }

// HasValidName checks to value of column "name" is not null
func (r *PackageAggRow) HasValidName() bool { return r.v.Name != nil }

// GetAvailable gets value of column "available" from "package_agg" row
func (r *PackageAggRow) GetAvailable() bool { return *r.v.Available }

// SetAvailable sets value of column "available" in "package_agg" row
func (r *PackageAggRow) SetAvailable(available bool) { r.v.Available = &available }

// ClearAvailable sets value of column "available" null in "package_agg" row
func (r *PackageAggRow) ClearAvailable() { r.v.Available = nil }

// HasValidAvailable checks to value of column "available" is not null
func (r *PackageAggRow) HasValidAvailable() bool { return r.v.Available != nil }

// GetCount gets value of column "count" from "package_agg" row
func (r *PackageAggRow) GetCount() int64 { return *r.v.Count }

// SetCount sets value of column "count" in "package_agg" row
func (r *PackageAggRow) SetCount(count int64) { r.v.Count = &count }

// ClearCount sets value of column "count" null in "package_agg" row
func (r *PackageAggRow) ClearCount() { r.v.Count = nil }

// HasValidCount checks to value of column "count" is not null
func (r *PackageAggRow) HasValidCount() bool { return r.v.Count != nil }

// PackageAggRows represents multiple rows for table "package_agg"
type PackageAggRows []*PackageAggRow

// NewPackageAggTable(h SQLHandle) creates new PackageAggTable
func NewPackageAggTable(h SQLHandle) *PackageAggTable {
	return &PackageAggTable{h}
}

// PackageAggTable provides access methods for table "package_agg"
type PackageAggTable struct {
	h SQLHandle
}

func (t *PackageAggTable) Find(ctx context.Context, filter PackageAggValues) (PackageAggRows, error) {
	return FindPackageAggRows(ctx, t.h, filter)
}

func (t *PackageAggTable) Count(ctx context.Context, filter PackageAggValues) (int, error) {
	return CountPackageAggRows(ctx, t.h, filter)
}

func (t *PackageAggTable) Update(ctx context.Context, changeset, filter PackageAggValues) (int64, error) {
	return UpdatePackageAggRows(ctx, t.h, changeset, filter)
}

func (t *PackageAggTable) Insert(ctx context.Context, rows ...*PackageAggRow) (int, error) {
	return InsertReturningPackageAggRows(ctx, t.h, rows...)
}

func (t *PackageAggTable) Delete(ctx context.Context, filter PackageAggValues) (int64, error) {
	return DeletePackageAggRows(ctx, t.h, filter)
}

type PackageAggValues struct {
	ID        *string `json:"id"`
	Name      *string `json:"name"`
	Available *bool   `json:"available"`
	Count     *int64  `json:"count"`
}

// InsertPackageAggRows inserts the rows into table "package_agg"
func InsertPackageAggRows(ctx context.Context, db SQLHandle, rows ...*PackageAggRow) (affected int64, err error) {
	affected, err = execWithJSONArgs(ctx, db, sqlInsertPackageAggRows, rows)
	if err != nil {
		return affected, formatError("InsertPackageAggRows", err)
	}
	return affected, nil
}

// InsertReturningPackageAggRows inserts the rows into table "package_agg" and returns the rows.
func InsertReturningPackageAggRows(ctx context.Context, db SQLHandle, inputs ...*PackageAggRow) (affected int, err error) {
	rows := PackageAggRows(inputs)
	affected, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlInsertReturningPackageAggRows, rows)
	if err != nil {
		return affected, formatError("InsertReturningPackageAggRows", err)
	}
	return affected, nil
}

// FindPackageAggRows finds the rows matching the condition from table "package_agg"
func FindPackageAggRows(ctx context.Context, db SQLHandle, cond PackageAggValues) (rows PackageAggRows, err error) {
	if _, err = queryWithJSONArgs(ctx, db, rows.ReceiveRows, sqlFindPackageAggRows, cond); err != nil {
		return nil, err
	}
	return rows, nil
}

// DeletePackageAggRows deletes the rows matching the condition from table "package_agg"
func DeletePackageAggRows(ctx context.Context, db SQLHandle, cond PackageAggValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlDeletePackageAggRows, cond)
}

func UpdatePackageAggRows(ctx context.Context, db SQLHandle, changeset, filter PackageAggValues) (afftected int64, err error) {
	return execWithJSONArgs(ctx, db, sqlUpdatePackageAggRows, changeset, filter)
}

// CountPackageAggRows counts the number of rows matching the condition from table "package_agg"
func CountPackageAggRows(ctx context.Context, db SQLHandle, cond PackageAggValues) (count int, err error) {
	if _, err = queryWithJSONArgs(ctx, db, func(int) []interface{} { return []interface{}{&count} }, sqlCountPackageAggRows, cond); err != nil {
		return 0, err
	}
	return count, nil
}

func (r *PackageAggRow) ReceiveRow() []interface{} {
	return []interface{}{&r.v.ID, &r.v.Name, &r.v.Available, &r.v.Count}
}

// ReceiveRows returns pointer slice to receive data for the row on index i
func (rs *PackageAggRows) ReceiveRows(i int) []interface{} {
	if cap(*rs) <= i {
		source := *rs
		*rs = make(PackageAggRows, i+1)
		copy(*rs, source)
	}
	if (*rs)[i] == nil {
		(*rs)[i] = new(PackageAggRow)
	}
	return (*rs)[i].ReceiveRow()
}

func (r *PackageAggRow) MarshalJSON() ([]byte, error) {
	return json.Marshal(r.v)
}

var (
	sqlFindPackageAggRows = `
		WITH __f AS (SELECT "id", "name", "available", "count" FROM json_populate_record(null::"wise"."package_agg", $1))
		SELECT __t.id, __t.name, __t.available, __t.count
		FROM "wise"."package_agg" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))
			AND ((SELECT __f."count" IS NULL FROM __f) OR (SELECT __f."count" = __t."count" FROM __f))`
	sqlCountPackageAggRows = `
		WITH __f AS (SELECT "id", "name", "available", "count" FROM json_populate_record(null::"wise"."package_agg", $1))
		SELECT count(*) FROM "wise"."package_agg" AS __t
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))
			AND ((SELECT __f."count" IS NULL FROM __f) OR (SELECT __f."count" = __t."count" FROM __f))`
	sqlReturningPackageAggRows = `
		RETURNING "id", "name", "available", "count"`
	sqlInsertPackageAggRows = `
		WITH __v AS (SELECT * FROM json_populate_recordset(null::"wise"."package_agg", $1))
		INSERT INTO "wise"."package_agg" AS __t ("id", "name", "available")
		SELECT 
			__v."id", 
			__v."name", 
			__v."available" FROM __v`
	sqlInsertReturningPackageAggRows = sqlInsertPackageAggRows + sqlReturningPackageAggRows
	sqlDeletePackageAggRows          = `
		DELETE FROM "wise"."package_agg" AS __t
		WHERE TRUE
			AND (($1::json->>'id' IS NULL) OR CAST($1::json->>'id' AS uuid) = __t."id")
			AND (($1::json->>'name' IS NULL) OR CAST($1::json->>'name' AS text) = __t."name")
			AND (($1::json->>'available' IS NULL) OR CAST($1::json->>'available' AS boolean) = __t."available")
			AND (($1::json->>'count' IS NULL) OR CAST($1::json->>'count' AS bigint) = __t."count")`
	sqlDeleteReturningPackageAggRows = sqlDeletePackageAggRows + sqlReturningPackageAggRows
	sqlUpdatePackageAggRows          = `
		WITH __v AS (SELECT * FROM json_populate_record(null::"wise"."package_agg", $1)),
			__f AS (SELECT * FROM json_populate_record(null::"wise"."package_agg", $2))
		UPDATE "wise"."package_agg" AS __t
		SET ("id", "name", "available") = (SELECT 
			COALESCE(__v."id", __t."id"), 
			COALESCE(__v."name", __t."name"), 
			COALESCE(__v."available", __t."available") FROM __v)
		WHERE ((SELECT __f."id" IS NULL FROM __f) OR (SELECT __f."id" = __t."id" FROM __f))
			AND ((SELECT __f."name" IS NULL FROM __f) OR (SELECT __f."name" = __t."name" FROM __f))
			AND ((SELECT __f."available" IS NULL FROM __f) OR (SELECT __f."available" = __t."available" FROM __f))
			AND ((SELECT __f."count" IS NULL FROM __f) OR (SELECT __f."count" = __t."count" FROM __f))`
	sqlUpdateReturningPackageAggRows = sqlUpdatePackageAggRows + sqlReturningPackageAggRows
)

func execWithJSONArgs(ctx context.Context, db SQLHandle, sql string, args ...interface{}) (numRows int64, err error) {
	bArgs := make([]interface{}, len(args))
	for i, arg := range args {
		if bArgs[i], err = json.Marshal(arg); err != nil {
			return 0, err
		}
	}
	return db.ExecAndCount(ctx, sql, bArgs...)
}

func queryWithJSONArgs(ctx context.Context, db SQLHandle, receive func(int) []interface{}, sql string, args ...interface{}) (numRows int, err error) {
	bArgs := make([]interface{}, len(args))
	for i, arg := range args {
		if bArgs[i], err = json.Marshal(arg); err != nil {
			return 0, err
		}
	}
	return db.QueryAndReceive(ctx, receive, sql, bArgs...)
}

func formatError(methodName string, err error) error {
	return fmt.Errorf("%w(%s, %s)", ErrPGMG, methodName, err.Error())
}

var ErrPGMG = fmt.Errorf("errPGMG")
var ErrUnexpectedRowNumberAffected = fmt.Errorf("unexpected row number affected")

type SQLHandle interface {
	QueryAndReceive(ctx context.Context, receiver func(int) []interface{}, sql string, args ...interface{}) (int, error)
	ExecAndCount(ctx context.Context, sql string, args ...interface{}) (int64, error)
}
