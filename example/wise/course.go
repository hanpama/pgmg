// Code generated by github.com/hanpama/pgmg. DO NOT EDIT.
package wise

import (
	"encoding/json"

	"github.com/hanpama/pgmg/dsl"
)

type CourseRow struct {
	ID      int32  `json:"id"`
	Title   string `json:"title"`
	Credits int32  `json:"credits"`
}

// Course represents table course
var Course = newCourseTable("")

func newCourseTable(alias string) *courseTable {
	table := dsl.TableReference{TableSchema: `wise`, TableName: `course`, Alias: alias}
	return &courseTable{
		table,
		courseTableIDColumn{
			dsl.ColumnReference{TableReference: table, ColumnName: "id"},
		},
		courseTableTitleColumn{
			dsl.ColumnReference{TableReference: table, ColumnName: "title"},
		},
		courseTableCreditsColumn{
			dsl.ColumnReference{TableReference: table, ColumnName: "credits"},
		},
	}
}

type courseTable struct {
	dsl.TableReference
	ID      courseTableIDColumn
	Title   courseTableTitleColumn
	Credits courseTableCreditsColumn
}

func (t *courseTable) As(alias string) *courseTable { return newCourseTable(alias) }
func (t *courseTable) AllColumns() []interface{} {
	return []interface{}{t.ID, t.Title, t.Credits}
}

type courseColumnValue interface {
	courseColumn() string
	courseValue() interface{}
}

type CourseValues []courseColumnValue

func (t *courseTable) Values(vals ...courseColumnValue) CourseValues { return vals }

func (t *courseTable) Input(
	title courseTableTitleValue,
	credits courseTableCreditsValue,
	optional ...courseColumnValue,
) CourseValues {
	return append(CourseValues{
		title,
		credits,
	}, optional...)
}

func (vs CourseValues) MarshalJSON() (b []byte, err error) {
	r := make(map[string]interface{})
	for _, v := range vs {
		r[v.courseColumn()] = v.courseValue()
	}
	return json.Marshal(r)
}

type courseTableIDColumn struct{ dsl.ColumnReference }
type courseTableIDValue int32
type courseTableTitleColumn struct{ dsl.ColumnReference }
type courseTableTitleValue string
type courseTableCreditsColumn struct{ dsl.ColumnReference }
type courseTableCreditsValue int32

func (courseTableIDColumn) New(val int32) courseTableIDValue        { return courseTableIDValue(val) }
func (courseTableTitleColumn) New(val string) courseTableTitleValue { return courseTableTitleValue(val) }
func (courseTableCreditsColumn) New(val int32) courseTableCreditsValue {
	return courseTableCreditsValue(val)
}

func (courseTableIDValue) courseColumn() string            { return "id" }
func (v courseTableIDValue) courseValue() interface{}      { return (int32)(v) }
func (courseTableTitleValue) courseColumn() string         { return "title" }
func (v courseTableTitleValue) courseValue() interface{}   { return (string)(v) }
func (courseTableCreditsValue) courseColumn() string       { return "credits" }
func (v courseTableCreditsValue) courseValue() interface{} { return (int32)(v) }

func (r *CourseRow) Receive() []interface{} {
	return []interface{}{&r.ID, &r.Title, &r.Credits}
}

type CourseRows []CourseRow

func (rs *CourseRows) Receive() []interface{} {
	*rs = append(*rs, CourseRow{})
	return (*rs)[len(*rs)-1].Receive()
}

func (t *courseTable) Select() *dsl.SelectQuery {
	return dsl.
		Select(t.AllColumns()...).From(t)
}

func (t *courseTable) InsertOneJSON(jsonExpr interface{}) *dsl.InsertQuery {
	return dsl.
		InsertInto(t, t.AllColumns()...).
		Select(
			dsl.Select(
				dsl.Coalesce(`__iv__."id"`, "nextval('wise.course_id_seq'::regclass)"),
				`__iv__."title"`,
				`__iv__."credits"`,
			).
				Fromf(`json_populate_record(null::%s, %s) AS __iv__`, Course, jsonExpr),
		)
}

func (t *courseTable) InsertManyJSON(jsonExpr interface{}) *dsl.InsertQuery {
	return dsl.
		InsertInto(t, t.AllColumns()...).
		Select(
			dsl.Select(
				dsl.Coalesce(`__iv__."id"`, "nextval('wise.course_id_seq'::regclass)"),
				`__iv__."title"`,
				`__iv__."credits"`,
			).
				Fromf(`json_populate_recordset(null::%s, %s) AS __iv__`, Course, jsonExpr),
		)
}

func (t *courseTable) UpdateJSON(jsonExpr interface{}) *dsl.UpdateQuery {
	return dsl.
		Update(t).
		Set(
			t.ID.Set(dsl.Coalesce(`__ch__."id"`, t.ID)),
			t.Title.Set(dsl.Coalesce(`__ch__."title"`, t.Title)),
			t.Credits.Set(dsl.Coalesce(`__ch__."credits"`, t.Credits)),
		).
		Fromf(`json_populate_record(null::%s, %s) AS __ch__`, Course, jsonExpr)
}

func (t *courseTable) DeleteWhere(cond interface{}) *dsl.DeleteQuery {
	return dsl.
		DeleteFrom(t).Where(dsl.WrapExpr(cond))
}
